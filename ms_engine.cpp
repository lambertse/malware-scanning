#include "ms_engine.h"

#include "ms_return_codes.h"
#include "ms_defines.h"
#include "ms_config.h"
#include "ms_labels.h"
#include "ms_threadpool.h"
#include "ms_buildrp_task.h"

#include <maf/threading/ThreadPoolFactory.h>
#include <maf/threading/IThreadPool.h>

#include "3rdparty/SQLiteCpp/include/SQLiteCpp/SQLiteCpp.h"

#include "path_finder/FinderFactory.h"

using namespace maf::threading;
using namespace owc::finder;

#include <memory>
#include <fstream>
#include <future>
#include <sstream>

namespace 
{
namespace Internal
{
    ms_rc miningScanFiles(std::unordered_set<ms_wstring>& results, FoundCallback foundCallback, FinishedCallback finishedCallback);
    ms_rc generateReqHeader(const MSDict& config, MSDict& desRqHeader);
    // MSDict buildFinalReport(const MSDict& infected, const MSDict& vulnerable, const MSDict& ignored, ms_int totalFileScanned, std::time_t start_time);
}
}

MalwareScanEngine::MalwareScanEngine(){

}
MalwareScanEngine::~MalwareScanEngine()
{

}

ms_rc MalwareScanEngine::_onSignalCome(const MSDict& inDict)
{
    ms_rc rc = MS_OK;
    // _start_time = std::time(nullptr);
    
    // if( MS_FAILED( rc = Internal::miningScanFiles(inDict, this->_files)) ){
    //     return rc;
    // }


    // // for(auto i: scanFiles){
    // //     printf(AxzScuString::toString(i).c_str());
    // //     printf("\n");
    // // }
    


    return rc;
}

ms_rc MalwareScanEngine::init()
{
    ms_rc rc = MS_OK;
    std::shared_ptr<Slot> readingSlot       = std::make_shared<Slot>(1E8, MS_THREAD_COUNT);

    ms_shared_layer_ptr verifyFile          = std::make_shared<VerifyFile>();
    ms_shared_layer_ptr manifestLayer       = std::make_shared<ManifestLayer>();
    ms_shared_layer_ptr cdrLayer            = std::make_shared<CDRLayer>();
    ms_shared_layer_ptr calHash             = std::make_shared<CaculateHashLayer>(readingSlot);
    ms_shared_layer_ptr localhash           = std::make_shared<LocalHashLayer>();
    ms_shared_layer_ptr serverHash          = std::make_shared<ServerHashLayer>();
    ms_shared_layer_ptr upload              = std::make_shared<UploadFileLayer>(1E8, readingSlot);
    ms_shared_layer_ptr queryResult         = std::make_shared<QueryResultLayer>(); 
    ms_shared_layer_ptr externalLayer       = std::make_shared<ExternalLayer>(); 

    verifyFile->setNext(manifestLayer)->setNext(cdrLayer)->setNext(calHash)->setNext(serverHash)->setNext(nullptr);
    _scanConfig = MalwareScanConfig::instance()->getConfig();
    Internal::generateReqHeader(_scanConfig, _reqHeader);
    std::wstring tmp;
    MSJson::serialize(_reqHeader, tmp);

    // ms_int disableHashCheck = CheckHashAndUpload;
    // MSDict scanningPolicy;
    // if( MS_FAILED ( rc = _scanConfig.val(MS_KEY_SCANNING_POLICY, scanningPolicy) )||
    //     MS_FAILED ( rc = scanningPolicy.val(MS_KEY_DISABLE_HASH_CHECK, disableHashCheck ))){
    //         return rc;
    // }
    // switch (disableHashCheck)
    // {
    // case HashCheckType::CheckHashAndUpload :
    //     verifyFile->setNext(manifestLayer)->setNext(cdrLayer)->setNext(calHash)->setNext(localhash)->setNext(serverHash)->setNext(upload)->setNext(queryResult)->setNext(externalLayer)->setNext(nullptr);
    //     break;
    // case HashCheckType::UploadOnly :
    //     verifyFile->setNext(manifestLayer)->setNext(cdrLayer)->setNext(calHash)->setNext(upload)->setNext(queryResult)->setNext(externalLayer)->setNext(externalLayer)->setNext(nullptr);
    //     break;
    // case HashCheckType::CheckHashOnly :
    //     verifyFile->setNext(manifestLayer)->setNext(cdrLayer)->setNext(calHash)->setNext(localhash)->setNext(serverHash)->setNext(externalLayer)->setNext(nullptr);
    //     break;
    // default:
    //     break;
    // }
    _layers = verifyFile;

    return rc;
}

ms_rc MalwareScanEngine::start()
{
    ms_rc rc = MS_OK;

    std::promise<ms_int> tellEngineToStop;
    std::future<ms_int> engineStop = tellEngineToStop.get_future();

   
    std::shared_ptr<MalwareScanBuildRP> buildReportManager = std::make_shared<MalwareScanBuildRP>(std::move(tellEngineToStop));
    ms_shared_pool scanningPool = std::make_shared<ThreadPoolInterface>(MS_THREAD_COUNT);
    ms_uint totalTask = 0;

    owc::finder::FoundCallback onNewFileFound = [&](FoundPathConstInfoPtr info){
        totalTask++;
        MSDict param = ms_dict_object{
            { MS_KEY_FILE_PATH, info->path.wstring() },
            { MS_KEY_REQUEST_HEADER, _reqHeader}, 
            { MS_KEY_CONFIG,    _scanConfig},
        };
        ms_shared_layer_ptr scanTask = std::make_shared<MSScanTask>( _layers, param );
        scanTask->registerCallback([&](const MSDict& scanResult){
            return buildReportManager->onNewFileScanned(scanResult);
        });
        scanTask->setNext(nullptr);
        scanningPool->push(scanTask);
    };
    owc::finder::FinishedCallback onPathFinderFinish = [&](){
        buildReportManager->setTotalTask(totalTask);
    };

    Internal::miningScanFiles( _files, onNewFileFound, onPathFinderFinish);

    engineStop.wait();

    scanningPool->stop();

    return rc;
}

namespace
{
namespace Internal
{
    ms_rc miningScanFiles(std::unordered_set<ms_wstring>& results,  FoundCallback foundCallback, FinishedCallback finishedCallback){
        ms_rc rc = MS_OK;
        ms_wstring path;
        
        auto miningMachine = FinderFactory::createFinder(Type::memory, foundCallback);
        miningMachine->registerFinishedCallback(finishedCallback);
        miningMachine->start();

        return rc;
    }
    ms_rc generateReqHeader(const MSDict &config, MSDict& desRqHeader)
    {
        ms_rc rc = MS_OK;

        MSDict availScanner, defaultScanner;
        if(MS_FAILED ( rc = config.val(MS_KEY_AVAIL_SCANNERS, availScanner))){
            if( !availScanner.isArray() || !availScanner.size() ){
                return MS_ERROR_NON_EXISTENT_SCANNER;
            } 
        }
        defaultScanner = availScanner[0];
        std::wstring tmp;
        MSJson::serialize(defaultScanner, tmp);
        MSDict scanRule;
        ms_wstring url, apiKey, user_agent, rule;
        if( MS_FAILED ( rc = defaultScanner.val(MS_KEY_URL, url))               ||
            MS_FAILED ( rc = defaultScanner.val(MS_KEY_API_KEY_CONFIG, apiKey))        ||
            MS_FAILED ( rc = defaultScanner.val(MS_KEY_SCAN_RULE, scanRule ))   ||
            MS_FAILED ( rc = scanRule.val(MS_KEY_USER_AGENT, user_agent) )      ||
            MS_FAILED ( rc = scanRule.val(MS_KEY_RULE, rule))){
            return rc;
        }
        desRqHeader = ms_dict_object{
            {   MS_KEY_RULE,           rule},
            {   MS_KEY_USER_AGENT,     user_agent},
            {   MS_KEY_WORK_FLOW,      L""},
            {   MS_KEY_ARCHIVEPWD,     L""},
            {   MS_KEY_API_KEY,        apiKey},
            {   MS_KEY_CONTENT_TYPE,   L"application/octet-stream"},
            {   MS_KEY_ACCEPT,         L""},
            {   MS_KEY_EXPECT,         L""},
            {   MS_KEY_USER_HOST_NAME, L""},
            {   MS_KEY_SOURCE,         L""},
            {   MS_KEY_CONNECTION,     L"Keep-Alive"}};
        ms_int r = desRqHeader.isObject();
        return rc;
    }
}
}