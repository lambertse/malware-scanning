#include "ms_engine.h"

#include "ms_return_codes.h"
#include "ms_defines.h"
// #include "ms_config.h"
#include "ms_labels.h"
#include "ms_threadpool.h"
#include "ms_layers.h"

#include <maf/threading/ThreadPoolFactory.h>
#include <maf/threading/IThreadPool.h>

#include "shared/SQLiteCpp/include/SQLiteCpp/SQLiteCpp.h"

#include "path_finder/FinderFactory.h"

using namespace maf::threading;
using namespace owc::finder;

#include <memory>
#include <fstream>
#include <future>
#include <sstream>

namespace 
{
namespace Internal
{
    ms_rc miningScanFiles(const AxzDict& in_dict, std::unordered_set<std::wstring>& results, FoundCallback foundCallback);
    // AxzDict buildFinalReport(const AxzDict& infected, const AxzDict& vulnerable, const AxzDict& ignored, axz_int totalFileScanned, std::time_t start_time);
}
}

MalwareScanEngine::MalwareScanEngine(){

}
MalwareScanEngine::~MalwareScanEngine()
{

}

ms_rc MalwareScanEngine::_onSignalCome(const AxzDict& in_dict)
{
    ms_rc rc = MS_OK;
    // _start_time = std::time(nullptr);
    
    // if( MS_FAILED( rc = Internal::miningScanFiles(in_dict, this->_files)) ){
    //     return rc;
    // }


    // // for(auto i: scanFiles){
    // //     printf(AxzScuString::toString(i).c_str());
    // //     printf("\n");
    // // }
    


    return rc;
}

ms_rc MalwareScanEngine::test(const AxzDict& in_dict , AxzDict& out_dict){
    try {
        // Open a connection to the database
        SQLite::Database db("/usr/opsw/usr.db", SQLite::OPEN_READWRITE | SQLite::OPEN_CREATE);

        // Create a table if it doesn't exist
        db.exec("CREATE TABLE IF NOT EXISTS mytable (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)");

        // // Insert data into the table
        SQLite::Statement query(db, "INSERT INTO mytable (name, age) VALUES (?, ?)");
        query.bind(1, "Tri");
        query.bind(2, 21);
        query.exec();

        // Query data from the table
        SQLite::Statement query2(db, "SELECT * FROM mytable");
        while (query2.executeStep()) {
            int id = query2.getColumn(0);
            std::string name = query2.getColumn(1);
            int age = query2.getColumn(2);

            // Process the retrieved data
            std::cout << "ID: " << id << ", Name: " << name << ", Age: " << age << std::endl;
        }
    } catch (std::exception& e) {
        std::cerr << "SQLite error: " << e.what() << std::endl;
        return 1;
    }

}

ms_rc MalwareScanEngine::start(const AxzDict& in_dict , AxzDict& out_dict)
{
    ms_rc rc = MS_OK;


    std::promise<int> tellEngineToStop;
    std::future<int> engineStop = tellEngineToStop.get_future();

    ms_shared_layer_ptr manifestLayer = std::make_shared<ManifestLayer>();
    ms_shared_layer_ptr cdrLayer = std::make_shared<CDRLayer>();
    // ms_shared_layer_ptr calHash = std::make_shared<CaculateHashLayer>(1E6);
    std::shared_ptr<Slot> cr = std::make_shared<Slot>(1E8);
    ms_shared_layer_ptr calHash = std::make_shared<CaculateHashLayer>(cr);
    ms_shared_layer_ptr localhash = std::make_shared<LocalHashLayer>();
    ms_shared_layer_ptr serverHash = std::make_shared<ServerHashLayer>();
    ms_shared_layer_ptr upload = std::make_shared<UploadFileLayer>();
    // manifestLayer->setNext(cdrLayer)->setNext(calHash)->setNext(localhash)->setNext(serverHash)->setNext(upload)->setNext(nullptr);
    manifestLayer->setNext(cdrLayer)->setNext(calHash)->setNext(upload)->setNext(nullptr);   
    ms_shared_pool scanningPool = std::make_shared<ThreadPoolInterface>(5);
    Internal::miningScanFiles(in_dict, _files, [&scanningPool, &manifestLayer](FoundPathConstInfoPtr info){
        AxzDict param{AxzDictType::OBJECT};
        // std::cout << "Found: " << info->path.string() << std::endl;
        param.add(MS_KEY_PATH, info->path.wstring());
        ms_shared_scan_task scanTask = std::make_shared<MalwareScanTask>( manifestLayer, param );
        // axz_shared_scan_task buildReportTask = std::make_shared<AxzBuildReportTask>( manifestLayer, param );
        scanTask->setNext(nullptr);
        scanningPool->push(scanTask);
    });


    engineStop.wait();

    return rc;
}

namespace
{
namespace Internal
{
    ms_rc miningScanFiles(const AxzDict& in_dict, std::unordered_set<std::wstring>& results, FoundCallback foundCallback){
        ms_rc rc = MS_OK;
        std::wstring path;
        
        auto miningMachine = FinderFactory::createFinder(Type::memory, foundCallback);
        miningMachine->start();
        // std::shared_ptr<AxzDeviceScanMiner> _miner;

        // if( MS_SUCCESS(rc =  in_dict.val(MS_KEY_PATH, path) )){
        //     _miner =  std::make_shared<AxzDriveMiner>(AxzDict::object{
        //         {MS_KEY_PATH, path}
        //     });
        // } 
        // else 
        //     _miner = std::make_shared<AxzMemoryMiner>();

        // return _miner->mining(results);

        return rc;
    }
}
}