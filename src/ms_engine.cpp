#include "ms_engine.h"

#include "ms_return_codes.h"
#include "ms_defines.h"
#include "ms_config.h"
#include "ms_labels.h"
#include "ms_threadpool.h"
#include "ms_buildrp_listener.h"

#include "ms_logger.h"
#include <SQLiteCpp/SQLiteCpp.h>
#include "path_finder/FinderFactory.h"
#include "ms_server_connection.h"
#include <cpr/cpr.h>
#include <vector>
#include <memory>
#include <fstream>
#include <future>
#include <sstream>

using namespace owc::finder;
const std::experimental::filesystem::path MS_LOG_DIR =   "/var/log/opswatclient/";

namespace 
{
namespace Internal
{    
    ms_rc initLayers(const MSDict& _scanConfig, ms_shared_layer_ptr& desLayers);
    ms_rc initFinders(const MSDict& _scanConfig, std::vector<PathFinder*>& desFinders);
    ms_rc initServerStatus(const MSDict& _scanConfig, bool& scannable, ms_wstring& errMsg);

    MSDict getAdditionalData(MSDict& scanRes);
}
}

MalwareScanEngine::MalwareScanEngine(ms_int srcEvent,std::shared_ptr<std::promise<ms_bool>> srcPromise, ms_wstring srcScanOptions){
    _event = srcEvent;
    _stopBuildSignal = srcPromise;

    if(!srcScanOptions.empty()){
        MSJson::deserialize(srcScanOptions, _scanOption);
    }
    _scanResult.become(MSDictType::OBJECT);
    _scanResult.add(MS_KEY_ACTION_RESULT, 0);
    _scanResult.add(MS_KEY_EXPLANATION_RESULT, L"");
    _scanResult.add(MS_KEY_RESULT, ms_dict_object{
    });
}
MalwareScanEngine::~MalwareScanEngine()
{

}

ms_rc MalwareScanEngine::init()
{
    owc::logging::init(MS_LOG_DIR / MS_LOG_FILENAME);
    ms_rc rc = MS_OK;
    MS_LOGGER_INFO("{} Init malware scan engine!", MS_LABEL_ENGINE);

    if(_event == 0){
        MS_LOGGER_INFO("Trigger scan by schedule!");
    }
    else{
        MS_LOGGER_INFO("Trigger scan by ondemand!");
    }

    ms_wstring serverID, errMsg;
    MSDict serverStatus, additionalInfo;
    _scanConfig = MalwareScanConfig::instance()->getConfig();
    if( MS_FAILED( rc = MDServerConnection::generateReqHeader(_scanConfig, _reqHeader, additionalInfo)) ||
        MS_FAILED( rc = additionalInfo.val(MS_KEY_SERVER_ID, serverID))){
        return rc;
    }
    if(_scanOption.isNull()){
        additionalInfo.val(MS_KEY_SCAN_OPTIONS, _scanOption);
    }
    else{
        _scanConfig.add(MS_KEY_SCAN_OPTIONS, _scanOption);
    }
    _scanResult.add(MS_KEY_SERVER_ID, serverID);

    ms_bool scannable = true;
    //check server status
    if( MS_FAILED ( rc = Internal::initServerStatus(_scanConfig, scannable, errMsg)) || !scannable){
        _scanResult.add(MS_KEY_EXPLANATION_RESULT, errMsg);
        MS_LOGGER_INFO("{} Malware scan engine is initialized failed!", MS_LABEL_ENGINE);
        return MS_ERROR_INIT_FAILED;
    }
    //init layers and finders
    if( MS_FAILED ( rc = Internal::initLayers(_scanConfig, _layers) ) ||
        MS_FAILED ( rc = Internal::initFinders(_scanConfig, _finders) )){
        MS_LOGGER_ERROR("{} Init engine failed, unable to create layers/ finders", MS_LABEL_ENGINE);
        return rc;
    }    
    _isInitSuccess = true;
    MS_LOGGER_INFO("{} Malware scan engine is initialized successfully!", MS_LABEL_ENGINE);
    return rc;
}

ms_rc MalwareScanEngine::deinit()
{
    _stopBuildSignal->set_value(_isInitSuccess);
    for(auto& finder : _finders){
        finder->stop();
        delete finder;
        finder = nullptr;
    }
    owc::logging::deinit();
}

ms_rc MalwareScanEngine::start()
{
    ms_rc rc = MS_OK;
    if(!_isInitSuccess)
        return rc;
        
    MS_LOGGER_INFO("{} Start malware scan engine! ", MS_LABEL_ENGINE);

    std::promise<ms_int> tellEngineToStop;
    std::future<ms_int> engineStop = tellEngineToStop.get_future();

   
    std::shared_ptr<MalwareScanBuildRP> buildReportManager = std::make_shared<MalwareScanBuildRP>(std::move(tellEngineToStop), _scanConfig);
    ms_shared_pool scanningPool = std::make_shared<ThreadPoolInterface>(MS_THREAD_COUNT);
    ms_uint totalTask = 0;

    FoundCallback onNewFileFound = [&](FoundPathConstInfoPtr info){
        totalTask++;
        ms_wstring filePath = info->path.wstring();
        MSDict param = ms_dict_object{
            { MS_KEY_FILE_PATH, filePath },
            { MS_KEY_REQUEST_HEADER, _reqHeader}, 
            { MS_KEY_CONFIG,    _scanConfig},
        };
        ms_shared_layer_ptr scanTask = std::make_shared<MSScanTask>( _layers, param );
        scanTask->registerCallback([filePath, buildReportManager](const MSDict& scanResult){
            return buildReportManager->onNewFileScanned(scanResult, filePath);
        });
        scanTask->setNext(nullptr);
        scanningPool->push(scanTask);
    };
    FinishedCallback onPathFinderFinish = [&](){
    };

    MS_LOGGER_INFO("{} Finders start mining files", MS_LABEL_ENGINE);
    for(auto i : _finders){
        i->registerFoundCallback(onNewFileFound);
        i->registerFinishedCallback(onPathFinderFinish);
        i->start();
    }
    buildReportManager->setTotalTask(totalTask);

    engineStop.wait();
    MSDict resultData = buildReportManager->getScanResult();
    resultData.add(MS_KEY_EVENT, _event);
    resultData.add(MS_KEY_SCAN_OPTIONS, _scanOption);

    _actionResult = buildReportManager->getActionResult();
    _scanResult.add(MS_KEY_RESULT, std::move(resultData) );
    _scanResult.add(MS_KEY_ACTION_RESULT, int(_actionResult) );
    scanningPool->stop();
    _additionalData = Internal::getAdditionalData(_scanResult);
    MS_LOGGER_INFO("{} Malware scan engine runs successfully!", MS_LABEL_ENGINE);
    return rc;
}

ms_wstring MalwareScanEngine::getScanResult()
{
    ms_wstring scanResultStr;
    if ( MS_FAILED ( MSJson::serialize(_scanResult, scanResultStr) )){
        return L"";
    }
    return scanResultStr;
}

ms_int MalwareScanEngine::getActionResult()
{
    ms_int action;
    if( !_additionalData.isNull() && MS_SUCCESS(_additionalData.val(MS_KEY_ACTION_RESULT, action ))){
        return action;
    }
    return 0;
}

ms_wstring MalwareScanEngine::getExplanationResult()
{
    ms_wstring explanation;
    if( !_additionalData.isNull() && MS_SUCCESS(_additionalData.val(MS_KEY_EXPLANATION_RESULT, explanation ))){
        return explanation;
    }
    return L"";
}

ms_wstring MalwareScanEngine::getServerID()
{
    ms_wstring serverID;
    if( !_additionalData.isNull() && MS_SUCCESS(_additionalData.val(MS_KEY_SERVER_ID, serverID ))){
        return serverID;
    }
    return L"";
}

namespace
{
namespace Internal
{
    ms_rc initLayers(const MSDict &_scanConfig, ms_shared_layer_ptr &desLayers)
    {
        ms_rc rc = MS_OK;
        std::shared_ptr<Slot> readingSlot       = std::make_shared<Slot>(1E8, MS_THREAD_COUNT);
        std::shared_ptr<Slot> uploadingSlot     = std::make_shared<Slot>(1E8, MS_MAX_ALLOWED_UPLOAD_THREAD);

        ms_shared_layer_ptr verifyFile          = std::make_shared<VerifyFile>();
        ms_shared_layer_ptr manifestLayer       = std::make_shared<ManifestLayer>();
        ms_shared_layer_ptr cdrLayer            = std::make_shared<CDRLayer>();
        ms_shared_layer_ptr calHash             = std::make_shared<CaculateHashLayer>(readingSlot);
        ms_shared_layer_ptr localhash           = std::make_shared<LocalHashLayer>();
        ms_shared_layer_ptr serverHash          = std::make_shared<ServerHashLayer>();
        ms_shared_layer_ptr upload              = std::make_shared<UploadFileLayer>(readingSlot, uploadingSlot);
        ms_shared_layer_ptr queryResult         = std::make_shared<QueryResultLayer>(); 
        ms_shared_layer_ptr externalLayer       = std::make_shared<ExternalLayer>(); 

        ms_int disableHashCheck = CheckHashAndUpload;
        MSDict scanningPolicy;
        if( MS_FAILED ( rc = _scanConfig.val(MS_KEY_SCANNING_POLICY, scanningPolicy) )          ||
            MS_FAILED ( rc = scanningPolicy.val(MS_KEY_DISABLE_HASH_CHECK, disableHashCheck))){
                MS_LOGGER_ERROR("{} Init layers failed, config is not valid", MS_LABEL_ENGINE);
                return rc;
        }
        switch (disableHashCheck)
        {
        case HashCheckType::CheckHashAndUpload :
            MS_LOGGER_INFO("{} Got check hash and upload config", MS_LABEL_ENGINE);
            verifyFile->setNext(manifestLayer)->setNext(cdrLayer)->setNext(calHash)->setNext(localhash)->setNext(serverHash)->setNext(upload)->setNext(queryResult)->setNext(externalLayer)->setNext(nullptr);
            break;
        case HashCheckType::UploadOnly :
            MS_LOGGER_INFO("{} Got upload only config", MS_LABEL_ENGINE);
            verifyFile->setNext(manifestLayer)->setNext(cdrLayer)->setNext(calHash)->setNext(upload)->setNext(queryResult)->setNext(externalLayer)->setNext(nullptr);
            break;
        case HashCheckType::CheckHashOnly :
            MS_LOGGER_INFO("{} Got check hash only config", MS_LABEL_ENGINE);
            verifyFile->setNext(manifestLayer)->setNext(cdrLayer)->setNext(calHash)->setNext(localhash)->setNext(serverHash)->setNext(externalLayer)->setNext(nullptr);
            break;
        default:
            break;
        }
        desLayers = verifyFile;
        return rc;
    }
    ms_rc initFinders(const MSDict &_scanConfig, std::vector<PathFinder*>& desFinders){

        ms_rc rc = MS_OK;
        MSDict scanOpts, types;
        ms_wstring path;
        ms_int fullScan;

        if ( MS_FAILED ( rc = _scanConfig.val(MS_KEY_SCAN_OPTIONS, scanOpts) )  ||
             MS_FAILED ( rc =  scanOpts.val(MS_KEY_TYPE, types))                ||
             MS_FAILED ( rc =  scanOpts.val(MS_KEY_PATH, path ))                ||
             MS_FAILED ( rc =  scanOpts.val(MS_KEY_FULLSCAN, fullScan ))        ||
             !types.isArray()){
                MS_LOGGER_ERROR("{} Init finders failed, config is not valid", MS_LABEL_ENGINE);
            return rc;
        }
        Paths paths;
        if(fullScan){
            desFinders.push_back(FinderFactory::createFinder(Type::memory));
            paths.push_back("/");
        }
        else{
            
            for(ms_int i = 0 ; i < types.size(); i++){        
                switch (types[i].intVal())
                {
                case 0:
                    desFinders.push_back(FinderFactory::createFinder(Type::memory));
                    break;
                case 2:
                    {
                        std::vector<std::string> portableDir;
                        FileUtils::getRemovableMediaDir(portableDir);
                        for( auto i : portableDir)
                            paths.push_back(i);
                    }
                    break;
                case 4:
                    paths.push_back(path);
                    break;
                default:
                    std::cout << "Not support yet!\n";
                }
        }
        }
        
        if( !paths.empty() ){
            auto finder = FinderFactory::createFinder(Type::regular);
            finder::Options finderOpts;
            finderOpts.async = true;
            finderOpts.file_only = true;
            finder->setOptions(finderOpts);
            finder->setPathToFind(paths);
            desFinders.push_back(finder);
        }
        return rc;
    }
    ms_rc initServerStatus(const MSDict &_scanConfig, bool &scannable, ms_wstring &errMsg)
    {
        ms_rc rc = MS_OK;
        MSDict server, resultDict;
        if( MS_FAILED ( rc = MDServerConnection::getServerStatus(_scanConfig, server) ) ){
            return rc;
        }
        if( MS_SUCCESS ( server.val(MS_KEY_RESULT, resultDict) ) &&
            MS_SUCCESS ( resultDict.val(MS_KEY_ERROR_MSG, errMsg) )){
            MS_LOGGER_INFO("{} init server meets error: {}", MS_LABEL_ENGINE, StringUtils::toString(errMsg));
        }
        ms_int errCode;
        resultDict.val(MS_KEY_CODE, errCode);
        switch (errCode) {
            case MDServerStatus::Disconnected:
            case MDServerStatus::EmptyAddress: 
                scannable = false;
            break;
            case MDServerStatus::InvalidApiKey:
            case MDServerStatus::LimitReached:
                scannable = false;
            break;
            case MDServerStatus::Scannable:
                scannable = true;
            break;
        }

    }
    MSDict getAdditionalData(MSDict& scanRes)
    {
        MSDict additionalData(MSDictType::OBJECT);
        ms_int actionResult;
        ms_wstring explainationResult, serverID;

        if( MS_FAILED(scanRes.steal(MS_KEY_ACTION_RESULT, actionResult)) ||
            MS_FAILED(scanRes.remove(MS_KEY_ACTION_RESULT))){
            actionResult = 0;
        }
        if( MS_FAILED(scanRes.steal(MS_KEY_EXPLANATION_RESULT, explainationResult))||
            MS_FAILED(scanRes.remove(MS_KEY_EXPLANATION_RESULT))){
            explainationResult = L"";
        }    
        if( MS_FAILED(scanRes.steal(MS_KEY_SERVER_ID, serverID))||
            MS_FAILED(scanRes.remove(MS_KEY_SERVER_ID))){
            serverID = L"";
        }
        
        additionalData.add(MS_KEY_ACTION_RESULT, actionResult);
        additionalData.add(MS_KEY_EXPLANATION_RESULT, explainationResult);
        additionalData.add(MS_KEY_SERVER_ID, serverID);

        return additionalData;
    }
}
}