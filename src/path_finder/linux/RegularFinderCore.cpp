#include "RegularFinderCore.h"
#include "axz_scu_string.h"
#include "axz_keys.h"
#include "axz_dict.h"
//#include <owccore/Logging.h>

#include <atomic>
#include <iostream>
#include <queue>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <fstream>
namespace fs = std::experimental::filesystem;
namespace
{
namespace Internal
{
    bool isDirectory(const axz_string& path) {
      struct stat path_stat;
      if (stat(path.c_str(), &path_stat) == 0) {
          return S_ISDIR(path_stat.st_mode);
      }
      return false;
    }
}
}

namespace owc {
namespace finder {

static void linuxExplore(
    const Path& path, const finder::Options& options,
    FoundCallback fileFoundCallback,
    std::shared_ptr<Queue<Path>> waittingToFindPathsQ,
    size_t threadCount = 1, std::function<void()> conditionCheck = nullptr,
    finder::FinishedCallback finishedCallback = nullptr){
      std::vector<std::thread> threads;
      std::atomic<int> threadExecuting = 0;
      std::error_code ec;

      auto isExcluded = [&options](const fs::path& path) {
        if (std::find(options.excludedPath.begin(), options.excludedPath.end(),
                      path) != options.excludedPath.end()) {
          return true;
        }
        return false;
      };
      if (isExcluded(path) || !fs::exists(path, ec)) {
        return;
      }
      waittingToFindPathsQ->push(path);

      auto process = [&options, &threadExecuting, &waittingToFindPathsQ,
                      conditionCheck, fileFoundCallback, isExcluded, &path]() {
        Path findPath;
        try {
          while (waittingToFindPathsQ->wait(findPath)) {
            if (conditionCheck) {
              conditionCheck();
            }
            ++threadExecuting;
            std::error_code ec;
            
            if(Internal::isDirectory(findPath)){
              std::vector<std::shared_ptr<FoundPathInfo>> childPaths;
              DIR* dir = opendir(findPath.c_str());
    
              if (dir) {
                  struct dirent* entry;
                  while ((entry = readdir(dir)) != nullptr) {
                      std::string entry_name = entry->d_name;
                      if (entry_name != "." && entry_name != "..") {
                          std::string full_path = findPath.string() + "/" + entry_name;
                          auto isDir = Internal::isDirectory(full_path);
                          childPaths.push_back(
                              std::make_shared<FoundPathInfo>(full_path, isDir));
                      }
                  }
                  closedir(dir);
                  if (!options.file_only) {
                    auto folderPath = std::make_shared<FoundPathInfo>(findPath, true);
                    folderPath->childCount = childPaths.size();
                    fileFoundCallback(folderPath);
                  }
                  for (auto& p : childPaths) {
                    if (p->isDirectory) {
                      if (options.recursive) {
                        waittingToFindPathsQ->push(p->path);
                      }
                    } else {
                      fileFoundCallback(p);
                    }
                  }
              }
            }
            else{
              fileFoundCallback(std::make_shared<FoundPathInfo>(findPath));
            }
            
            if (--threadExecuting == 0 && waittingToFindPathsQ->empty()) {
              waittingToFindPathsQ->close();
              break;
            }
          }
        } catch (const std::exception& /*ec*/) {
          //      FINDER_LOGGER_ERROR("Finder caught exception: ", ec.what());
        } catch (...) {
        }
      };


      if (threadCount == 1) {
        process();
      } else {
        for (size_t threadIdx = 0; threadIdx < threadCount; ++threadIdx) {
          threads.push_back(std::thread{[process]() {
            //FINDER_LOGGER_DEBUG("Starting thread: ", std::this_thread::get_id());
            process();
            //FINDER_LOGGER_DEBUG("Exit thread: ", std::this_thread::get_id());
          }});
        }
      }

      for (auto& thread : threads) {
        if (thread.joinable()) {
          thread.join();
        }
      }

      if(finishedCallback){
        finishedCallback();
      }
    }
RegularFinderCore::RegularFinderCore() { type_ = finder::Type::regular; }

RegularFinderCore::RegularFinderCore(std::shared_ptr<std::recursive_mutex> mtx)
    : PathFinder{mtx} {
  type_ = finder::Type::regular;
}

RegularFinderCore::~RegularFinderCore() {}

LargeSize RegularFinderCore::getTotalFileCount() {
  std::atomic<LargeSize> totalFiles = 0;
  auto threadCount = std::thread::hardware_concurrency() / 2;
  auto opt = options_;
  opt.file_only = true;
  // auto waittingToFindPathsQ = std::make_shared<Queue<finder::Path>>();
  // queues_.emplace(waittingToFindPathsQ);
  for (auto& path : multiPath_) {
    linuxExplore(
        path, opt,
        [&totalFiles](finder::FoundPathConstInfoPtr) { ++totalFiles; }, nullptr);
  }

  std::lock_guard lock(mtx_);
  // queues_.erase(waittingToFindPathsQ);
  return totalFiles;
}

LargeSize RegularFinderCore::getTotalFileCount(const Path& path,
                                               const Options& options,
                                               uint32_t threadCount) {
  std::atomic<size_t> totalFiles = 0;
  // auto waittingToFindPathsQ = std::make_shared<Queue<finder::Path>>();
  // queues_.emplace(waittingToFindPathsQ);
  linuxExplore(
      path, options,
      [&totalFiles](finder::FoundPathConstInfoPtr) { totalFiles++; }, nullptr);
  std::lock_guard lock(mtx_);
  // queues_.erase(waittingToFindPathsQ);
  return totalFiles;
}

void RegularFinderCore::getTotalFileCount(FileCountCallback callback) {
  if (!callback) {
    return;
  }
  asyncThreads_.push_back(std::thread{[callback, this]() {
    //FINDER_LOGGER_DEBUG("Starting thread: ", std::this_thread::get_id());
    if (callback) {
      callback(getTotalFileCount());
    }
    //FINDER_LOGGER_DEBUG("Exit thread: ", std::this_thread::get_id());
  }});
}

bool RegularFinderCore::accesible(const Path& path, int& error) {
  std::error_code ec;
  if (fs::exists(path, ec)) {
    return true;
  }
  error = ec.value();
  return false;
}

void RegularFinderCore::stop() {
  {
    std::lock_guard lock(mtx_);
    for (auto& queue : queues_) {
      queue->close();
    }
  }
  PathFinder::stop();
}

void RegularFinderCore::explorePath(const Path& path) {
  auto waittingToFindPathsQ = std::make_shared<Queue<Path>>();
  queues_.emplace(waittingToFindPathsQ);
  linuxExplore(
      path, options_,
      std::bind(&RegularFinderCore::onFileFound, this, std::placeholders::_1),waittingToFindPathsQ, 1, finishedCallback_);
  std::lock_guard lock(mtx_);
  queues_.erase(waittingToFindPathsQ);
}
}  // namespace finder
}  // namespace owc
