#include "PathFinder.h"

#include <iostream>

namespace owc {
namespace oesis {
void AllowThisThread(bool b);
}
namespace finder {
PathFinder::PathFinder() {
  mtx_ = std::make_unique<std::recursive_mutex>();
  state_ = std::make_unique<ObservableState>(*mtx_, State::not_initialized);
  state_->connect([this](auto state) { conditionVarible_.notify_all(); });
}
PathFinder::PathFinder(std::shared_ptr<std::recursive_mutex> mtx) : mtx_{mtx} {
  if (!mtx_) {
    mtx_ = std::make_unique<std::recursive_mutex>();
  }
  state_ = std::make_unique<ObservableState>(*mtx_, State::not_initialized);
  state_->connect([this](auto state) { conditionVarible_.notify_all(); });
}

PathFinder::~PathFinder() {
  state_->disconnect();
  for (auto& thread : asyncThreads_) {
    if (thread.joinable()) {
      thread.join();
    }
  }
}

bool PathFinder::start(std::function<void(finder::State)> cb) {
  try {
    checkState();
    // std::lock_guard lock(changeStateMutex_);
    state_->set(State::running);
  } catch (...) {
    return false;
  }

  if (!foundCallback_) {
    setState(finder::State::error);
    return false;
  }

  auto findingThread = std::thread{[this, cb] {
    if (type_ == finder::Type::memory) {
      explorePath("Memory");
    } else {
      for (auto& path : multiPath_) {
        explorePath(path);
      }
    }
    if (state_->get() <= State::running) {
      // std::lock_guard lock(changeStateMutex_);
      state_->set(State::finished);
    }
    if (cb) {
      cb(state_->get());
    }
    // if (state_->get() != State::stopped) {
    //  // call suitably callback by state
    //  callSuitablyCallback();
    //}
  }};

  if (!cb && findingThread.joinable()) {
    findingThread.join();
  } else {
    asyncThreads_.push_back(std::move(findingThread));
  }
  return true;
}

void PathFinder::stop() {
  // std::lock_guard lock(changeStateMutex_);
  state_->set(State::stopped);
  for (auto& thread : asyncThreads_) {
    if (thread.joinable()) {
      thread.join();
    }
  }
}

void PathFinder::pause() {
  if (state_->get() <= State::running) {
    // std::lock_guard lock(changeStateMutex_);
    state_->set(State::paused);
  }
}

void PathFinder::resume() {
  if (state_->get() == State::paused) {
    // std::lock_guard lock(changeStateMutex_);
    state_->set(State::running);
  }
}

void PathFinder::setOptions(const Options& options) { options_ = options; }

void PathFinder::checkState() {
  switch (state_->get()) {
    case State::paused: {
      static std::mutex mutex;
      std::unique_lock<std::mutex> lock(mutex);
      conditionVarible_.wait(lock);
      if (state_->get() != State::stopped) {
        break;
      }
    }
    case State::stopped:
    case State::finished: {
      throw nullptr;
      break;
    }
    default:
      break;
  }
}

PathFinder::ObservableState& PathFinder::state() { return *state_; }

Type PathFinder::type() const { return type_; }

void PathFinder::setPathToFind(const Paths& multiPath) {
  multiPath_ = multiPath;
}

void PathFinder::setPathToFind(const Path& path) {
  multiPath_.emplace_back(path);
}

void PathFinder::registerFoundCallback(FoundCallback foundCallback) {
  foundCallback_ = foundCallback;
}

void PathFinder::registerFinishedCallback(
    std::function<void()> finishedCallback) {
  finishedCallback_ = finishedCallback;
}

void PathFinder::reigsterAbortedCallback(
    std::function<void()> abortedCallback) {
  abortedCallback_ = abortedCallback;
}

void PathFinder::setState(State state) { state_->set(state); }

void PathFinder::onFileFound(FoundPathConstInfoPtr path) {
  checkState();
  if (foundCallback_) {
    foundCallback_(path);
  }
}

void PathFinder::callSuitablyCallback() {
  switch (state_->get()) {
    case State::stopped: {
      if (abortedCallback_) {
        abortedCallback_();
      }
      break;
    }
    case State::error:
      break;
    default: {
      if (finishedCallback_) {
        finishedCallback_();
      }
      break;
    }
  }
}
}  // namespace finder
}  // namespace owc
