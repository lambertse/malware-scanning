#include "ms_threadpool.h"
#include "ms_labels.h"
#include "ms_logger.h"
#include <iostream>
#include <sstream>
#include <thread>

ThreadPoolInterface::ThreadPoolInterface(unsigned threadCount)
    : _taskDone(0), done(false)
{
    unsigned threadSupported = std::thread::hardware_concurrency();

    if( threadSupported < threadCount){
        MS_LOGGER_INFO("{} the number of current supported thread in this device is less than {} , just use {} threads to work.", MS_LABEL_THREADPOOL, threadCount, threadSupported);
        threadCount = threadSupported;
    }

    try
    {
        for (ms_uint i = 0; i < threadCount; i++)
        {
            threads.push_back(std::thread(&ThreadPoolInterface::work, this));
            threatMap[threads.back().get_id()] = 0;
        }
    }
    catch(...)
    {
        throw;
    }
}

ThreadPoolInterface::~ThreadPoolInterface()
{
    for (auto& thread : threads)
    {
        try{
            if (thread.joinable()) {
                thread.join();
            }  
        }
        catch(const std::exception& e){
            std::cerr << "Exception caught: " << e.what() << std::endl;
        }
    }
}

void ThreadPoolInterface::stop(){
    done = true;
    MS_LOGGER_INFO("{} The number of tasks processed of each thread: ", MS_LABEL_THREADPOOL);
    for(auto i : _threadTaskCount){
        MS_LOGGER_INFO("{} 1 thread processed: {} tasks", MS_LABEL_THREADPOOL, i.second);
    }
    for (auto& thread : threads)
    {
        if (thread.joinable()) {
            thread.join();
        }  
    }
}

void ThreadPoolInterface::push(ms_shared_layer_ptr param)
{
    _workQueue.push(param);
}

void ThreadPoolInterface::work()
{
    while (!done)
    {
        ms_shared_layer_ptr task;
        if (this->_workQueue.tryPop(task))
        {
            _threadTaskCount[std::this_thread::get_id()]++;
            MSDict outDict; 
            task->start(ms_dict_object{}, outDict);
            {
                std::lock_guard<std::mutex> lockTask(_mtx);
                _taskDone++;
                // std::cout << "Done " << _taskDone << std::endl;
                threatMap[std::this_thread::get_id()]++;
            }
        }
        else
        {
            std::this_thread::yield();
        }
    }
}

ms_bool ThreadPoolInterface::empty() 
{
    return this->_workQueue.empty();
}