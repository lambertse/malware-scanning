#include "utils/file_utils.h"
#include "utils/string_utils.h"
#include "file_utils_calhash.h"
#include <sys/stat.h>
#include <fstream>
#include <string>
#include <sstream>   
namespace
{
namespace Internal
{
    ms_rc mapCode( int in_err_no );
};
}

ms_rc FileUtils::fileSize( const std::wstring& in_file_path, size_t& out_size )
{               
    struct stat st;
    if ( stat( StringUtils::toString( in_file_path ).c_str(), &st ) < 0 )
    {
        out_size = 0;
        return Internal::mapCode( errno );
    }

    out_size = st.st_size;
    return MS_OK;    
}

std::ifstream FileUtils::getContent(const std::wstring &in_file_path, ms_rc &rc)
{
    std::ifstream is( StringUtils::toString( in_file_path ).c_str(), std::ifstream::binary );
    rc = MS_OK;
    return is;
}

ms_rc FileUtils::calculateHash(std::ifstream& in_content, std::wstring &sha256)
{
    MSUtilsShamd hasher( MSUtilsHashType::MS_SHA_256 );
    return hasher.hexCodeOfFile(in_content, sha256);
}


ms_rc FileUtils::getRemovableMediaDir(std::vector<std::string> &out_dir)
{
    const std::string mediaDirectory = "/media";
    std::ifstream mounts("/proc/mounts");
    std::string line;
    const std::string mediaPrefix = "/media/";

    while (std::getline(mounts, line)) {
        std::istringstream iss(line);
        std::string device, mountPoint;
        iss >> device >> mountPoint;

        if (mountPoint.compare(0, mediaPrefix.length(), mediaPrefix) == 0) {
            // Found a mount point within /media, which is likely removable media
            out_dir.push_back(mountPoint);
        }
    }

    return MS_OK; // No removable media found
}
namespace
{
namespace Internal
{
    ms_rc mapCode( int in_err_no )
    {        
        switch ( in_err_no )
        {
            case 0:         return MS_OK;
            case EROFS:    
            case EACCES:    return MS_ERROR_ACCESS_DENIED;
            case ENOENT:
            case ENOTDIR:   return MS_ERROR_NOT_FOUND;            
        }
        return MS_ERROR_NATIVE_API;     
    }
}
}

