#include "utils/string_utils.h"
#include <codecvt>
#include <cwctype>
#include <iostream>
#include <sstream>

namespace StringUtils
{
    static std::wstring_convert< std::codecvt_utf8<wchar_t> > _convertor;

    std::string toString( const std::wstring& _wstr )
    {
        return _convertor.to_bytes( _wstr );
    }

    std::wstring toWideString( const std::string& _str )
    {
        return _convertor.from_bytes( _str );
    }

    #ifdef __APPLE__
    #ifdef __BIG_ENDIAN__
        static const CFStringEncoding kWideStringEncoding = kCFStringEncodingUTF32BE;
    #else
        static const CFStringEncoding kWideStringEncoding = kCFStringEncodingUTF32LE;
    #endif
    std::wstring toWideString( CFStringRef _cfs )
    {
        if ( !_cfs ) {
            return L"";
        }
        
        CFIndex len = CFStringGetLength( _cfs ) + 1;
        CFIndex size = CFStringGetMaximumSizeForEncoding( len, kWideStringEncoding );
        
        std::wstring s( size / sizeof( wchar_t ) - 1, 0 );
        CFStringGetCString( _cfs, ( char* )s.data(), size, kWideStringEncoding );
        return s;
    }

    std::string toString( CFStringRef _cfs )
    {        
        if ( !_cfs ) {
            return "";
        }
        
        CFIndex len = CFStringGetLength( _cfs ) + 1;
        std::string s( len - 1, 0 );
        CFStringGetCString( _cfs, ( char* )s.data(), len, kCFStringEncodingUTF8 );
        return s;
    }
    #endif

    void ensureDirEnding( std::wstring& _path )
    {
        #ifdef _WIN32
        if  ( ( _path[_path.length() - 1] != L'/' ) || ( _path[_path.length() - 1] != L'\\' ) ) {
            _path += L'\\';
        }
        #else
        if ( _path[_path.length() - 1] != L'/' ) {
            _path += L'/';
        }
        #endif 
    }

    void ensureDirEnding( std::string& _path )
    {
        #ifdef _WIN32
        if  ( ( _path[_path.length() - 1] != '/' ) || ( _path[_path.length() - 1] != '\\' ) ) {
            _path += '\\';
        }
        #else
        if ( _path[_path.length() - 1] != '/' ) {
            _path += '/';
        }
        #endif        
    }

    void trimLeft( std::wstring& s ) {
        s.erase(s.begin(), std::find_if(s.begin(), s.end(), []( wchar_t ch) {
            return !std::iswspace(ch);
        }));
    }
    
    void trimRight( std::wstring& s ) {
        s.erase( std::find_if(s.rbegin(), s.rend(), []( wchar_t ch) {
            return !std::iswspace(ch);
        }).base(), s.end());
    }
    
    void trim( std::wstring& s ) {
        trimLeft(s);
        trimRight(s);
    }    

    void removeDashChars( std::wstring& s ) {
        s.erase(std::remove(s.begin(), s.end(), L'-'), s.end());
    }    

    void tokenize( const std::wstring& in_str, const wchar_t in_delimiter, std::vector<std::wstring>& out_tokens )
	{
		out_tokens.clear();
		std::wstringstream stream( in_str );		
		std::wstring token;
		while ( std::getline( stream, token, in_delimiter ) )
		{
			out_tokens.emplace_back( token );
		}
	}

	void replaceChars( std::wstring& out_target, const std::wstring& in_chars_to_replace, wchar_t in_replacement)
	{
		if (!out_target.empty() && !in_chars_to_replace.empty())
		{
			for (wchar_t* p = &out_target.front(); ( p = std::wcspbrk(p, in_chars_to_replace.c_str()) ) ; ++p)
			{
				*p = in_replacement;
			}
		}
	}
}
std::vector<std::string> StringUtils::explode(const std::string& str, const char ch){
    std::string next;
    std::vector<std::string> result;
    for (std::string::const_iterator it = str.begin(); it != str.end(); it++)
	{
        if (*it == ch)
		{
            if (!next.empty())
			{
				result.push_back(next);
                next.clear();
            }
        } 
		else 
		{
            next += *it;
        }
    }
    if (!next.empty())
         result.push_back(next);
    return result;
}

int StringUtils::strToI32(std::string &str)
{
    return atoi(str.c_str());
}

time_t StringUtils::utcTimeStrToTimet(const std::string &utcTimeStr)
{
    tm tmTime;
	std::vector<std::string> timeStampVec = StringUtils::explode(utcTimeStr, 'T');
	if (timeStampVec.size() >= 2)
	{
		std::string dateStr = timeStampVec[0];
		std::vector<std::string> dateVec = StringUtils::explode(utcTimeStr, '-');
		if (dateVec.size() >= 3)
		{
			tmTime.tm_year = StringUtils::strToI32(dateVec[0]) - 1900;
			tmTime.tm_mon = StringUtils::strToI32(dateVec[1]) - 1;
			tmTime.tm_mday = StringUtils::strToI32(dateVec[2]);
		}

		std::string timeStr1 = timeStampVec[1];
		std::vector<std::string> timeVec1 = StringUtils::explode(timeStr1, 'Z');
		if (timeVec1.size() >= 1)
		{
			std::string timeStr2 = timeVec1[0];
			std::vector<std::string> timeVec2 = StringUtils::explode(timeStr2, ':');
			if (timeVec2.size() >= 3)
			{
				tmTime.tm_hour = StringUtils::strToI32(timeVec2[0]);
				tmTime.tm_min = StringUtils::strToI32(timeVec2[1]);
				tmTime.tm_sec = StringUtils::strToI32(timeVec2[2]);
			}
		}
	}

	return mktime(&tmTime);
}
