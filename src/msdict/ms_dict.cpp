#include "ms_dict.h"
#include "ms_dict_stepper.h"
#include "ms_return_codes.h"
#include <cassert>
#include <cstring>
#include <stdexcept>

template<bool isDict>
struct _MSBool2Type
{
	enum{ val = isDict };
};

class _MSDictVal;
struct _MSDicDefault 
{	
	static const std::shared_ptr<_MSDicVal> nullVal;
	static const std::shared_ptr<_MSDicVal> trueVal;
	static const std::shared_ptr<_MSDicVal> falseVal;
};

namespace
{
namespace Internal
{
	template<class T>
	ms_rc getVal( MSDict& in_object, T& out_val, _MSBool2Type<false> )
	{
		return in_object.val( out_val );
	}
	
	ms_rc getVal( MSDict& in_object, MSDict& out_val, _MSBool2Type<true> )
	{
		out_val = in_object;
		return MS_OK;
	}	

	template<class T>
	ms_rc stealVal( MSDict& in_object, T& out_val, _MSBool2Type<false> )
	{
		ms_rc rc = in_object.steal( out_val );
		if ( MS_SUCCESS( rc ) )	in_object.drop();
		return rc;
	}

	ms_rc stealVal( MSDict& in_object, MSDict& out_val, _MSBool2Type<true> )
	{
		out_val = std::move( in_object );
		in_object.drop();
		return MS_OK;
	}
}
};

class _MSDicVal
{
public:
	virtual MSDictType type() const = 0;   
	virtual bool isType( const MSDictType type ) const = 0;
	virtual size_t size() const 					{ throw std::invalid_argument( "MSDict::size available for object or array only" ); }

	virtual ms_rc val( double& val ) const                     	    	{ return MS_ERROR_NOT_SUPPORT; }
	virtual ms_rc val( int32_t& val ) const		                        { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( bool& val ) const		                            { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( ms_wstring& val ) const	                        { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( ms_bytes& val ) const	                            { return MS_ERROR_NOT_SUPPORT; };

	virtual ms_rc steal( double& val )    		                 	    	{ return this->val( val ); }
	virtual ms_rc steal( int32_t& val )			                        { return this->val( val ); };
	virtual ms_rc steal( bool& val ) 			                            { return this->val( val ); };
	virtual ms_rc steal( ms_wstring& val ) 		                        { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc steal( ms_bytes& val ) 		                        	{ return MS_ERROR_NOT_SUPPORT; };

	virtual ms_rc val( const ms_wstring& key, MSDict& val )	            { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( const ms_wstring& key, double& val )	    		{ return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( const ms_wstring& key, int32_t& val )		   	    { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( const ms_wstring& key, bool& val )		    	    { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( const ms_wstring& key, ms_wstring& val )	    	{ return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( const ms_wstring& key, ms_bytes& val )		    { return MS_ERROR_NOT_SUPPORT; };	

	virtual ms_rc steal( const ms_wstring& key, MSDict& val )			{ return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc steal( const ms_wstring& key, double& val )	    		{ return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc steal( const ms_wstring& key, int32_t& val )		   	{ return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc steal( const ms_wstring& key, bool& val )		    	{ return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc steal( const ms_wstring& key, ms_wstring& val )		{ return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc steal( const ms_wstring& key, ms_bytes& val )			{ return MS_ERROR_NOT_SUPPORT; };	

	virtual ms_rc val( const size_t idx, MSDict& val )            	    { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( const size_t idx, double& val )			            { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( const size_t idx, int32_t& val )				    { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( const size_t idx, bool& val )			            { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( const size_t idx, ms_wstring& val )		        { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc val( const size_t idx, ms_bytes& val )		            { return MS_ERROR_NOT_SUPPORT; };

	virtual ms_rc steal( const size_t idx, MSDict& val )					{ return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc steal( const size_t idx, double& val )			        { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc steal( const size_t idx, int32_t& val )				    { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc steal( const size_t idx, bool& val )			            { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc steal( const size_t idx, ms_wstring& val )				{ return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc steal( const size_t idx, ms_bytes& val )				{ return MS_ERROR_NOT_SUPPORT; };

	virtual ms_rc call( MSDict&& in_val, MSDict& out_val )				{ return MS_ERROR_NOT_SUPPORT; };

	virtual double numberVal() const            							{ throw std::invalid_argument( "MSDict::numberVal available for number only" ); }
	virtual int32_t intVal() const                  						{ throw std::invalid_argument( "MSDict::intVal available for number only" ); }
	virtual bool boolVal() const                							{ throw std::invalid_argument( "MSDict::boolVal available for boolean only" ); }
	virtual ms_wstring stringVal() const									{ throw std::invalid_argument( "MSDict::stringVal available for string only" ); }
	virtual ms_bytes bytesVal() const										{ throw std::invalid_argument( "MSDict::bytesVal available for bytes only" ); }

	virtual ms_rc add( const MSDict& val )	                            { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc add( MSDict&& val )			                            { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc add( const ms_wstring& key, const MSDict& val )        { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc add( const ms_wstring& key, MSDict&& val )		        { return MS_ERROR_NOT_SUPPORT; };

	virtual void clear() {};
	virtual ms_rc remove( const size_t idx )		                        { return MS_ERROR_NOT_SUPPORT; };
	virtual ms_rc remove( const ms_wstring& key )	                        { return MS_ERROR_NOT_SUPPORT; };
	
	virtual MSDict& at( const size_t idx )									{ throw std::invalid_argument( "MSDict::at@size_t available for array only" ); }
    virtual const MSDict& at( const size_t idx ) const                     { throw std::invalid_argument( "MSDict::at@size_t available for array only" ); }
	virtual MSDict& at( const ms_wstring& key )							{ throw std::invalid_argument( "MSDict::at@ms_wstring available for object only" ); }

	virtual ms_rc step( ms_shared_dict_stepper stepper ) = 0;	
};

template<MSDictType _type, class T>
class _MSTVal: public _MSDicVal
{
public:	
	explicit _MSTVal( const T& val ): m_val( val ) {}
	explicit _MSTVal( T&& val ): m_val( std::move( val ) ) {}	
	~_MSTVal() {}

	T& data() { return this->m_val; }
	MSDictType type() const override								        { return _type; }
	virtual bool isType( const MSDictType type ) const override	        { return ( _type == type ); }
	virtual ms_rc step( ms_shared_dict_stepper stepper ) override {
		return stepper->step( this->data() );
	}

protected:
	T m_val;
};

class _MSNull final: public _MSTVal< MSDictType::NUL, std::nullptr_t >
{
public:
	_MSNull(): _MSTVal( nullptr ) {}	
};

class _MSBool final: public _MSTVal< MSDictType::BOOL, bool >
{
public:
	explicit _MSBool( bool val = true ): _MSTVal( val ) {}		
	virtual ms_rc val( bool& val ) const override	                        { val = this->m_val; return MS_OK; }
	virtual bool boolVal() const override			                        { return this->m_val; }
};

const std::shared_ptr<_MSDicVal> _MSDicDefault::nullVal = std::make_shared<_MSNull>();
const std::shared_ptr<_MSDicVal> _MSDicDefault::trueVal = std::make_shared<_MSBool>( true );
const std::shared_ptr<_MSDicVal> _MSDicDefault::falseVal = std::make_shared<_MSBool>( false );

class _MSDouble final: public _MSTVal< MSDictType::NUMBER, double >
{
public:
	explicit _MSDouble( double val = 0. ): _MSTVal( val ) {}

	virtual ms_rc val( double& val ) const override
	{		
		val = this->m_val;		
		return MS_OK;
	}

	virtual ms_rc val( int32_t& val ) const override
	{		
		val = ( int32_t )this->m_val;
		return MS_OK;
	}	

	virtual double numberVal() const override	{ return this->m_val; }
	virtual int32_t intVal() const override		{ return ( int32_t )this->m_val; }
};

class _MSInt final: public _MSTVal< MSDictType::INTEGRAL, int32_t >
{
public:
	explicit _MSInt( int32_t val = 0 ): _MSTVal( val ) {}

	virtual ms_rc val( double& val ) const override
	{		
		val = ( double )this->m_val;
		return MS_OK;
	}

	virtual ms_rc val( int32_t& val ) const override
	{		
		val = this->m_val;
		return MS_OK;
	}

	virtual double numberVal() const override	{ return ( double )this->m_val; }
	virtual int32_t intVal() const override		{ return this->m_val; }
};

class _MSString final: public _MSTVal< MSDictType::STRING, ms_wstring >
{
public:
	explicit _MSString( const ms_wstring& val = L"" ): _MSTVal( val )    {}
	explicit _MSString( ms_wstring&& val ): _MSTVal( std::move( val ) )  {}	

	virtual ms_rc val( ms_wstring& val ) const override	                { val = this->m_val; return MS_OK; }
	virtual ms_rc steal( ms_wstring& val ) override						{ val = std::move( this->m_val ); return MS_OK; }
	virtual ms_wstring stringVal() const override		                    { return this->m_val; }
	virtual void clear() override						                    { this->m_val.clear(); }
};

class _MSBytes final: public _MSTVal< MSDictType::BYTES, ms_bytes >
{
public:
	explicit _MSBytes( const ms_bytes& val = {} ): _MSTVal( val )        {}
	explicit _MSBytes( ms_bytes&& val ): _MSTVal( std::move( val ) )     {}

	virtual ms_rc val( ms_bytes& val ) const override	                    { val = this->m_val; return MS_OK; }
	virtual ms_rc steal( ms_bytes& val ) override							{ val = std::move( this->m_val ); return MS_OK; }

	virtual ms_bytes bytesVal() const override			                    { return this->m_val; }
	virtual void clear() override						                    { this->m_val.clear(); }
};

class _MSArray final: public _MSTVal< MSDictType::ARRAY, ms_dict_array >
{
public:
	explicit _MSArray( const ms_dict_array& val = {} ): _MSTVal( val ) {}
	explicit _MSArray( ms_dict_array&& val ): _MSTVal( std::move( val ) ) {}

	virtual ms_rc val( const size_t idx, MSDict& val ) override			{ return this->_val<MSDict, true>( idx, val ); }
	virtual ms_rc val( const size_t idx, double& val ) override			{ return this->_val<double, false>( idx, val ); }
	virtual ms_rc val( const size_t idx, int32_t& val ) override   		{ return this->_val<int32_t, false>( idx, val ); }
	virtual ms_rc val( const size_t idx, bool& val ) override			    { return this->_val<bool, false>( idx, val ); }
	virtual ms_rc val( const size_t idx, ms_wstring& val ) override		{ return this->_val<ms_wstring, false>( idx, val ); }
	virtual ms_rc val( const size_t idx, ms_bytes& val ) override		    { return this->_val<ms_bytes, false>( idx, val ); }

	virtual ms_rc steal( const size_t idx, MSDict& val ) override			{ return this->_steal<MSDict, true>( idx, val ); }		
	virtual ms_rc steal( const size_t idx, double& val ) override			{ return this->_steal<double, false>( idx, val ); }
	virtual ms_rc steal( const size_t idx, int32_t& val ) override   		{ return this->_steal<int32_t, false>( idx, val ); }
	virtual ms_rc steal( const size_t idx, bool& val ) override			{ return this->_steal<bool, false>( idx, val ); }
	virtual ms_rc steal( const size_t idx, ms_wstring& val ) override		{ return this->_steal<ms_wstring, false>( idx, val ); }		
	virtual ms_rc steal( const size_t idx, ms_bytes& val ) override		{ return this->_steal<ms_bytes, false>( idx, val ); }	

	virtual void clear() override										    { this->m_val.clear(); }
	virtual size_t size() const override								    { return this->m_val.size(); }

	virtual ms_rc add( const MSDict& val ) override	
	{
		this->m_val.emplace_back( val );
		return MS_OK; 
	}

	virtual ms_rc add( MSDict&& val )	override		
	{
		this->m_val.emplace_back( std::move( val ) );
		return MS_OK; 
	}	

	virtual ms_rc remove( const size_t idx ) override		
	{ 
		if ( idx >= this->m_val.size() )
			return MS_ERROR_OUT_OF_RANGE;

		this->m_val.erase( this->m_val.begin() + idx );
		return MS_OK;
	}	
    
	const MSDict& at( const size_t idx ) const override
	{
		assert( ( 0 <= idx && idx < this->m_val.size() ) );
		return this->m_val[idx];
	}

	virtual MSDict& at( const size_t idx ) override
	{
		assert( ( 0 <= idx && idx < this->m_val.size() ) );
		return this->m_val[idx];
	}
	
private:
	
	template<class V, bool isDict>
	ms_rc _val( const size_t idx, V& val )
	{		
		if ( idx >= this->m_val.size() )
			return MS_ERROR_OUT_OF_RANGE;

		return Internal::getVal( this->m_val[idx], val, _MSBool2Type<isDict>() );
	}

	template<class V, bool isDict>
	ms_rc _steal( const size_t idx, V& val )
	{		
		if ( idx >= this->m_val.size() )
			return MS_ERROR_OUT_OF_RANGE;

		return Internal::stealVal( this->m_val[idx], val, _MSBool2Type<isDict>() );		
	}	
};

class _MSObject final: public _MSTVal< MSDictType::OBJECT, ms_dict_object >
{
public:
	_MSObject( const ms_dict_object& val = {} ): _MSTVal( val )        {}
	_MSObject( ms_dict_object&& val ): _MSTVal( std::move( val ) )     {}

	virtual ms_rc val( const ms_wstring& key, MSDict& val ) override			{ return this->_val<MSDict, true>( key, val ); }
	virtual ms_rc val( const ms_wstring& key, double& val ) override			{ return this->_val<double, false>( key, val ); }
	virtual ms_rc val( const ms_wstring& key, int32_t& val ) override			{ return this->_val<int32_t, false>( key, val ); }
	virtual ms_rc val( const ms_wstring& key, bool& val ) override			{ return this->_val<bool, false>( key, val ); }
	virtual ms_rc val( const ms_wstring& key, ms_wstring& val )	override	{ return this->_val<ms_wstring, false>( key, val ); }
	virtual ms_rc val( const ms_wstring& key, ms_bytes& val ) override		{ return this->_val<ms_bytes, false>( key, val ); }
	
	virtual ms_rc steal( const ms_wstring& key, MSDict& val ) override			{ return this->_steal<MSDict, true>( key, val ); }		
	virtual ms_rc steal( const ms_wstring& key, double& val ) override			{ return this->_steal<double, false>( key, val ); }
	virtual ms_rc steal( const ms_wstring& key, int32_t& val ) override			{ return this->_steal<int32_t, false>( key, val ); }
	virtual ms_rc steal( const ms_wstring& key, bool& val ) override				{ return this->_steal<bool, false>( key, val ); }
	virtual ms_rc steal( const ms_wstring& key, ms_wstring& val ) override		{ return this->_steal<ms_wstring, false>( key, val ); }	
	virtual ms_rc steal( const ms_wstring& key, ms_bytes& val ) override			{ return this->_steal<ms_bytes, false>( key, val ); }			

	virtual size_t size() const override	                                    { return this->m_val.size(); }
	virtual void clear() override			                                    { this->m_val.clear(); }

	virtual ms_rc add( const MSDict& val ) override	
	{
		if ( !val.isObject() ) 
		{
			return MS_ERROR_INVALID_INPUT;
		}

		auto keys = val.keys();
		for( auto key: keys )
		{
			this->m_val.emplace( key, val[key] );
		}		
		return MS_OK; 
	}

	virtual ms_rc add( MSDict&& val )	override		
	{
		if ( !val.isObject() ) 
		{
			return MS_ERROR_INVALID_INPUT;
		}

		auto keys = val.keys();
		for( auto key: keys )
		{
			this->m_val.emplace( key, std::move( val[key] ) );
		}		
		return MS_OK; 
	}

	virtual ms_rc add( const ms_wstring& key, const MSDict& val ) override 
	{ 
		auto found = this->m_val.find( key );
		if ( found == this->m_val.end() )
		{
			this->m_val.emplace( key, val );
			return MS_OK;
		}
		found->second = val;
		return MS_OK_REPLACED;
	}

	virtual ms_rc add( const ms_wstring& key, MSDict&& val ) override
	{
		auto found = this->m_val.find( key );
		if ( found == this->m_val.end() )
		{
			this->m_val.emplace( key, std::move( val ) );
			return MS_OK;
		}
		found->second = std::move( val );
		return MS_OK_REPLACED;
	}

	virtual ms_rc remove( const ms_wstring& key ) override	
	{ 
		this->m_val.erase( key ); 
		return MS_OK; 
	}	

	MSDict& at( const ms_wstring& key ) override
	{
		auto found = this->m_val.find( key );
		assert( found != this->m_val.end() );			

		return found->second;
	}

private:	

	template<class V, bool isDict>
	ms_rc _val( const ms_wstring& key, V& val )
	{	
		auto found = this->m_val.find( key );
		if ( found == this->m_val.end() )
			return MS_ERROR_NOT_FOUND;

		return Internal::getVal( found->second, val, _MSBool2Type<isDict>() );		
	}		

	template<class V, bool isDict>
	ms_rc _steal( const ms_wstring& key, V& val )
	{	
		auto found = this->m_val.find( key );
		if ( found == this->m_val.end() )
			return MS_ERROR_NOT_FOUND;
		
		return Internal::stealVal( found->second, val, _MSBool2Type<isDict>() );	
	}

	friend class _MSDot;
};

class _MSCallable final: public _MSDicVal
{
public:
	_MSCallable( const ms_dict_callable& val = nullptr ): m_val( val ) {}		

	MSDictType type() const override								        { return MSDictType::CALLABLE; }
	virtual bool isType( const MSDictType type ) const override	        { return ( MSDictType::CALLABLE == type ); }
	ms_dict_callable& data() { return this->m_val; }

	virtual ms_rc call( MSDict&& in_val, MSDict& out_val ) override
	{
		out_val = this->m_val( std::move( in_val ) );
		return MS_OK;
	}		

	virtual ms_rc step( ms_shared_dict_stepper stepper ) override 
	{
		stepper->step( ms_wstring( L"callable object" ) );
		return MS_OK;
	}

private:
	ms_dict_callable m_val;
};

/* This class is really hot - it makes friend with both MSDict and _MSObject !!!*/
class _MSDot
{
public:
	template<class V, bool isDict, bool steal>
	static ms_rc doDot( std::shared_ptr<_MSDicVal> p_root, const ms_wstring& key_list, V& val )
	{
		if ( key_list.empty() )
		{
			return MS_ERROR_INVALID_INPUT;
		}

		ms_wchar* temp = nullptr;	
		ms_wchar* key_string = new ms_wchar[key_list.size() + 1]{'\0'};
		if ( !key_string )
		{
			return MS_ERROR_MEMORY_DRAINED;
		}
		memcpy( key_string, key_list.c_str(), key_list.size() * sizeof( ms_wchar ) );

			
		std::shared_ptr<_MSDicVal> pre_object = p_root;
		std::shared_ptr<_MSDicVal> object = p_root;		
		ms_wchar* p_tok = wcstok( key_string, L".", &temp );	
		ms_wchar* last_tok = p_tok;

		while ( p_tok && object->isType( MSDictType::OBJECT ) )
		{
			auto u_object = ( _MSObject* )object.get();	// get underlined object
			auto found = u_object->m_val.find( p_tok );
			if ( found == u_object->m_val.end() )
			{
				object.reset();
				break;
			}
			pre_object = object;
			object = found->second.m_val;
			last_tok = p_tok;
			p_tok = wcstok( nullptr, L".", &temp );	
		}

		ms_rc rc = MS_ERROR_NOT_FOUND;
		if ( !p_tok && object )
		{			
			MSDict temp_dict( object );
			if ( steal )
			{				
				Internal::stealVal( temp_dict, val, _MSBool2Type<isDict>() );
				(( _MSObject* )pre_object.get())->at( last_tok ).drop();					
			}
			else
			{				
				Internal::getVal( temp_dict, val, _MSBool2Type<isDict>() );			
			}
			rc = MS_OK;
		}

		if ( key_string )
		{
			delete[] key_string;
		}
		return rc;
	}	

	// type_checked = -1, do not check the type
	static ms_rc dotContain( std::shared_ptr<_MSDicVal> p_root, const ms_wstring& key_list, int type_checked = -1 )
	{
		if ( key_list.empty() )
		{
			return MS_ERROR_INVALID_INPUT;
		}
		
		if ( !p_root->isType( MSDictType::OBJECT ) )
		{
			return MS_ERROR_NOT_SUPPORT;			
		}
		
		ms_wchar* temp = nullptr;	
		std::shared_ptr<ms_wchar> key_string(new ms_wchar[key_list.size() + 1]{'/0'}, std::default_delete<ms_wchar[]>());
		if ( !key_string )
		{
			return MS_ERROR_MEMORY_DRAINED;
		}
		memcpy( key_string.get(), key_list.c_str(), key_list.size() * sizeof( ms_wchar ) );

			
		std::shared_ptr<_MSDicVal> pre_object = p_root;
		std::shared_ptr<_MSDicVal> object = p_root;	
		ms_wchar* p_tok = wcstok( key_string.get(), L".", &temp );	
		ms_wchar* last_tok = p_tok;
		ms_rc rc = MS_OK;
		
		while ( p_tok )
		{
			if ( !object->isType( MSDictType::OBJECT ) )
			{
				rc = MS_ERROR_NOT_SUPPORT;
				break;
			}

			auto u_object = ( _MSObject* )object.get();	// get underlined object
			auto found = u_object->m_val.find( p_tok );
			if ( found == u_object->m_val.end() )
			{				
				rc = MS_ERROR_NOT_FOUND;
				break;
			}
			pre_object = object;
			object = found->second.m_val;
			last_tok = p_tok;
			p_tok = wcstok( nullptr, L".", &temp );	
		}

		if ( MS_FAILED( rc ) ) {
			return rc;
		}

		if ( type_checked < 0 ) {
			return rc;
		}

		return object->isType( ( MSDictType )type_checked )? MS_OK: MS_ERROR_NOT_FOUND;		
	}
};	


MSDict::MSDict() noexcept							    : m_val( _MSDicDefault::nullVal ) {}
MSDict::MSDict( std::nullptr_t ) noexcept			    : m_val( _MSDicDefault::nullVal ) {}
MSDict::MSDict( double val )						    : m_val( std::make_shared<_MSDouble>( val ) ) {}
MSDict::MSDict( int32_t val )							: m_val( std::make_shared<_MSInt>( val ) ) {}
MSDict::MSDict( bool val )							: m_val( val? _MSDicDefault::trueVal: _MSDicDefault::falseVal ) {}
MSDict::MSDict( const ms_wstring& val )				: m_val( std::make_shared<_MSString>( val ) ) {}
MSDict::MSDict( ms_wstring&& val )					: m_val( std::make_shared<_MSString>( std::move( val ) ) ) {}	
MSDict::MSDict( const ms_wchar* val )				: m_val( std::make_shared<_MSString>( val ) ) {}
MSDict::MSDict( const ms_bytes& val )				: m_val( std::make_shared<_MSBytes>( val ) ) {}
MSDict::MSDict( ms_bytes&& val )					    : m_val( std::make_shared<_MSBytes>( std::move( val ) ) ) {}
MSDict::MSDict( const ms_dict_array& vals )	        : m_val( std::make_shared<_MSArray>( vals ) ) {}
MSDict::MSDict( ms_dict_array&& vals )		        : m_val( std::make_shared<_MSArray>( std::move( vals ) ) ) {}
MSDict::MSDict( const ms_dict_object& vals )	        : m_val( std::make_shared<_MSObject>( vals ) ) {}
MSDict::MSDict( ms_dict_object&& vals )		        : m_val( std::make_shared<_MSObject>( std::move( vals ) ) ) {}
MSDict::MSDict( const ms_dict_callable& val )		: m_val( std::make_shared<_MSCallable>( val ) ) {}

MSDict::MSDict( const MSDict& val )
{
	this->_set( val );
}

MSDict::MSDict( MSDict&& val )
{
	this->_set( std::move( val ) );
}

MSDict::MSDict( MSDictType type ) noexcept 
{
	this->become( type );
}	

MSDict& MSDict::operator=( const MSDict& other )
{
	this->_set( other );
	return *this;
}

MSDict& MSDict::operator=( MSDict&& other )
{
	this->_set( std::move( other ) );
	return *this;
}

MSDict& MSDict::operator=( std::nullptr_t )
{
	this->m_val = _MSDicDefault::nullVal;
	return *this;
}

MSDict& MSDict::operator=( double val )
{
	this->m_val = std::make_shared<_MSDouble>( val );
	return *this;
}

MSDict& MSDict::operator=( int32_t val )
{
	this->m_val = std::make_shared<_MSInt>( val );
	return *this;
}

MSDict& MSDict::operator=( bool val )
{
	this->m_val = std::make_shared<_MSBool>( val );
	return *this;
}

MSDict& MSDict::operator=( const ms_wstring& val )
{
	this->m_val = std::make_shared<_MSString>( val );
	return *this;
}

MSDict& MSDict::operator=( ms_wstring&& val )
{
	this->m_val = std::make_shared<_MSString>( std::move( val ) );
	return *this;
}
	
MSDict& MSDict::operator=( const ms_wchar* val )
{
	this->m_val = std::make_shared<_MSString>( val );
	return *this;
}

MSDict& MSDict::operator=( const ms_bytes& val )
{
	this->m_val = std::make_shared<_MSBytes>( val );
	return *this;
}

MSDict& MSDict::operator=( ms_bytes&& val )
{
	this->m_val = std::make_shared<_MSBytes>( std::move( val ) );
	return *this;
}

MSDict& MSDict::operator=( const ms_dict_object& other )
{
	this->m_val = std::make_shared<_MSObject>( other );
	return *this;
}

MSDict& MSDict::operator=( ms_dict_object&& other )
{
	this->m_val = std::make_shared<_MSObject>( std::move( other ) );	
	return *this;
}

MSDict& MSDict::operator=( const ms_dict_array& other )
{
	this->m_val = std::make_shared<_MSArray>( other );	
	return *this;
}

MSDict& MSDict::operator=( ms_dict_array&& other )
{
	this->m_val = std::make_shared<_MSArray>( std::move( other ) );	
	return *this;
}

MSDict& MSDict::operator=( const ms_dict_callable& other )
{
	this->m_val = std::make_shared<_MSCallable>( other );
	return *this;
}


MSDictType MSDict::type() const	                                { return this->m_val->type(); }
bool MSDict::isType( const MSDictType type ) const                { return this->m_val->isType( type ); }
bool MSDict::isNull()	const	                                    { return this->m_val->isType( MSDictType::NUL ); }
bool MSDict::isNumber() const	                                    { return this->m_val->isType( MSDictType::NUMBER ); }
bool MSDict::isIntegral() const	                                 { return this->m_val->isType( MSDictType::INTEGRAL ); }
bool MSDict::isString() const	                                    { return this->m_val->isType( MSDictType::STRING ); }
bool MSDict::isBytes() const	                                    { return this->m_val->isType( MSDictType::BYTES ); }
bool MSDict::isArray() const	                                    { return this->m_val->isType( MSDictType::ARRAY ); }
bool MSDict::isObject() const	                                    { return this->m_val->isType( MSDictType::OBJECT ); }
bool MSDict::isCallable() 	const									{ return this->m_val->isType( MSDictType::CALLABLE ); }

ms_rc MSDict::val( double& val ) const                    		{ return this->m_val->val( val ); }
ms_rc MSDict::val( int32_t& val ) const                  			{ return this->m_val->val( val ); }
ms_rc MSDict::val( bool& val ) const			                    { return this->m_val->val( val ); }
ms_rc MSDict::val( ms_wstring& val ) const                   	{ return this->m_val->val( val ); }
ms_rc MSDict::val( ms_bytes& val ) const		                    { return this->m_val->val( val ); }

ms_rc MSDict::steal( double& val )								
{
	ms_rc rc = this->m_val->steal( val );
	if ( MS_SUCCESS( rc ) )		this->drop();	
	return rc;
}

ms_rc MSDict::steal( int32_t& val )								
{
	ms_rc rc = this->m_val->steal( val );
	if ( MS_SUCCESS( rc ) )		this->drop();	
	return rc;
}

ms_rc MSDict::steal( bool& val )									
{
	ms_rc rc = this->m_val->steal( val );
	if ( MS_SUCCESS( rc ) )		this->drop();	
	return rc;
}

ms_rc MSDict::steal( ms_wstring& val )								{ return this->m_val->steal( val ); }
ms_rc MSDict::steal( ms_bytes& val )									{ return this->m_val->steal( val ); }

ms_rc MSDict::val( const ms_wstring& key, MSDict& val ) const		{ return this->m_val->val( key, val ); }
ms_rc MSDict::val( const ms_wstring& key, double& val ) const		{ return this->m_val->val( key, val ); }
ms_rc MSDict::val( const ms_wstring& key, int32_t& val )	const		{ return this->m_val->val( key, val ); }
ms_rc MSDict::val( const ms_wstring& key, bool& val )	const		{ return this->m_val->val( key, val ); }
ms_rc MSDict::val( const ms_wstring& key, ms_wstring& val ) const	{ return this->m_val->val( key, val ); }
ms_rc MSDict::val( const ms_wstring& key, ms_bytes& val )	const	{ return this->m_val->val( key, val ); }

ms_rc MSDict::dotVal( const ms_wstring& key_list, MSDict& val ) const		{ return _MSDot::doDot<MSDict, true, false>( this->m_val, key_list, val ); }
ms_rc MSDict::dotVal( const ms_wstring& key_list, double& val ) const		{ return _MSDot::doDot<double, false, false>( this->m_val, key_list, val ); }
ms_rc MSDict::dotVal( const ms_wstring& key_list, int32_t& val ) const		{ return _MSDot::doDot<int32_t, false, false>( this->m_val, key_list, val ); }
ms_rc MSDict::dotVal( const ms_wstring& key_list, bool& val ) const			{ return _MSDot::doDot<bool, false, false>( this->m_val, key_list, val ); }
ms_rc MSDict::dotVal( const ms_wstring& key_list, ms_wstring& val ) const	{ return _MSDot::doDot<ms_wstring, false, false>( this->m_val, key_list, val ); }
ms_rc MSDict::dotVal( const ms_wstring& key_list, ms_bytes& val ) const		{ return _MSDot::doDot<ms_bytes, false, false>( this->m_val, key_list, val ); }

ms_rc MSDict::steal( const ms_wstring& key, MSDict& val )					{ return this->m_val->steal( key, val ); }
ms_rc MSDict::steal( const ms_wstring& key, double& val )					{ return this->m_val->steal( key, val ); }	
ms_rc MSDict::steal( const ms_wstring& key, int32_t& val )					{ return this->m_val->steal( key, val ); }
ms_rc MSDict::steal( const ms_wstring& key, bool& val )						{ return this->m_val->steal( key, val ); }
ms_rc MSDict::steal( const ms_wstring& key, ms_wstring& val )				{ return this->m_val->steal( key, val ); }
ms_rc MSDict::steal( const ms_wstring& key, ms_bytes& val )					{ return this->m_val->steal( key, val ); }

ms_rc MSDict::dotSteal( const ms_wstring& key_list, MSDict& val )		{ return _MSDot::doDot<MSDict, true, true>( this->m_val, key_list, val ); }
ms_rc MSDict::dotSteal( const ms_wstring& key_list, double& val )		{ return _MSDot::doDot<double, false, true>( this->m_val, key_list, val ); }		
ms_rc MSDict::dotSteal( const ms_wstring& key_list, int32_t& val )		{ return _MSDot::doDot<int32_t, false, true>( this->m_val, key_list, val ); }
ms_rc MSDict::dotSteal( const ms_wstring& key_list, bool& val )			{ return _MSDot::doDot<bool, false, true>( this->m_val, key_list, val ); }
ms_rc MSDict::dotSteal( const ms_wstring& key_list, ms_wstring& val )	{ return _MSDot::doDot<ms_wstring, false, true>( this->m_val, key_list, val ); }
ms_rc MSDict::dotSteal( const ms_wstring& key_list, ms_bytes& val )		{ return _MSDot::doDot<ms_bytes, false, true>( this->m_val, key_list, val ); }

ms_rc MSDict::val( const size_t idx, MSDict& val ) const		    { return this->m_val->val( idx, val ); }
ms_rc MSDict::val( const size_t idx, double& val ) const			{ return this->m_val->val( idx, val ); }
ms_rc MSDict::val( const size_t idx, int32_t& val ) const			{ return this->m_val->val( idx, val ); }
ms_rc MSDict::val( const size_t idx, bool& val ) const			{ return this->m_val->val( idx, val ); }
ms_rc MSDict::val( const size_t idx, ms_wstring& val ) const		{ return this->m_val->val( idx, val ); }
ms_rc MSDict::val( const size_t idx, ms_bytes& val ) const		{ return this->m_val->val( idx, val ); }

ms_rc MSDict::steal( const size_t idx, MSDict& val )				{ return this->m_val->steal( idx, val ); }
ms_rc MSDict::steal( const size_t idx, double& val )				{ return this->m_val->steal( idx, val ); }
ms_rc MSDict::steal( const size_t idx, int32_t& val )				{ return this->m_val->steal( idx, val ); }
ms_rc MSDict::steal( const size_t idx, bool& val )				{ return this->m_val->steal( idx, val ); }
ms_rc MSDict::steal( const size_t idx, ms_wstring& val )			{ return this->m_val->steal( idx, val ); }
ms_rc MSDict::steal( const size_t idx, ms_bytes& val )			{ return this->m_val->steal( idx, val ); }

ms_rc MSDict::call( MSDict&& in_val, MSDict& out_val ) const	{ return this->m_val->call( std::move( in_val ), out_val ); }
MSDict MSDict::operator()( MSDict&& val ) const					
{ 
	MSDict res;
	ms_rc rc = MS_OK;
	if ( MS_FAILED( rc = this->m_val->call( std::move( val ), res ) ) )
	{
		return ms_dict_object{ { L"code", rc } };
	}
	return res;
}

double 		MSDict::numberVal() const                       		{ return this->m_val->numberVal(); }
int32_t		MSDict::intVal() const			                        { return this->m_val->intVal(); }
bool 		MSDict::boolVal() const			                    { return this->m_val->boolVal(); }
ms_wstring MSDict::stringVal() const	                            { return this->m_val->stringVal(); }
ms_bytes 	MSDict::bytesVal() const		                        { return this->m_val->bytesVal(); }
size_t 		MSDict::size() const			                        { return this->m_val->size(); }

const MSDict& MSDict::operator[]( const size_t idx ) const
{
	assert( this->m_val->type() == MSDictType::ARRAY );
	return this->m_val->at( idx );
}

MSDict& MSDict::operator[]( const size_t idx )
{
	assert( this->m_val->type() == MSDictType::ARRAY );
	return this->m_val->at( idx );
}

const MSDict& MSDict::operator[]( const ms_wstring& key ) const
{
	assert( this->m_val->type() == MSDictType::OBJECT );
	return this->m_val->at( key );
}

MSDict& MSDict::operator[]( const ms_wstring& key )
{
	assert( this->m_val->type() == MSDictType::OBJECT );
	return this->m_val->at( key );
}

ms_rc MSDict::add( const MSDict& val )		                        { return this->m_val->add( val ); }
ms_rc MSDict::add( MSDict&& val )			                        { return this->m_val->add( std::move( val ) ); }
ms_rc MSDict::add( const ms_wstring& key, const MSDict& val )	    { return this->m_val->add( key, val ); }
ms_rc MSDict::add( const ms_wstring& key, MSDict&& val )		    { return this->m_val->add( key, std::move( val ) ); }

void MSDict::clear()								                    { this->m_val->clear(); }
ms_rc MSDict::remove( const size_t idx )			                    { return this->m_val->remove( idx ); }
ms_rc MSDict::remove( const ms_wstring& key )		                { return this->m_val->remove( key ); }
ms_rc MSDict::contain( const ms_wstring& key_list ) const	                { return _MSDot::dotContain( this->m_val, key_list ); }
ms_rc MSDict::contain( const ms_wstring& key_list, const MSDictType type ) const { return _MSDot::dotContain( this->m_val, key_list, ( int )type ); }

ms_dict_keys MSDict::keys() const
{
	ms_dict_keys keys;
	if( this->m_val->isType( MSDictType::OBJECT ) )		
	{
		auto items = ( ( _MSObject* )this->m_val.get() )->data();
		// populate our keys
		for( auto item : items )
		{
			keys.emplace( item.first );
		}
	}
	return keys;
}

void MSDict::become( MSDictType type )
{
	switch ( type )
	{
	case MSDictType::NUL:
		this->m_val = std::make_shared<_MSNull>();
		break;
	case MSDictType::BOOL:
		this->m_val = std::make_shared<_MSBool>();
		break;
	case MSDictType::NUMBER:
		this->m_val = std::make_shared<_MSDouble>( 0. );
		break;
	case MSDictType::INTEGRAL:
		this->m_val = std::make_shared<_MSInt>( 0 );
		break;
	case MSDictType::STRING:
		this->m_val = std::make_shared<_MSString>();
		break;	
	case MSDictType::BYTES:
		this->m_val = std::make_shared<_MSBytes>();
		break;
	case MSDictType::ARRAY:
		this->m_val = std::make_shared<_MSArray>();
		break;
	case MSDictType::OBJECT:
		this->m_val = std::make_shared<_MSObject>();
		break;
	case MSDictType::CALLABLE:
		this->m_val = std::make_shared<_MSCallable>();
		break;
	default:
		this->m_val = std::make_shared<_MSNull>();
		break;
	}
}

void MSDict::drop()
{
	this->m_val = _MSDicDefault::nullVal;
}

ms_rc MSDict::step( std::shared_ptr<MSDictStepper> stepper ) const
{
    if ( !stepper )
    {
        return MS_ERROR_NOT_READY;
    }
    return this->m_val->step( stepper );
}

void MSDict::_set( const MSDict& val )
{
	switch ( val.m_val->type() )
	{
	case MSDictType::NUL:
		this->m_val = _MSDicDefault::nullVal;
		break;
	case MSDictType::BOOL:
		this->m_val = std::make_shared<_MSBool>( val.m_val->boolVal() );
		break;
	case MSDictType::NUMBER:		
		this->m_val = std::make_shared<_MSDouble>( val.m_val->numberVal() );
		break;	
	case MSDictType::INTEGRAL:		
		this->m_val = std::make_shared<_MSInt>( val.m_val->intVal() );		
		break;	
	case MSDictType::STRING:
		this->m_val = std::make_shared<_MSString>( ( ( _MSString* )val.m_val.get() )->data() );
		break;
	case MSDictType::BYTES:
		this->m_val = std::make_shared<_MSBytes>( ( ( _MSBytes* )val.m_val.get() )->data() );
		break;
	case MSDictType::ARRAY:
		this->m_val = std::make_shared<_MSArray>( ( ( _MSArray* )val.m_val.get() )->data() );
		break;
	case MSDictType::OBJECT:
		this->m_val = std::make_shared<_MSObject>( ( ( _MSObject* )val.m_val.get() )->data() );
		break;
	case MSDictType::CALLABLE:
		this->m_val = std::make_shared<_MSCallable>( ( ( _MSCallable* )val.m_val.get() )->data() );
		break;
	default:
		break;
	}
}

void MSDict::_set( MSDict&& val )
{
	switch ( val.m_val->type() )
	{
	case MSDictType::NUL:
		this->m_val = _MSDicDefault::nullVal;
		break;
	case MSDictType::BOOL:
		this->m_val = std::make_shared<_MSBool>( val.m_val->boolVal() );
		break;
	case MSDictType::NUMBER:
		this->m_val = std::make_shared<_MSDouble>( val.m_val->numberVal() );
		break;	
	case MSDictType::INTEGRAL:
		this->m_val = std::make_shared<_MSInt>( val.m_val->intVal() );		
		break;	
	case MSDictType::STRING:
		this->m_val = std::make_shared<_MSString>( std::move( ( ( _MSString* )val.m_val.get() )->data() ) );
		break;
	case MSDictType::BYTES:
		this->m_val = std::make_shared<_MSBytes>( std::move( ( ( _MSBytes* )val.m_val.get() )->data() ) );
		break;
	case MSDictType::ARRAY:
		this->m_val = std::make_shared<_MSArray>( std::move( ( ( _MSArray* )val.m_val.get() )->data() ) );
		break;
	case MSDictType::OBJECT:
		this->m_val = std::make_shared<_MSObject>( std::move( ( ( _MSObject* )val.m_val.get() )->data() ) );
		break;
	case MSDictType::CALLABLE:
		this->m_val = std::make_shared<_MSCallable>( ( ( _MSCallable* )val.m_val.get() )->data() );
		break;
	default:
		break;
	}
}

