#include "ms.h"
#include "ms_defines.h"
#include "ms_config.h"
#include "ms_logger.h"

namespace
{
namespace Internal
{
    void startEngine(ms_shared_engine engine, MalwareScanManager* manager);
    
}
}

// ms_rc EngineManager::init()
// {
//     return _engine->init();
// }

// ms_rc EngineManager::start()
// {
//     ms_rc rc = MS_OK;
//     if(MS_FAILED(rc = _engine->start())){
//         _buildRPFinish->set_value(0);
//     }
//     else
//         _buildRPFinish->set_value(1);
//     return rc;
// }

// ms_rc EngineManager::deinit()
// {
//     return _engine->deinit();
// }

// ms_wstring EngineManager::getScanResult()
// {
//     _additionalData = std::move( _engine->getScanAdditionalData());
//     return _engine->getScanResultData();
// }

// ms_int EngineManager::getActionResult()
// {
//     ms_int action;
//     if( !_additionalData.isNull() && MS_SUCCESS(_additionalData.val(MS_KEY_ACTION_RESULT, action ))){
//         return action;
//     }
//     return 0;
// }

// ms_wstring EngineManager::getExplanationResult()
// {
//     ms_wstring explanation;
//     if( !_additionalData.isNull() && MS_SUCCESS(_additionalData.val(MS_KEY_EXPLANATION_RESULT, explanation ))){
//         return explanation;
//     }
//     return L"";
// }

// ms_wstring EngineManager::getServerID()
// {
//     ms_wstring serverID;
//     if( !_additionalData.isNull() && MS_SUCCESS(_additionalData.val(MS_KEY_SERVER_ID, serverID ))){
//         return serverID;
//     }
//     return L"";
// }

//=============================================== MS Manager ======================
MalwareScanManager* MalwareScanManager::_instance;

void MalwareScanManager::onEngineFinish(ms_shared_engine srcEngine)
{
    std::lock_guard<std::mutex> lock(_mutex);
    _engineQueue.pop_front();
    if (!_engineQueue.empty())
    {
        Internal::startEngine(_engineQueue.front(), _instance);
    }
}

MalwareScanManager* MalwareScanManager::instance()
{
    if (!_instance) {
        _instance =new MalwareScanManager();
        _instance->init();
    }
    return _instance;
}

bool MalwareScanManager::addScanTask(ms_shared_engine srcEngine)
{
    std::lock_guard lock(_mutex);
    _engineQueue.push_back(std::move(srcEngine));
    if ( (_engineQueue.size() == 1) )
    {
        Internal::startEngine(_engineQueue.front(), _instance);
    }
    return true;
}

ms_rc MalwareScanManager::init()
{
    ms_rc rc = MS_OK;
    MSDict sotConfig;
    MSDict scanConfig = MalwareScanConfig::instance()->getConfig();
    if( MS_FAILED( rc = scanConfig.val(MS_KEY_SOT_CONFIG, sotConfig)) ||
        MS_FAILED( rc = sotConfig.val(MS_KEY_ENABLED, _sotEnabled))){
        return rc;
    }
}

ms_rc MalwareScanManager::start()
{
    ms_rc rc = MS_OK;
    if (!_engineQueue.empty())
    {
        Internal::startEngine(_engineQueue.front(), _instance);
    }
}


namespace
{
namespace Internal
{
    void startEngine(ms_shared_engine engine, MalwareScanManager* manager)
    {
        std::thread{ [engine, manager] {
            if( MS_SUCCESS(engine->init()))
                engine->start();
            engine->deinit();
            manager->onEngineFinish(engine);
            }
		}.detach();
    }
}
}
