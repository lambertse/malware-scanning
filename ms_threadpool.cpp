#include "ms_threadpool.h"
#include <iostream>
#include <thread>

ThreadPoolInterface::ThreadPoolInterface(unsigned threadCount)
    : _taskDone(0), done(false)
{
    unsigned threadSupported = std::thread::hardware_concurrency();

    unsigned threadAvailable = std::min(threadCount, threadSupported);

    try
    {
        for (ms_uint i = 0; i < threadAvailable; i++)
        {
            threads.push_back(std::thread(&ThreadPoolInterface::work, this));
            threatMap[threads.back().get_id()] = 0;
        }
    }
    catch(...)
    {
        throw;
    }
}

ThreadPoolInterface::~ThreadPoolInterface()
{
    for (auto& thread : threads)
    {
        try{
            if (thread.joinable()) {
                thread.join();
            }  
        }
        catch(const std::exception& e){
            std::cerr << "Exception caught: " << e.what() << std::endl;
        }
    }
}

void ThreadPoolInterface::stop(){
    done = true;
    for (auto& thread : threads)
    {
        if (thread.joinable()) {
            thread.join();
        }  
    }
}

void ThreadPoolInterface::push(ms_shared_layer_ptr param)
{
    _workQueue.push(param);
}

void ThreadPoolInterface::work()
{
    while (!done)
    {
        ms_shared_layer_ptr task;
        if (this->_workQueue.tryPop(task))
        {
            MSDict outDict; 
            task->start(ms_dict_object{}, outDict);
            {
                std::lock_guard<std::mutex> lockTask(_mtx);
                _taskDone++;
                // std::cout << "Done " << _taskDone << std::endl;
                threatMap[std::this_thread::get_id()]++;
            }
        }
        else
        {
            std::this_thread::yield();
        }
    }
}

ms_bool ThreadPoolInterface::empty() 
{
    return this->_workQueue.empty();
}