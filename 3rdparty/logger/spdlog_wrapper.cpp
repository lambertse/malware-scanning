#include "spdlog_wrapper.h"

#include <spdlog/fmt/ostr.h>
#include <spdlog/sinks/rotating_file_sink.h>
#ifndef _WIN32
    #include <string>
    #include "axz_utils_cryptography.h"
    #include "axz_scu_string.h"
#else
    #include "shared/encoding/InternalEncryption.h"
#endif

namespace owc {
namespace logging {
static fs::path& logDir() {
  static fs::path defaultDir = ".\\";
  return defaultDir;
}
void init(const fs::path& filePath, Prefix defaultLoggerName, size_t maxSize,
          std::chrono::seconds flushEvery) {
  spdlog::set_pattern("[%l] [%m-%d-%C] (%T) %z (%P:%t) [%n]: %v");
  set_level(level::info);
  flush_on(spdlog::level::trace);
  logDir() = filePath.parent_path();

  auto logger = rotating_logger_mt(std::move(defaultLoggerName),  //
                                   filePath.u8string(),           //
                                   maxSize,                       //
                                   1,  // max file count
                                   false);
  logger->info("============ START SESSION MALWARE SCANNING ============");
  set_default_logger(std::move(logger));
}

const fs::path& getDefaultLogDir() { return logDir(); }

void deinit() {
  spdlog::default_logger()->info("============ END SESSION MALWARE SCANNING ============");
  apply_all([](LoggerPtr const& logger) { logger->flush(); });
  drop_all();
}

LoggerPtr createCategory(Prefix name, LoggerPtr logger) {
  if (logger) {
    return logger->clone(std::move(name));
  }
  return default_logger_raw()->clone(std::move(name));
}

LoggerPtr createLogger(const fs::path& filePath, Prefix name, size_t maxSize,
                       size_t maxFileCount) {
  auto u8strpath = filePath.u8string();  // c++20 is basic_string<char8_t>
  auto logger = rotating_logger_mt(std::move(name),                       //
                                   {u8strpath.begin(), u8strpath.end()},  //
                                   maxSize,                               //
                                   maxFileCount,  // max file count
                                   false);
  return logger;
}

std::string encrypt(const std::string_view& text) {
#ifndef _WIN32
    std::string tmp (text.data(), text.size());
    std::string ecrtedText = AxzUtilsCryptography::AESnCFB128nNoPaddingEncrypt (tmp) ;
    return fmt::format("<?>{}</?>", ecrtedText);
#else
  using namespace internal_encryption;
  auto txt = encrypt(text, EncryptDataMode::Base64).value_or("Unencryptable!");
  return fmt::format("<?>{}</?>", txt);
#endif
}
}  // namespace logging
}  // namespace owc