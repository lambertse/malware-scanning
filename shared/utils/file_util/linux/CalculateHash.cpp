#include "../CalculateHash.h"
#include "../../string_util/StringUtils.h"
#include "openssl/evp.h"
#include "openssl/hmac.h"
#include <fstream>
#include <memory>


#define MS_BUFFER_SZE  512

//---------------< _ms_hash_impl class >-----------------------
//
class _ms_hash_impl
{
public:    
    const EVP_MD* md;

public:
    _ms_hash_impl( MSUtilsHashType in_hash_type )
    {        
        OpenSSL_add_all_digests();
        this->md = EVP_get_digestbyname( this->_getName( in_hash_type ) );
    }

    virtual ~_ms_hash_impl() {        
    }

private:
    const char* _getName( MSUtilsHashType in_hash_type )
    {
        switch ( in_hash_type )
        {
            case MS_SHA_256:   return "SHA256";
            case MS_SHA_384:   return "SHA384";
            case MS_SHA_512:   return "SHA512";
            case MS_MD_4:      return "MD4";
            case MS_MD_5:      return "MD5";
        }
        return nullptr;
    }
};


//----------------------< Utils Hash class >-----------------------
//
class _ms_shamd_impl: public _ms_hash_impl
{
public:
    EVP_MD_CTX* mdCtx;

public:
    _ms_shamd_impl( MSUtilsHashType in_hash_type )
        : _ms_hash_impl( in_hash_type )
        , mdCtx( EVP_MD_CTX_create() )
    {}

    virtual ~_ms_shamd_impl()
    {
        if ( this->mdCtx )
        {
            EVP_MD_CTX_destroy( this->mdCtx );
        }
        EVP_cleanup();
    }
};

MSUtilsShamd::MSUtilsShamd( MSUtilsHashType in_hash_type )
    : m_impl( std::make_shared<_ms_shamd_impl>(in_hash_type) ) 
{
    
}

MSUtilsShamd::~MSUtilsShamd()
{   
}


ms_rc MSUtilsShamd::hexCodeOfFile( const std::wstring& in_path, std::wstring& out_code, std::ifstream& srcIs )
{       
    _ms_shamd_impl* impl = ( _ms_shamd_impl* )m_impl.get();
    if ( !impl || !impl->mdCtx || !impl->md )
    {
        return MS_ERROR_MEMORY_DRAINED;
    }

    ms_rc rc = MS_OK;    

    do
    {
        EVP_DigestInit_ex( impl->mdCtx, impl->md, nullptr );

        unsigned int code_len = EVP_MD_CTX_size( impl->mdCtx );
        if ( code_len <= 0 )
        {
            rc = MS_ERROR_NOT_READY;
            break;
        }

        std::shared_ptr<unsigned char> code(new unsigned char[code_len], std::default_delete<unsigned char[]>());
        if ( !code )
        {
            rc = MS_ERROR_MEMORY_DRAINED;
            break;
        }
        std::ifstream tmp( StringUtils::toString( in_path ).c_str(), std::ifstream::binary );
        srcIs(&tmp);
        if ( !srcIs.is_open() )
        {
            rc = MS_ERROR_ACCESS_DENIED;
            break;
        }                
        
        srcIs.seekg( 0, is.end );
        size_t dat_len = is.tellg();
        srcIs.seekg( 0, is.beg );

        unsigned char* buffer = new unsigned char[dat_len];
        if ( !buffer )
        {
            rc = MS_ERROR_MEMORY_DRAINED;
            break;
        }

        srcIs.read( ( char* )buffer, dat_len );               

        EVP_DigestUpdate( impl->mdCtx, buffer, dat_len );                       
        EVP_DigestFinal_ex( impl->mdCtx, code.get(), &code_len );
        if ( buffer )
        {
            delete[] buffer;
        } 
        
        out_code.resize( code_len * 2 );
        auto p_out = ( unsigned int* )out_code.data();
        for( unsigned int i = 0 ; i < code_len ; i++ )
        {
            swprintf( p_out + i * 2, 3, L"%02X", code.get()[i] );        
        }
    } while( 0 );
    
    return rc;
}

