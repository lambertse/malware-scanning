#pragma once

#include <map>
#include <sstream>
#include <string>
#include <functional>
#include <curl/curl.h>
#include <atomic>
#include <ctime>

namespace Curl
{

typedef std::map<std::string, std::string> headers_t;
using Cookies = std::map<std::string, std::string>;
typedef void CURL;
class CurlRequestGroup;

struct CookieOption
{
	enum Action
	{
		Load,
		Store,
		NA
	};

	CookieOption(Action act = NA, Cookies* cookies = nullptr)
            : action(act), cookies(cookies) {}

	std::string encodeCookies(CURL* curl_handle);

	Cookies* cookies = nullptr;
	Action action = Action::NA;
};

struct httpRequest
{
	std::string method;
	std::string url;
	std::istream& request;
	headers_t& requestHeaders;
	std::ostream& response;
	CookieOption cookieOpt;    // storing the cookies, enabled if not empty
	headers_t responseHeaders;	// response.headers[""] is Reason-Phrase
	char error[512]{ '\0' };			// native curl error text
	uint32_t errorCode;			// native curl error code
	uint16_t respCode;			// http response code
	uint16_t connectTimeoutSec = 0;
	uint16_t totalTimeoutSec = 0;
	bool verifyPeer = true;
	bool verboseLogging;
	CurlRequestGroup* session;

	std::string ToString();
};

class CurlRequestGroup {
	public:
		CurlRequestGroup() = default;
		~CurlRequestGroup() = default;

		void request(httpRequest& req);
		void stop();
		size_t readCb(char* buffer, size_t size, size_t nitems,
												void* ptr);
		
		static size_t readCallback(char* buffer, size_t size,
                                           size_t nitems, void* ptr);
	private:
		time_t id_ = std::time(nullptr);
		std::atomic_bool stop_ = false;
};

class CurlLib
{
	static std::string certDirStr;
	static const char* m_certDir;

	CurlLib() { Init(); }
	~CurlLib() {}

	void Init();
	void Deinit() {}

public:
	static CurlLib* getInstance();
	static void destroyInstance();
	static std::string UrlEncode(std::string);
	static std::string UrlDecode(std::string);

	void Request(httpRequest& req);
	static void SetCertLocation(std::string path) { certDirStr = path; m_certDir = certDirStr.c_str(); }
};

inline uint8_t getStausCodeClass(uint16_t respCode)
{
	return static_cast<uint8_t>(respCode / 100);
}

inline bool isStatusCode200s(uint16_t respCode)
{
	return getStausCodeClass(respCode) == 2;
}

inline bool isStatusCodeError(uint16_t respCode)
{
	uint8_t statusClass = getStausCodeClass(respCode);
	return  statusClass == 4 || statusClass == 5;
}

}	//namespace Curl
