

#include "EzCurl.h"
// #include "Logging.h"
#include "../string/StringUtils.h"

#ifdef _WIN32
#include <windows.h>
#include <wincrypt.h>
#else
#include "axz_scu_file.h"
#include "axz_scu_string.h"
#endif

using namespace std;

namespace Curl
{

#ifdef _MSC_VER
#include <curl.h>
#else
#include <curl/curl.h>
#endif

#include <openssl/ssl.h>
#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/x509.h>
#include <openssl/x509_vfy.h>
#include <assert.h>

template<class T>
CURLcode setopt(CURL *curl, CURLoption option, T v)
{
	return curl_easy_setopt(curl, option, static_cast<T>(v));
}

static std::vector<std::string> split(const std::string& to_split, char delimiter) {
  std::vector<std::string> tokens;

  std::stringstream stream(to_split);
  std::string item;
  while (std::getline(stream, item, delimiter)) {
    tokens.push_back(item);
  }

  return tokens;
}

static std::string urlEncode(CURL* curl_handle, const std::string& s) {
  assert(curl_handle);
  char* output = curl_easy_escape(curl_handle, s.c_str(), s.length());
  if (output) {
    std::string result = output;
    curl_free(output);
    return result;
  }
  return "";
}

static Cookies parseRawCookies(curl_slist* raw_cookies) {
  Cookies cookies;
  for (curl_slist* nc = raw_cookies; nc; nc = nc->next) {
    std::vector<std::string> tokens = split(nc->data, '\t');
    std::string value = tokens.back();
    tokens.pop_back();
    cookies[tokens.back()] = value;
  }
  curl_slist_free_all(raw_cookies);
  return cookies;
}

static size_t header_callback(char * buffer, size_t size, size_t nitems, void * outstream)
{
	if (outstream != NULL)
	{
		string header = buffer;
		size_t sp = header.find(':');
		string name;
		if (sp != string::npos)
			name = header.substr(0, sp);

		string value = header.substr(sp != string::npos ? sp : 0);

		if (sp == string::npos)
		{
			size_t skip = value.find(' ') + 1;
			value = value.substr(skip);
			skip = value.find(' ') + 1;
			value = value.substr(skip);
		}
		else
			value = value.substr(1);

		std::wstring tmp = StringUtils::toWideString(value);
		StringUtils::trim(tmp);
		value = StringUtils::toString(tmp);

		if (!name.empty() || !value.empty())
		{
			headers_t& headers = *reinterpret_cast<headers_t*>(outstream);
			headers[name] = value;
		}
	}
	return size * nitems;
}

static size_t read_callback(char* buffer, size_t size, size_t nitems, void * ptr)
{
	if (ptr == NULL)
		return 0;

	istream& stream = *reinterpret_cast<std::istream*>(ptr);

	if (stream.bad() || stream.eof())
		return 0;

	auto currCount = (size_t)stream.read(buffer, size * nitems).gcount();
	return currCount;
}

static int trace_callback(CURL *handle, curl_infotype type, char *data, size_t size, void *userp)
{
	// Taken from curllib docs as is -fdye
	const char *text;
	(void)handle; /* prevent compiler warning */

	switch (type) {
	case CURLINFO_TEXT:
		// logWrite(LogLevel::error, 0, "== Info: %s: ", data);
		/* FALLTHROUGH */
	default: /* in case a new one is introduced to shock us */
		return 0;

	case CURLINFO_HEADER_OUT:
		text = "=> Send header: ";
		break;
	case CURLINFO_DATA_OUT:
		text = "=> Send data: ";
		break;
	case CURLINFO_SSL_DATA_OUT:
		text = "=> Send SSL data: ";
		break;
	case CURLINFO_HEADER_IN:
		text = "<= Recv header: ";
		break;
	case CURLINFO_DATA_IN:
		text = "<= Recv data: ";
		break;
	case CURLINFO_SSL_DATA_IN:
		text = "<= Recv SSL data: ";
		break;
	}

	// logWrite(LogLevel::info, 0, text, data);

	return 0;
}

static size_t write_callback(char * buffer, size_t size, size_t nitems, void * ptr)
{
	if (ptr == NULL)
		return 0;

	ostream& stream = *reinterpret_cast<std::ostream*>(ptr);

	if (!stream.good())
		return 0;

	stream.write(buffer, size * nitems);
	return stream.good() ? size*nitems : 0;
}

#ifdef _WIN32

static X509_STORE* GetStaticStore()
{
	static X509_STORE* store = nullptr;

	if (store != nullptr)
		return store;

	store = X509_STORE_new();

	vector<HCERTSTORE> winstores{
		CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_LOCAL_MACHINE, L"ROOT"),
		CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_LOCAL_MACHINE, L"CA"),
		CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_LOCAL_MACHINE, L"MY"),
		CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_CURRENT_USER, L"ROOT"),
		CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_CURRENT_USER, L"CA"),
		CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_CURRENT_USER, L"MY")
	};

	for (auto winstore : winstores)
	{
		if (winstore == nullptr)
			continue;

		PCCERT_CONTEXT context = nullptr;
		while ((context = CertEnumCertificatesInStore(winstore, context)) != nullptr)
		{
			auto cert = const_cast<const unsigned char **>(&context->pbCertEncoded);
			X509* x509 = d2i_X509(nullptr, cert, context->cbCertEncoded);
			if (x509)
			{
				int i = X509_STORE_add_cert(store, x509);
				X509_free(x509);
			}
		}

		CertFreeCertificateContext(context);
		CertCloseStore(winstore, 0);
	}

	return store;
}

static CURLcode sslctx_function(CURL* curl, void* sslctx, void* parm)
{
	auto This = reinterpret_cast<CurlLib*>(parm);
	auto store = GetStaticStore();
	X509_STORE_up_ref(store);
	SSL_CTX_set_cert_store(reinterpret_cast<SSL_CTX*>(sslctx), store);
	return CURLE_OK;
}

#endif

void CurlLib::Init()
{
	curl_global_init(CURL_GLOBAL_ALL);
}

/*static*/ CurlLib* CurlLib::getInstance()
{
	static auto m_Instance = new CurlLib();
	return m_Instance;
}

/*static*/ void CurlLib::destroyInstance()
{
	getInstance()->Deinit();
	delete getInstance();
}

std::string CurlLib::UrlEncode(std::string unencoded)
{
	if (unencoded.length() <= 0)
		return {};

	char* p = curl_escape(unencoded.c_str(), unencoded.length());
	if (p == nullptr)
		return {};

	string encoded = p;
	curl_free(p);
	return encoded;
}

std::string CurlLib::UrlDecode(std::string encoded)
{
	if (encoded.length() <= 0)
		return {};

	char* p = curl_unescape(encoded.c_str(), encoded.length());
	if (p == nullptr)
		return {};

	string decoded = p;
	curl_free(p);
	return decoded;
}

void CurlLib::Request(httpRequest& req)
{
	if (sizeof(req.error) < CURL_ERROR_SIZE)
	{
		string msg = "httpRequest::error smaller than CURL_ERROR_SIZE";
		std::copy(msg.begin(), msg.end(), req.error);
		req.errorCode = -3;
		return;
	}

	CURL* curl_handle = curl_easy_init();
  curl_easy_setopt(curl_handle, CURLOPT_COOKIEFILE, "");
	if (curl_handle == NULL)
	{
		string msg = "curl_easy_init failed";
		std::copy(msg.begin(), msg.end(), req.error);
		req.errorCode = -2;
		return;
	}

	if (req.verboseLogging) {
		setopt<curl_debug_callback>(curl_handle, CURLOPT_DEBUGFUNCTION, trace_callback);
		setopt<uint32_t>(curl_handle, CURLOPT_VERBOSE, 1L);
	}

	setopt<const char*>(curl_handle, CURLOPT_URL, req.url.c_str());

	if (req.method != "GET" && req.method != "HEAD" && req.request.good())
	{
		req.request.seekg(0, std::ios::end);
		std::streampos fsize = req.request.tellg();
		req.request.seekg(0, std::ios::beg);
		req.request.clear();

		if (fsize > 0)
		{
			setopt<uint32_t>(curl_handle, CURLOPT_POST, 1);
			setopt<uint64_t>(curl_handle, CURLOPT_POSTFIELDSIZE_LARGE, fsize);
      if (req.session) {
				setopt<curl_read_callback>(curl_handle, CURLOPT_READFUNCTION, &CurlRequestGroup::readCallback);
				setopt<httpRequest*>(curl_handle, CURLOPT_READDATA, &req);
      } else {
				setopt<curl_read_callback>(curl_handle, CURLOPT_READFUNCTION, read_callback);
				setopt<std::istream*>(curl_handle, CURLOPT_READDATA, &req.request);
      }
		}
	}

	setopt<const char*>(curl_handle, CURLOPT_CUSTOMREQUEST, req.method.c_str());

	// Set Custom Headers, Required for Non URL Encoded POST - ie. Content-Type: text/html
	curl_slist * header_list = NULL;
	req.requestHeaders["User-Agent"] = "OPSWAT Client";
	if (!req.requestHeaders.empty()) {
		for (auto header : req.requestHeaders) {
			header_list = curl_slist_append(header_list, (header.first + ": " + header.second).c_str());
		}

		setopt<curl_slist *>(curl_handle, CURLOPT_HTTPHEADER, header_list);
	}

	setopt<uint32_t>(curl_handle, CURLOPT_TCP_KEEPALIVE, true);
	setopt<uint32_t>(curl_handle, CURLOPT_TCP_KEEPIDLE, 120);
	setopt<uint32_t>(curl_handle, CURLOPT_TCP_KEEPINTVL, 60);		// interval time between keep-alive probes

	setopt<uint32_t>(curl_handle, CURLOPT_SSL_VERIFYPEER, req.verifyPeer);
	setopt<uint32_t>(curl_handle, CURLOPT_SSL_VERIFYHOST, req.verifyPeer ? 2 : 0);	// should be default but make sure

	// Https certificate verification
	if (req.verifyPeer)
	{

#ifdef _WIN32
		{
			setopt<char*>(curl_handle, CURLOPT_CAINFO, nullptr);
			setopt<char*>(curl_handle, CURLOPT_CAPATH, nullptr);
			setopt<curl_ssl_ctx_callback>(curl_handle, CURLOPT_SSL_CTX_FUNCTION, sslctx_function);
			setopt<CurlLib*>(curl_handle, CURLOPT_SSL_CTX_DATA, this);
		}
#else
		{
			std::wstring cert_path;
        	AxzScuFile::moduleDir( cert_path );

        	curl_easy_setopt( curl_handle, CURLOPT_CAINFO, AxzScuString::toString(cert_path + L"curl-ca-bundle.crt").c_str() );
		}
#endif
	}
	if (req.cookieOpt.action == CookieOption::Load)
	{
		curl_easy_setopt(curl_handle, CURLOPT_COOKIELIST, "ALL");
		curl_easy_setopt(curl_handle, CURLOPT_COOKIE, req.cookieOpt.encodeCookies(curl_handle).c_str());
	}
	setopt<curl_write_callback>(curl_handle, CURLOPT_WRITEFUNCTION, write_callback);
	setopt<std::ostream*>(curl_handle, CURLOPT_WRITEDATA, &req.response);
	setopt<headers_t*>(curl_handle, CURLOPT_HEADERDATA, &req.responseHeaders);
	setopt<curl_write_callback>(curl_handle, CURLOPT_HEADERFUNCTION, header_callback);

	setopt<char*>(curl_handle, CURLOPT_ERRORBUFFER, req.error);
	setopt<uint32_t>(curl_handle, CURLOPT_TIMEOUT, req.totalTimeoutSec);	// Set the timeout of the whole operation, (default is 0, which means no timeout)
	setopt<uint32_t>(curl_handle, CURLOPT_CONNECTTIMEOUT, req.connectTimeoutSec); // Set the timeout for connecting to the server. (default is 0, which uses 300 seconds)
	req.errorCode = curl_easy_perform(curl_handle);
	
	if (req.cookieOpt.action == CookieOption::Store && req.cookieOpt.cookies) 
	{
    curl_slist* raw_cookies{nullptr};
    curl_easy_getinfo(curl_handle, CURLINFO_COOKIELIST, &raw_cookies);
    (*req.cookieOpt.cookies) = parseRawCookies(raw_cookies);
  }

	if (req.errorCode == 0)
		curl_easy_getinfo(curl_handle, CURLINFO_RESPONSE_CODE, &req.respCode);

	if (header_list != NULL)
		curl_slist_free_all(header_list);

	curl_easy_cleanup(curl_handle);
}

const char* CurlLib::m_certDir = NULL;
std::string CurlLib::certDirStr;

std::string httpRequest::ToString()
{
	std::stringstream ss;

	ss << method << " " << url;
	if (errorCode != 0)
		ss << ", Error Code: " << errorCode;

	if (*error != '\0')		// not empty
		ss << ", Error: " << std::string(error);

	ss << ", " << respCode;
	if (responseHeaders.count("") > 0)
		ss << " " << responseHeaders[""];

	ss << ", Request Headers:{ ";
	for (auto header = requestHeaders.begin(); header != requestHeaders.end(); )
	{
		ss << header->first << ": " << header->second;
		if (++header != requestHeaders.end())
			ss << ", ";
	}
	ss << " }";

	ss << ", Response Headers:{ ";
	for (auto header = responseHeaders.begin(); header != responseHeaders.end(); )
	{
		if (header->first.empty())
		{
			++header;
			continue;
		}
		ss << header->first << ": " << header->second;
		if (++header != responseHeaders.end())
			ss << ", ";
	}
	ss << " }";

	return ss.str();
}

std::string CookieOption::encodeCookies(CURL* curl_handle) {
  if (!cookies) {
    return {};
	}
  std::stringstream stream;
  for (const auto& item : (*cookies)) {
    // Depending on if encoding is set to "true", we will URL-encode cookies
    stream << urlEncode(curl_handle, item.first) << "=";

    // special case version 1 cookies, which can be distinguished by
    // beginning and trailing quotes
    if (!item.second.empty() && item.second.front() == '"' &&
        item.second.back() == '"') {
      stream << item.second;
    } else {
      // Depending on if encoding is set to "true", we will URL-encode cookies
      stream << urlEncode(curl_handle, item.second);
    }
    stream << "; ";
  }
  return stream.str();
}
size_t CurlRequestGroup::readCallback(char* buffer, size_t size, size_t nitems,
                                 void* ptr) {
  auto req = static_cast<httpRequest*>(ptr);
  return req->session->readCb(buffer, size, nitems, &req->request);
}

void CurlRequestGroup::request(httpRequest& req) {
  using namespace std::placeholders;
  req.session = this;
  CurlLib::getInstance()->Request(req);
}

void CurlRequestGroup::stop() { stop_ = true; }

size_t CurlRequestGroup::readCb(char* buffer, size_t size, size_t nitems,
                           void* ptr) {
  if (stop_) {
    return CURL_READFUNC_ABORT;
  }
  if (ptr == NULL) return 0;
  istream& stream = *reinterpret_cast<std::istream*>(ptr);
  if (stream.bad() || stream.eof()) return 0;

  auto currCount = (size_t)stream.read(buffer, size * nitems).gcount();
  return currCount;
}
}  // namespace Curl


