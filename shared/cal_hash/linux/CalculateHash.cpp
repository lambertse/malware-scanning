#include "../CalculateHash.h"
// #include "axz_scu_string.h"
#include "openssl/evp.h"
#include "openssl/hmac.h"
#include <fstream>
#include <memory>


#define MS_BUFFER_SZE  512

//---------------< _axz_hash_impl class >-----------------------
//
class _axz_hash_impl
{
public:    
    const EVP_MD* md;

public:
    _axz_hash_impl( AxzUtilsHashType in_hash_type )
    {        
        OpenSSL_add_all_digests();
        this->md = EVP_get_digestbyname( this->_getName( in_hash_type ) );
    }

    virtual ~_axz_hash_impl() {        
    }

private:
    const char* _getName( AxzUtilsHashType in_hash_type )
    {
        switch ( in_hash_type )
        {
            case MS_SHA_256:   return "SHA256";
            case MS_SHA_384:   return "SHA384";
            case MS_SHA_512:   return "SHA512";
            case MS_MD_4:      return "MD4";
            case MS_MD_5:      return "MD5";
        }
        return nullptr;
    }
};


//----------------------< Utils Hash class >-----------------------
//
class _axz_shamd_impl: public _axz_hash_impl
{
public:
    EVP_MD_CTX* mdCtx;

public:
    _axz_shamd_impl( AxzUtilsHashType in_hash_type )
        : _axz_hash_impl( in_hash_type )
        , mdCtx( EVP_MD_CTX_create() )
    {}

    virtual ~_axz_shamd_impl()
    {
        if ( this->mdCtx )
        {
            EVP_MD_CTX_destroy( this->mdCtx );
        }
        EVP_cleanup();
    }
};

AxzUtilsShamd::AxzUtilsShamd( AxzUtilsHashType in_hash_type )
    : m_impl( std::make_shared<_axz_shamd_impl>(in_hash_type) ) 
{
    
}

AxzUtilsShamd::~AxzUtilsShamd()
{   
}

ms_rc AxzUtilsShamd::hexCodeOfBytes( const axz_bytes& in_bytes, axz_wstring& out_code )
{
    _axz_shamd_impl* impl = ( _axz_shamd_impl* )m_impl.get();    
    if ( !impl || !impl->mdCtx || !impl->md )
    {
        return MS_ERROR_MEMORY_DRAINED;
    }            
       
    EVP_DigestInit_ex( impl->mdCtx, impl->md, nullptr );
    unsigned int code_len = EVP_MD_CTX_size( impl->mdCtx );
    if ( code_len <= 0 )
    {
        return MS_ERROR_NOT_READY;
    }

    unsigned char* code = new unsigned char[code_len];
    if ( !code )
    {
        return MS_ERROR_MEMORY_DRAINED;
    }
    
    EVP_DigestSignUpdate( impl->mdCtx, ( char* )in_bytes.data(), in_bytes.size() );
    EVP_DigestFinal_ex( impl->mdCtx, code, &code_len );
    
    out_code.resize( code_len * 2 );
    auto p_out = ( axz_wchar* )out_code.data();    
    for( unsigned int i = 0 ; i < code_len ; i++ )
    {
        swprintf( p_out + i * 2, 3, L"%02X", code[i] );        
    }

    if ( code )
    {
        delete[] code;
    }
    
    return MS_OK;
}

ms_rc AxzUtilsShamd::hexCodeOfBytesR( const axz_bytes& in_bytes, axz_string& out_code )
{
    _axz_shamd_impl* impl = ( _axz_shamd_impl* )m_impl.get();    
    if ( !impl || !impl->mdCtx || !impl->md )
    {
        return MS_ERROR_MEMORY_DRAINED;
    }            
       
    EVP_DigestInit_ex( impl->mdCtx, impl->md, nullptr );
    unsigned int code_len = EVP_MD_CTX_size( impl->mdCtx );
    if ( code_len <= 0 )
    {
        return MS_ERROR_NOT_READY;
    }

    unsigned char* code = new unsigned char[code_len];
    if ( !code )
    {
        return MS_ERROR_MEMORY_DRAINED;
    }
    
    EVP_DigestSignUpdate( impl->mdCtx, ( char* )in_bytes.data(), in_bytes.size() );
    EVP_DigestFinal_ex( impl->mdCtx, code, &code_len );
    
    out_code.resize(code_len);
    out_code = axz_string { code, code + code_len };

    if ( code )
    {
        delete[] code;
    }
    
    return MS_OK;
}

ms_rc AxzUtilsShamd::hexCodeOfFile( const axz_wstring& in_path, axz_wstring& out_code )
{       
    _axz_shamd_impl* impl = ( _axz_shamd_impl* )m_impl.get();
    if ( !impl || !impl->mdCtx || !impl->md )
    {
        return MS_ERROR_MEMORY_DRAINED;
    }

    ms_rc rc = MS_OK;    

    do
    {
        EVP_DigestInit_ex( impl->mdCtx, impl->md, nullptr );

        unsigned int code_len = EVP_MD_CTX_size( impl->mdCtx );
        if ( code_len <= 0 )
        {
            rc = MS_ERROR_NOT_READY;
            break;
        }

        std::shared_ptr<unsigned char> code(new unsigned char[code_len], std::default_delete<unsigned char[]>());
        if ( !code )
        {
            rc = MS_ERROR_MEMORY_DRAINED;
            break;
        }

        std::ifstream is( AxzScuString::toString( in_path ).c_str(), std::ifstream::binary );
        if ( !is.is_open() )
        {
            rc = MS_ERROR_ACCESS_DENIED;
            break;
        }                
        
        is.seekg( 0, is.end );
        size_t dat_len = is.tellg();
        is.seekg( 0, is.beg );

        unsigned char* buffer = new unsigned char[dat_len];
        if ( !buffer )
        {
            rc = MS_ERROR_MEMORY_DRAINED;
            break;
        }

        is.read( ( char* )buffer, dat_len );               

        EVP_DigestUpdate( impl->mdCtx, buffer, dat_len );                       
        EVP_DigestFinal_ex( impl->mdCtx, code.get(), &code_len );
        if ( buffer )
        {
            delete[] buffer;
        } 
        
        out_code.resize( code_len * 2 );
        auto p_out = ( axz_wchar* )out_code.data();
        for( unsigned int i = 0 ; i < code_len ; i++ )
        {
            swprintf( p_out + i * 2, 3, L"%02X", code.get()[i] );        
        }
    } while( 0 );
    
    return rc;
}

//--------------------------<AxzUtilsHmac class>----------------------------------------
//
class _axz_hmac_impl: public _axz_hash_impl
{
public:
    HMAC_CTX* hmacCtx;

public:
    _axz_hmac_impl( AxzUtilsHashType in_hash_type )
        : _axz_hash_impl( in_hash_type )
        , hmacCtx( HMAC_CTX_new() )
    {}

    virtual ~_axz_hmac_impl()
    {
        if ( this->hmacCtx )
        {
            HMAC_CTX_free( this->hmacCtx );
        }
    }
};

AxzUtilsHmac::AxzUtilsHmac( AxzUtilsHashType in_hash_type )
    : m_impl( std::make_shared<_axz_hmac_impl>( in_hash_type ) ) 
{
}

AxzUtilsHmac::~AxzUtilsHmac()
{
}

ms_rc AxzUtilsHmac::hexCodeOfBytes( const axz_bytes& in_key, const axz_bytes& in_data, axz_bytes& out_code )
{
    _axz_hmac_impl* impl = ( _axz_hmac_impl* )m_impl.get();        
    
    if ( !impl || !impl->md || !impl->hmacCtx )
    {
        return MS_ERROR_NOT_READY;
    }

    HMAC_Init_ex( impl->hmacCtx, in_key.data(), ( int )in_key.size(), impl->md, nullptr );    

    unsigned int code_len = ( unsigned int )HMAC_size( impl->hmacCtx );    
    if ( code_len <= 0 )
    {
        return MS_ERROR_NOT_READY;
    }

    unsigned char* code = new unsigned char[code_len];
    if ( !code )
    {
        return MS_ERROR_MEMORY_DRAINED;        
    }
    
    HMAC_Update( impl->hmacCtx, in_data.data(), in_data.size() );
    HMAC_Final( impl->hmacCtx, code, &code_len );

    out_code.resize( code_len * 2 );
    auto p_out = ( char* )out_code.data();
    for( unsigned int i = 0 ; i < code_len ; i++ )
    {
        snprintf( p_out + i * 2, 3, "%02X", code[i] );        
    }

    if ( code )
    {
        delete[] code;
    }
    return MS_OK;
}

ms_rc AxzUtilsHmac::hexCodeOfBytesR( const axz_bytes& in_key, const axz_bytes& in_data, axz_bytes& out_code )
{
    _axz_hmac_impl* impl = ( _axz_hmac_impl* )m_impl.get();        
    
    if ( !impl || !impl->md || !impl->hmacCtx )
    {
        return MS_ERROR_NOT_READY;
    }

    HMAC_Init_ex( impl->hmacCtx, in_key.data(), ( int )in_key.size(), impl->md, nullptr );    

    unsigned int code_len = ( unsigned int )HMAC_size( impl->hmacCtx );    
    if ( code_len <= 0 )
    {
        return MS_ERROR_NOT_READY;
    }

    unsigned char* code = new unsigned char[code_len];
    if ( !code )
    {
        return MS_ERROR_MEMORY_DRAINED;        
    }
    
    HMAC_Update( impl->hmacCtx, in_data.data(), in_data.size() );
    HMAC_Final( impl->hmacCtx, code, &code_len );

    out_code.resize( code_len );
    auto p_out = ( unsigned char* )out_code.data();
    for( unsigned int i = 0 ; i < code_len ; i++ )
    {
        p_out[i] = code[i] & 0xFF;    
    }	

    if ( code )
    {
        delete[] code;
    }
    return MS_OK;
}