#include "ms_buildrp_task.h"
#include "ms_defines.h"
#include "3rdparty/msdict/ms_json.h"

#define RESTRICTED_REPORT_AMOUNT 100

namespace{
namespace Internal{
    ms_rc createSOTReportData( ms_dict_object r, MSDict& sotReportData);
}
}

MalwareScanBuildRP::MalwareScanBuildRP()
{
}

MalwareScanBuildRP::~MalwareScanBuildRP()
{
}

ms_rc MalwareScanBuildRP::start(const MSDict &in_dict, MSDict &out_dict)
{
    return ms_rc();
}

MSDict MalwareScanBuildRP::onNewFileScanned( MSDict file_result)
{
    std::cout << "On new file scanned" <<std::endl;
    _blockedResults[L"name"] = std::move(file_result);
    // _ignoredResults.add(L"name2", file_result);
    onScanFinished();
}

ms_rc MalwareScanBuildRP::onScanFinished()
{
    buildAndSendScanReport();
}

ms_rc MalwareScanBuildRP::buildAndSendScanReport()
{
    ms_rc rc = MS_OK;

    MSDict sotReportData;
    if(MS_FAILED( rc = createSOTReport(sotReportData))){
        return rc;
    }

    std::wstring tmp;
    MSJson::serialize(sotReportData, tmp);

    return rc;
}

ms_rc MalwareScanBuildRP::createSOTReport(MSDict &sotReportData)
{
    ms_rc rc = MS_OK;

    sotReportData.add( MS_KEY_START_TIME,           static_cast<int>(startTime));
    sotReportData.add( MS_KEY_END_TIME,             static_cast<int>(endTime));
    // sotReportData.add( MS_KEY_TOTAL_VUL_FILE,       static_cast<int>(_vulnarableResults.keys().size()));
    sotReportData.add( MS_KEY_TOTAL_SCANNED_FILE,   totalScannedFile);
    // sotReportData.add( MS_KEY_TOTAL_INFECTED_FILE,  static_cast<int>(_blockedResults.keys().size()));

    // std::cout << _blockedResults.keys().size() << std::endl;

    if (!_blockedResults.empty())
    {
       MSDict blckData;
       if( MS_FAILED( rc = Internal::createSOTReportData(_blockedResults, blckData))){
            return rc;
       }
       ms_dict_object infectedSumary =  { {MS_KEY_DATA, blckData} } ;
        // if (isScanningAgainstMDCloudServer()) {
        //     joInfectedSumary["engine_detected"] = sumaryInfectedEngines(_joBlockedResults);
        // }
        sotReportData.add ( MS_KEY_INFECTED_FILES, infectedSumary );

    }
    if (!_ignoredResults.empty()) {
        MSDict ignoreData;
        if( MS_FAILED( rc = Internal::createSOTReportData(_ignoredResults, ignoreData))){
            return rc;
       }
        sotReportData.add ( MS_KEY_INFECTED_FILES, ignoreData );
    }

    return rc;
}

MSDict MalwareScanBuildRP::getSummaryData()
{
    ms_dict_object summaryData =  {
        // { MS_KEY_EXPLA_MSG,             explainationMsg },
        // { MS_KEY_COMPLETE_PERCENT,      completePercentage.get() },
        // { MS_KEY_START_TIME,            startTime },
        // { MS_KEY_END_TIME,              endTime },
        // { MS_KEY_TOTAL_SCANNED_FILE,    totalScannedFile },
        // { MS_KEY_TOTAL_ALLOWED_FILE,    totalAllowedFile },
        // { MS_KEY_PRCED_DATA_SIZE,       processedDataSize },
        // { MS_KEY_BATCH_ID,          batchID },
        // { MS_KEY_JOB_ID,            jobId }
    };
    return summaryData;
}

namespace{
namespace Internal{
    ms_rc createSOTReportData(ms_dict_object r , MSDict& sotReportData)
    {
        ms_dict_object results = std::move(r);
        // std::wstring tmp;
        // MSJson::serialize(results, tmp);
        // std::cout << StringUtils::toString(tmp) << std::endl;
        ms_rc rc = MS_OK;
        ms_dict_array dataReport;
        for(std::pair<std::wstring, MSDict> res : results){
            std::wstring filePath = res.first;
            MSDict fileInfo = res.second;
            MSDict scanResult;

            std::wstring startTime;
            if( MS_FAILED (rc = fileInfo.val(MS_KEY_SCAN_RES, scanResult)) &&
                MS_FAILED (rc = scanResult.val(MS_KEY_START_TIME, startTime)) ){
                return rc;
            }

            ms_dict_array threatArr;
            MSDict threats;
            if( MS_FAILED (rc = scanResult.val(MS_KEY_SCAN_DETAIL, threats))){
                return rc;
            }
            auto threatEngines = threats.keys();
            for(auto engineName : threatEngines){
                if(threats[engineName][MS_KEY_SCAN_RES_I].intVal() == 1){
                    threatArr.emplace_back(ms_dict_object{
							{ MS_KEY_NAME, threats[engineName][MS_KEY_THREAT_FOUND] },
							{ MS_KEY_ENGINE_NAME, engineName },
							{ MS_KEY_ENGINE_DEF_DATE, (int)StringUtils::utcTimeStrToTimet( StringUtils::toString(threats[engineName][MS_KEY_DEF_TIME].stringVal())) } 
                            });
                }
            } 
            dataReport.emplace_back(ms_dict_object {
					{ MS_KEY_NAME, filePath },
					{ MS_KEY_PATH, filePath},
					{ MS_KEY_TIME, startTime },
					{ MS_KEY_HASH, fileInfo[MS_KEY_FILE_INFO][MS_KEY_SHA_256] },
					{ MS_KEY_DATA_ID, fileInfo[MS_KEY_DATA_ID] },
					{ MS_KEY_THREATS, std::move(threatArr) } });

            if (dataReport.size() >= RESTRICTED_REPORT_AMOUNT) {
                break;
            } 
        }
        std::wstring tmp;
        MSJson::serialize(dataReport, tmp);
        std::cout << StringUtils::toString(tmp) << std::endl;
        sotReportData = std::move(dataReport);
        return rc;

    }
}
}