#include "ms_buildrp_task.h"
#include "ms_defines.h"
#include "3rdparty/msdict/ms_json.h"

#include <experimental/filesystem>

#define RESTRICTED_REPORT_AMOUNT 100
namespace fs = std::experimental::filesystem;

namespace{
namespace Internal{
    ms_rc createSOTReportData( MSDict in_dict, MSDict& sotReportData);
    ms_rc getConclusion( const MSDict& result,FileScanConclusion& conclusion);
    
    ms_rc isBlockedResult(const MSDict &result, ms_wstring& isBlock);
}
}

MalwareScanBuildRP::~MalwareScanBuildRP()
{
}

ms_rc MalwareScanBuildRP::start(const MSDict &in_dict, MSDict &out_dict)
{
    return ms_rc();
}

MSDict MalwareScanBuildRP::onNewFileScanned( MSDict file_result)
{
    MSDict fileInfo;
    ms_wstring fileSizeStr;
    if( MS_FAILED ( file_result.val( MS_KEY_FILE_INFO, fileInfo )  ||
        MS_FAILED ( fileInfo.val(MS_KEY_FILE_SIZE, fileSizeStr)))){
            std::cout << "Cannot get fileszie\n";
            return MSDict();
    }
    size_t fileSize = fileSizeStr == L"" ? 0 : std::stoull(fileSizeStr);

    // ms_wstring tmp;
    // MSJson::serialize(file_result, tmp);
    // std::cout << StringUtils::toString(tmp) << std::endl;

    ms_wstring b;
    if ( MS_SUCCESS(Internal::isBlockedResult(file_result, b)) && b == MS_BLOCKED){
        std::cout << "Find "<< ++_totalBlockFile <<" block file" << std::endl;
        file_result.add( MS_KEY_RESULT, FileScanStatus::BlockedFile);
        onNewBlockResult(file_result);
    }
    else{
        // std::cout << "Not a block file\n";
    }
    onNewFileProcessed(fileSize);
    return MS_OK;
}

ms_rc MalwareScanBuildRP::onNewBlockResult(MSDict file_result)
{
    ms_rc rc = MS_OK;
    FileScanConclusion conclusion;
    
    ms_wstring filePath;
    file_result.steal(MS_KEY_FILE_PATH, filePath);
    {
        std::lock_guard<std::mutex> lock(_mtx);
        if( MS_SUCCESS( rc = Internal::getConclusion(file_result, conclusion) ) &&
            conclusion == FileScanConclusion::PotentiallyVulnerableFile){
            _vulnarableResults.add(filePath, file_result);
        }
        _blockedResults.add(filePath, file_result);
    }
}

ms_rc MalwareScanBuildRP::onNewFileProcessed(const size_t& fileSize)
{
    {

        std::lock_guard<std::mutex> lock(_mtx);
        processedDataSize += fileSize;
        std::cout << "Processed " << totalScannedFile << std::endl;
        if( ++totalScannedFile == _totalTask){
            onScanFinished();
        }
    }
}

ms_rc MalwareScanBuildRP::onScanFinished()
{
    ms_rc rc = MS_OK;
    filterIgnoredResults(); 
    buildAndSendScanReport();
    _tellEngineToStop.set_value(1);
    return rc;
}

ms_rc MalwareScanBuildRP::filterIgnoredResults()
{
    return ms_rc();
}

ms_rc MalwareScanBuildRP::buildAndSendScanReport()
{
    ms_rc rc = MS_OK;

    endTime = std::time(nullptr);

    MSDict reportDict, resultData;
    if(MS_FAILED( rc = createSOTReport(resultData))){
        return rc;
    }

    // reportDict.add()


    ms_wstring tmp;
    MSJson::serialize(resultData, tmp);
    std::cout << StringUtils::toString(tmp) << std::endl;
    return rc;
}

ms_rc MalwareScanBuildRP::createSOTReport(MSDict &sotReportData)
{
    ms_rc rc = MS_OK;
    sotReportData.become(MSDictType::OBJECT);

    if( MS_FAILED ( rc = sotReportData.add( MS_KEY_START_TIME,           static_cast<int>(startTime)) ) ||
        MS_FAILED ( rc = sotReportData.add( MS_KEY_END_TIME,             static_cast<int>(endTime)) ) ||
        MS_FAILED ( rc = sotReportData.add( MS_KEY_TOTAL_VUL_FILE,       static_cast<int>(_vulnarableResults.size()))) ||
        MS_FAILED ( rc = sotReportData.add( MS_KEY_TOTAL_SCANNED_FILE,   totalScannedFile) ) ||
        MS_FAILED ( rc = sotReportData.add( MS_KEY_TOTAL_INFECTED_FILE,  static_cast<int>(_blockedResults.size())) )){
            return rc;
    }
    

    if (_blockedResults.size() != 0)
    {
       MSDict blckData;
       if( MS_FAILED( rc = Internal::createSOTReportData(_blockedResults, blckData))){
            return rc;
       }
       ms_dict_object infectedSumary =  { {MS_KEY_DATA, blckData} } ;
        // if (isScanningAgainstMDCloudServer()) {
        //     joInfectedSumary["engine_detected"] = sumaryInfectedEngines(_joBlockedResults);
        // }
        sotReportData.add ( MS_KEY_INFECTED_FILES, infectedSumary );

    }
    if (_ignoredResults.size() != 0) {
        MSDict ignoreData;
        if( MS_FAILED( rc = Internal::createSOTReportData(_ignoredResults, ignoreData))){
            return rc;
       }
        sotReportData.add ( MS_KEY_IGNORED_FILES, ms_dict_object{{MS_KEY_DATA, ignoreData}} );
    }

    return rc;
}

void MalwareScanBuildRP::setTotalTask(int srcTotalTask)
{
    _totalTask = srcTotalTask;
    if(_totalTask == totalScannedFile){
        onScanFinished();
    }
}

MSDict MalwareScanBuildRP::getSummaryData()
{
    ms_dict_object summaryData =  {
        // { MS_KEY_EXPLA_MSG,             explainationMsg },
        // { MS_KEY_COMPLETE_PERCENT,      completePercentage.get() },
        // { MS_KEY_START_TIME,            startTime },
        // { MS_KEY_END_TIME,              endTime },
        // { MS_KEY_TOTAL_SCANNED_FILE,    totalScannedFile },
        // { MS_KEY_TOTAL_ALLOWED_FILE,    totalAllowedFile },
        // { MS_KEY_PRCED_DATA_SIZE,       processedDataSize },
        // { MS_KEY_BATCH_ID,          batchID },
        // { MS_KEY_JOB_ID,            jobId }
    };
    return summaryData;
}

namespace{
namespace Internal{
    ms_rc createSOTReportData(MSDict in_dict , MSDict& sotReportData)
    {
        ms_rc rc = MS_OK;
        ms_dict_array dataReport;
        std::set<ms_wstring> keys = in_dict.keys();
        for(auto i : keys){
            auto filePath = fs::u8path(i);
            MSDict fileInfo;
            if( MS_FAILED ( rc = in_dict.val( i, fileInfo))){
                return rc;
            }
            // std::cout << StringUtils::toString(sPath) << std::endl;
            MSDict scanResult;

            ms_wstring startTime;
            if( MS_FAILED (rc = fileInfo.val(MS_KEY_SCAN_RES, scanResult)) ||
                MS_FAILED (rc = scanResult.val(MS_KEY_START_TIME, startTime)) ){
                return rc;
            }

            ms_dict_array threatArr;
            MSDict threats;
            if( MS_FAILED (rc = scanResult.val(MS_KEY_SCAN_DETAIL, threats))){
                return rc;
            }
            auto threatEngines = threats.keys();
            for(auto engineName : threatEngines){
                if(threats[engineName][MS_KEY_SCAN_RES_I].intVal() == 1){
                    threatArr.emplace_back(ms_dict_object{
							{ MS_KEY_NAME, threats[engineName][MS_KEY_THREAT_FOUND] },
							{ MS_KEY_ENGINE_NAME, engineName },
							{ MS_KEY_ENGINE_DEF_DATE, (int)StringUtils::utcTimeStrToTimet( StringUtils::toString(threats[engineName][MS_KEY_DEF_TIME].stringVal())) } 
                            });
                }
            } 
            dataReport.emplace_back(ms_dict_object {
					{ MS_KEY_NAME,  StringUtils::toWideString(filePath.filename().u8string()) },
					{ MS_KEY_PATH,  StringUtils::toWideString(filePath.u8string())},
					{ MS_KEY_TIME, startTime },
					{ MS_KEY_HASH, fileInfo[MS_KEY_FILE_INFO][MS_KEY_SHA_256] },
					{ MS_KEY_DATA_ID, fileInfo[MS_KEY_DATA_ID] },
					{ MS_KEY_THREATS, std::move(threatArr) } });

            if (dataReport.size() >= RESTRICTED_REPORT_AMOUNT) {
                break;
            } 
        }
        sotReportData = std::move(dataReport);
        return rc;

    }
    ms_rc getConclusion( const MSDict& result,FileScanConclusion& conclusion)
    {
        ms_rc rc = MS_OK;
        MSDict scanResult;
        int conclusion_i = -1;
        if(MS_SUCCESS ( rc = result.val(MS_KEY_SCAN_RES, scanResult)) &&
           MS_SUCCESS ( rc = scanResult.val(MS_KEY_SCAN_ALL_RES_I, conclusion_i))){
            conclusion = static_cast<FileScanConclusion>(conclusion_i);
            return rc;
        }
        return rc;

    }
    ms_rc isBlockedResult(const MSDict &result, ms_wstring& isBlock)
    {
        ms_rc rc = MS_OK;
        MSDict procInfo;
        if( MS_FAILED ( rc = result.val(MS_KEY_PROC_INFO, procInfo) ) ||
            MS_FAILED ( rc = procInfo.val(MS_KEY_RESULT, isBlock)) ){
                return rc;
        }
        return rc;
    }
}
}