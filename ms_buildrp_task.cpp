#include "ms_buildrp_task.h"
#include "ms_defines.h"
#include "3rdparty/msdict/ms_json.h"

#define RESTRICTED_REPORT_AMOUNT 100

namespace{
namespace Internal{
    ms_rc createSOTReportData( ms_dict_object in_dict, MSDict& sotReportData);
    ms_rc getConclusion( const MSDict& result,FileScanConclusion& conclusion);
    
    ms_rc isBlockedResult(const MSDict &result, ms_wstring& isBlock);
}
}

MalwareScanBuildRP::MalwareScanBuildRP()
{
}

MalwareScanBuildRP::~MalwareScanBuildRP()
{
}

ms_rc MalwareScanBuildRP::start(const MSDict &in_dict, MSDict &out_dict)
{
    return ms_rc();
}

MSDict MalwareScanBuildRP::onNewFileScanned( MSDict file_result)
{
    ms_wstring b;
    if ( MS_SUCCESS(Internal::isBlockedResult(file_result, b)) && b == MS_BLOCKED){
        std::cout << "Find "<< ++_totalBlockFile <<" block file" << std::endl;
        file_result.add( MS_KEY_RESULT, FileScanStatus::BlockedFile);
        onNewBlockResult(file_result);
    }
    else{
        std::cout << "Not a block file\n";
    }
}

ms_rc MalwareScanBuildRP::onNewBlockResult(MSDict file_result)
{
    ms_rc rc = MS_OK;
    FileScanConclusion conclusion;

    ms_wstring filePath;
    file_result.steal(MS_KEY_FILE_PATH, filePath);
    {
        std::lock_guard<std::mutex> lock(_mtx);
        if( MS_SUCCESS( rc = Internal::getConclusion(file_result, conclusion) ) &&
            conclusion == FileScanConclusion::PotentiallyVulnerableFile){
            _vulnarableResults[filePath] = file_result;
        }
        _blockedResults[filePath] = file_result;
    }
}

MSDict MalwareScanBuildRP::onScanFinished()
{
    filterIgnoredResults(); 
    buildAndSendScanReport();
}

ms_rc MalwareScanBuildRP::filterIgnoredResults()
{
    return ms_rc();
}

ms_rc MalwareScanBuildRP::buildAndSendScanReport()
{
    ms_rc rc = MS_OK;

    MSDict sotReportData;
    if(MS_FAILED( rc = createSOTReport(sotReportData))){
        return rc;
    }

    ms_wstring tmp;
    MSJson::serialize(sotReportData, tmp);

    return rc;
}

ms_rc MalwareScanBuildRP::createSOTReport(MSDict &sotReportData)
{
    ms_rc rc = MS_OK;

    sotReportData.add( MS_KEY_START_TIME,           static_cast<int>(startTime));
    sotReportData.add( MS_KEY_END_TIME,             static_cast<int>(endTime));
    // sotReportData.add( MS_KEY_TOTAL_VUL_FILE,       static_cast<int>(_vulnarableResults.keys().size()));
    sotReportData.add( MS_KEY_TOTAL_SCANNED_FILE,   totalScannedFile);
    // sotReportData.add( MS_KEY_TOTAL_INFECTED_FILE,  static_cast<int>(_blockedResults.keys().size()));

    // std::cout << _blockedResults.keys().size() << std::endl;

    if (!_blockedResults.empty())
    {
       MSDict blckData;
       if( MS_FAILED( rc = Internal::createSOTReportData(_blockedResults, blckData))){
            return rc;
       }
       ms_dict_object infectedSumary =  { {MS_KEY_DATA, blckData} } ;
        // if (isScanningAgainstMDCloudServer()) {
        //     joInfectedSumary["engine_detected"] = sumaryInfectedEngines(_joBlockedResults);
        // }
        sotReportData.add ( MS_KEY_INFECTED_FILES, infectedSumary );

    }
    if (!_ignoredResults.empty()) {
        MSDict ignoreData;
        if( MS_FAILED( rc = Internal::createSOTReportData(_ignoredResults, ignoreData))){
            return rc;
       }
        sotReportData.add ( MS_KEY_INFECTED_FILES, ignoreData );
    }

    return rc;
}

MSDict MalwareScanBuildRP::getSummaryData()
{
    ms_dict_object summaryData =  {
        // { MS_KEY_EXPLA_MSG,             explainationMsg },
        // { MS_KEY_COMPLETE_PERCENT,      completePercentage.get() },
        // { MS_KEY_START_TIME,            startTime },
        // { MS_KEY_END_TIME,              endTime },
        // { MS_KEY_TOTAL_SCANNED_FILE,    totalScannedFile },
        // { MS_KEY_TOTAL_ALLOWED_FILE,    totalAllowedFile },
        // { MS_KEY_PRCED_DATA_SIZE,       processedDataSize },
        // { MS_KEY_BATCH_ID,          batchID },
        // { MS_KEY_JOB_ID,            jobId }
    };
    return summaryData;
}

namespace{
namespace Internal{
    ms_rc createSOTReportData(ms_dict_object in_dict , MSDict& sotReportData)
    {
        ms_dict_object results = std::move(in_dict);
        // ms_wstring tmp;
        // MSJson::serialize(results, tmp);
        // std::cout << StringUtils::toString(tmp) << std::endl;
        ms_rc rc = MS_OK;
        ms_dict_array dataReport;
        for(std::pair<ms_wstring, MSDict> res : results){
            ms_wstring filePath = res.first;
            MSDict fileInfo = res.second;
            MSDict scanResult;

            ms_wstring startTime;
            if( MS_FAILED (rc = fileInfo.val(MS_KEY_SCAN_RES, scanResult)) &&
                MS_FAILED (rc = scanResult.val(MS_KEY_START_TIME, startTime)) ){
                return rc;
            }

            ms_dict_array threatArr;
            MSDict threats;
            if( MS_FAILED (rc = scanResult.val(MS_KEY_SCAN_DETAIL, threats))){
                return rc;
            }
            auto threatEngines = threats.keys();
            for(auto engineName : threatEngines){
                if(threats[engineName][MS_KEY_SCAN_RES_I].intVal() == 1){
                    threatArr.emplace_back(ms_dict_object{
							{ MS_KEY_NAME, threats[engineName][MS_KEY_THREAT_FOUND] },
							{ MS_KEY_ENGINE_NAME, engineName },
							{ MS_KEY_ENGINE_DEF_DATE, (int)StringUtils::utcTimeStrToTimet( StringUtils::toString(threats[engineName][MS_KEY_DEF_TIME].stringVal())) } 
                            });
                }
            } 
            dataReport.emplace_back(ms_dict_object {
					{ MS_KEY_NAME, filePath },
					{ MS_KEY_PATH, filePath},
					{ MS_KEY_TIME, startTime },
					{ MS_KEY_HASH, fileInfo[MS_KEY_FILE_INFO][MS_KEY_SHA_256] },
					{ MS_KEY_DATA_ID, fileInfo[MS_KEY_DATA_ID] },
					{ MS_KEY_THREATS, std::move(threatArr) } });

            if (dataReport.size() >= RESTRICTED_REPORT_AMOUNT) {
                break;
            } 
        }
        ms_wstring tmp;
        MSJson::serialize(dataReport, tmp);
        std::cout << StringUtils::toString(tmp) << std::endl;
        sotReportData = std::move(dataReport);
        return rc;

    }
    ms_rc getConclusion( const MSDict& result,FileScanConclusion& conclusion)
    {
        ms_rc rc = MS_OK;
        MSDict scanResult;
        int conclusion_i = -1;
        if(MS_SUCCESS ( rc = result.val(MS_KEY_SCAN_RES, scanResult)) &&
           MS_SUCCESS ( rc = scanResult.val(MS_KEY_SCAN_ALL_RES_I, conclusion_i))){
            conclusion = static_cast<FileScanConclusion>(conclusion_i);
            return rc;
        }
        return rc;

    }
    ms_rc isBlockedResult(const MSDict &result, ms_wstring& isBlock)
    {
        ms_rc rc = MS_OK;
        MSDict procInfo;
        if( MS_FAILED ( rc = result.val(MS_KEY_PROC_INFO, procInfo) ) ||
            MS_FAILED ( rc = procInfo.val(MS_KEY_RESULT, isBlock)) ){
                return rc;
        }
        return rc;
    }
}
}