#include "ms_buildrp_task.h"
#include "ms_logger.h"
#include "3rdparty/msdict/ms_json.h"

#include <experimental/filesystem>

#define RESTRICTED_REPORT_AMOUNT 100
namespace fs = std::experimental::filesystem;

namespace{
namespace Internal{
    ms_rc createSOTReportData( MSDict inDict, MSDict& sotReportData);
    ms_rc getConclusion( const MSDict& result,FileScanConclusion& conclusion);
    ms_rc getServerType( const MSDict& inDict, ms_int& serverType);
    ms_rc getEngineThreshold( const MSDict& inDict, ms_int& threshold);
    ms_bool isTrustedEngine( const MSDict& config, const ms_wstring& engineName);
}
}

MalwareScanBuildRP::~MalwareScanBuildRP()
{
}

ms_rc MalwareScanBuildRP::start(const MSDict &inDict, MSDict &outDict)
{
    return ms_rc();
}

MSDict MalwareScanBuildRP::onNewFileScanned( MSDict file_result)
{
    MS_LOGGER_INFO("[buildreport] Got new file scanned");
    MSDict fileInfo;
    ms_int fileSize;
    if( MS_FAILED ( file_result.val( MS_KEY_FILE_INFO, fileInfo )  ||
        MS_FAILED ( fileInfo.val(MS_KEY_FILE_SIZE, fileSize)))){
            MS_LOGGER_ERROR("[buildreport] can not get filesize");
    }
    // size_t fileSize = fileSizeStr == L"" ? 0 : std::stoull(fileSizeStr);

    // ms_wstring tmp;
    // MSJson::serialize(file_result, tmp);
    // std::cout << StringUtils::toString(tmp) << std::endl;

    ms_bool state;
    ms_rc rc = MS_OK;
    if( MS_SUCCESS( rc = isErrorResult(file_result, state)) && state ){
        MS_LOGGER_INFO("[buildreport] Got a SCAN ERROR file");
        file_result.add( MS_KEY_RESULT, FileScanStatus::ErrorFile);
        onErrorResult(file_result);
    }
    else if ( MS_SUCCESS( rc = isBlockedResult(file_result, state)) && state){
        // std::cout << "Find "<< ++_totalBlockFile <<" block file" << std::endl;
        MS_LOGGER_INFO("[buildreport] Got a BLOCKED file");
        file_result.add( MS_KEY_RESULT, FileScanStatus::BlockedFile);
        onNewBlockResult(file_result);
    }
    else{
        // std::cout << "Not a block file\n";
    }
    onNewFileProcessed(fileSize);
    return MS_OK;
}

ms_rc MalwareScanBuildRP::onNewBlockResult(MSDict file_result)
{
    ms_rc rc = MS_OK;
    FileScanConclusion conclusion;
    
    ms_wstring filePath;
    file_result.steal(MS_KEY_FILE_PATH, filePath);
    {
        std::lock_guard<std::mutex> lock(_mtx);
        if( MS_SUCCESS( rc = Internal::getConclusion(file_result, conclusion) ) &&
            conclusion == FileScanConclusion::PotentiallyVulnerableFile){
            _vulnarableResults.add(filePath, file_result);
        }
        _blockedResults.add(filePath, file_result);
    }
}
ms_rc MalwareScanBuildRP::onErrorResult(MSDict file_result)
{
    ms_rc rc = MS_OK;
    
    ms_wstring filePath;
    file_result.steal(MS_KEY_FILE_PATH, filePath);
    {
        std::lock_guard<std::mutex> lock(_mtx);
        _skippedResults.add(filePath, file_result);
    }
}

ms_rc MalwareScanBuildRP::onNewFileProcessed(const size_t& fileSize)
{
    {

        std::lock_guard<std::mutex> lock(_mtx);
        processedDataSize += fileSize;
        std::cout << "Processed " << totalScannedFile << std::endl;
        if( ++totalScannedFile == _totalTask){
            onScanFinished();
        }
    }
}

ms_rc MalwareScanBuildRP::onScanFinished()
{
    ms_rc rc = MS_OK;
    filterIgnoredResults(); 
    buildScanReport();
    _tellEngineToStop.set_value(1);
    return rc;
}

ms_rc MalwareScanBuildRP::filterIgnoredResults()
{
    return ms_rc();
}

ms_rc MalwareScanBuildRP::buildScanReport()
{
    ms_rc rc = MS_OK;

    endTime = std::time(nullptr);

    MSDict reportDict;
    if(MS_FAILED( rc = createSOTReport(_scanResult))){
        return rc;
    }

    // reportDict.add()


    ms_wstring tmp;
    MSJson::serialize(_scanResult, tmp);
    MS_LOGGER_INFO("[buildreport] processing {} bytes", processedDataSize);
    MS_LOGGER_INFO("[buildreport] build report successfully, report: {}",StringUtils::toString(tmp));
    return rc;
}

ms_rc MalwareScanBuildRP::createSOTReport(MSDict &sotReportData)
{
    ms_rc rc = MS_OK;
    sotReportData.become(MSDictType::OBJECT);

    if( MS_FAILED ( rc = sotReportData.add( MS_KEY_START_TIME,           static_cast<ms_int>(startTime)) ) ||
        MS_FAILED ( rc = sotReportData.add( MS_KEY_END_TIME,             static_cast<ms_int>(endTime)) ) ||
        MS_FAILED ( rc = sotReportData.add( MS_KEY_TOTAL_VUL_FILE,       static_cast<ms_int>(_vulnarableResults.size()))) ||
        MS_FAILED ( rc = sotReportData.add( MS_KEY_TOTAL_SCANNED_FILE,   totalScannedFile) ) ||
        MS_FAILED ( rc = sotReportData.add( MS_KEY_TOTAL_INFECTED_FILE,  static_cast<ms_int>(_blockedResults.size())) )){
            MS_LOGGER_ERROR("[buildreport] report data is not valid, rc: {}", rc);
            return rc;
    }
    

    if (_blockedResults.size() != 0)
    {
       MSDict blckData;
       if( MS_FAILED( rc = Internal::createSOTReportData(_blockedResults, blckData))){
            MS_LOGGER_ERROR("[buildreport] can not create block files data, rc: {}", rc);
            return rc;
       }
       ms_dict_object infectedSumary =  { {MS_KEY_DATA, blckData} } ;
        // if (isScanningAgainstMDCloudServer()) {
        //     joInfectedSumary["engine_detected"] = sumaryInfectedEngines(_joBlockedResults);
        // }
        sotReportData.add ( MS_KEY_INFECTED_FILES, infectedSumary );

    }
    if (_ignoredResults.size() != 0) {
        MSDict ignoreData;
        if( MS_FAILED( rc = Internal::createSOTReportData(_ignoredResults, ignoreData))){
            MS_LOGGER_ERROR("[buildreport] can not create ignored files data, rc: {}", rc);
            return rc;
       }
        sotReportData.add ( MS_KEY_IGNORED_FILES, ms_dict_object{{MS_KEY_DATA, ignoreData}} );
    }

    return rc;
}

void MalwareScanBuildRP::setTotalTask(ms_int srcTotalTask)
{
    _totalTask = srcTotalTask;
    MS_LOGGER_INFO("[buildreport] Get {} tasks need to handle", srcTotalTask);
    if(_totalTask == totalScannedFile){
        onScanFinished();
    }
}
MSDict MalwareScanBuildRP::getScanResult()
{
    return _scanResult;
}
ms_rc MalwareScanBuildRP::isBlockedResult(const MSDict &result, ms_bool &isBlock)
{
    ms_rc rc = MS_OK;
    MSDict procInfo;
    ms_wstring res;
    ms_int serverType;
    FileScanConclusion conclusion;
    if( MS_FAILED ( rc = result.val(MS_KEY_PROC_INFO, procInfo) )           ||
        MS_FAILED ( rc = procInfo.val(MS_KEY_RESULT, res))                  ||
        MS_FAILED ( rc = Internal::getConclusion(result, conclusion) )      ||
        MS_FAILED ( rc = Internal::getServerType(_pScanConfig, serverType) )){
        ms_wstring tmp;
        MSJson::serialize(result, tmp);
        MS_LOGGER_ERROR("[buildreport] file result is not valid, result:{} ,rc: {}", StringUtils::toString(tmp) ,rc);
        return rc;
    }
    isBlock = ( res == MS_BLOCKED);
    if( isBlock && serverType == 0 && conclusion < FileScanConclusion::LP_LocalProcessResultStart && conclusion != FileScanConclusion::Blacklisted){
        MSDict scanRes, scanDetails;
         if( MS_FAILED ( rc = result.val(MS_KEY_SCAN_RES, scanRes) )         ||
            MS_FAILED ( rc = scanRes.val(MS_KEY_SCAN_DETAIL, scanDetails))   ||
            !scanDetails.isObject()){
            MS_LOGGER_ERROR("[buildreport] can not get details of scan result");
            return rc;
        }
        ms_int infectedEngineCount = 0;
        for (auto i : scanDetails.keys()){
            if ( scanDetails[i][MS_KEY_SCAN_RES_I].intVal() == FileScanConclusion::Infected &&
                    Internal::isTrustedEngine(_pScanConfig,i) ){
                infectedEngineCount++;
            }
        }
        ms_int threshold = 0;
        if ( MS_SUCCESS( rc = Internal::getEngineThreshold(_pScanConfig,threshold)) &&
                infectedEngineCount < threshold){
            MS_LOGGER_INFO("[buildreport] Treat 1 file is not block due to infected engine count less than threshold, {} < {}", infectedEngineCount, threshold);
            isBlock = false;
        }
    }
    return rc;
}

ms_rc MalwareScanBuildRP::isErrorResult(const MSDict &result, ms_bool &isBlock)
{
    MSDict infectedErr;
    if( MS_FAILED (result.val(MS_KEY_INFECT_ERR, infectedErr ) ))
        return true;
    return false;
}

namespace{
namespace Internal{
    ms_rc createSOTReportData(MSDict inDict , MSDict& sotReportData)
    {
        ms_rc rc = MS_OK;
        ms_dict_array dataReport;
        std::set<ms_wstring> keys = inDict.keys();
        for(auto i : keys){
            auto filePath = fs::u8path(i);
            MSDict fileInfo;
            if( MS_FAILED ( rc = inDict.val( i, fileInfo))){
                return rc;
            }
            MSDict scanResult;

            ms_wstring startTime;
            if( MS_FAILED (rc = fileInfo.val(MS_KEY_SCAN_RES, scanResult)) ||
                MS_FAILED (rc = scanResult.val(MS_KEY_START_TIME, startTime)) ){
                return rc;
            }

            ms_dict_array threatArr;
            MSDict threats;
            if( MS_FAILED (rc = scanResult.val(MS_KEY_SCAN_DETAIL, threats))){
                return rc;
            }
            auto threatEngines = threats.keys();
            for(auto engineName : threatEngines){
                if(threats[engineName][MS_KEY_SCAN_RES_I].intVal() == 1){
                    threatArr.emplace_back(ms_dict_object{
							{ MS_KEY_NAME, threats[engineName][MS_KEY_THREAT_FOUND] },
							{ MS_KEY_ENGINE_NAME, engineName },
							{ MS_KEY_ENGINE_DEF_DATE, (ms_int)StringUtils::utcTimeStrToTimet( StringUtils::toString(threats[engineName][MS_KEY_DEF_TIME].stringVal())) } 
                            });
                }
            } 
            dataReport.emplace_back(ms_dict_object {
					{ MS_KEY_NAME,  StringUtils::toWideString(filePath.filename().u8string()) },
					{ MS_KEY_PATH,  StringUtils::toWideString(filePath.u8string())},
					{ MS_KEY_TIME, startTime },
					{ MS_KEY_HASH, fileInfo[MS_KEY_FILE_INFO][MS_KEY_SHA_256] },
					{ MS_KEY_DATA_ID, fileInfo[MS_KEY_DATA_ID] },
					{ MS_KEY_THREATS, std::move(threatArr) } });

            if (dataReport.size() >= RESTRICTED_REPORT_AMOUNT) {
                break;
            } 
        }
        sotReportData = std::move(dataReport);
        return rc;

    }
    ms_rc getConclusion( const MSDict& result,FileScanConclusion& conclusion)
    {
        ms_rc rc = MS_OK;
        MSDict scanResult;
        ms_int conclusion_i = -1;
        if(MS_SUCCESS ( rc = result.val(MS_KEY_SCAN_RES, scanResult)) &&
           MS_SUCCESS ( rc = scanResult.val(MS_KEY_SCAN_ALL_RES_I, conclusion_i))){
            conclusion = static_cast<FileScanConclusion>(conclusion_i);
            return rc;
        }
        return rc;

    }
    ms_rc getServerType(const MSDict &inDict, ms_int &serverType)
    {
        ms_rc rc = MS_OK;
        MSDict availScanner;
        if( MS_FAILED ( rc = inDict.val(MS_KEY_AVAIL_SCANNERS, availScanner))   ||
            !availScanner.isArray()                                             ||
            !availScanner.size()                                                ||
            MS_FAILED ( rc = availScanner[0].val(MS_KEY_TYPE, serverType))){
            return MS_ERROR_NON_EXISTENT_SCANNER;
        } 
        return rc;
    }
    ms_rc getEngineThreshold(const MSDict &inDict, ms_int &threshold)
    {
        ms_rc rc = MS_OK;
        MSDict availScanner,scanRule;
        if( MS_FAILED ( rc = inDict.val(MS_KEY_AVAIL_SCANNERS, availScanner))       ||
            !availScanner.isArray()                                                 ||
            !availScanner.size()                                                    ||
            MS_FAILED (rc = availScanner[0].val(MS_KEY_SCAN_RULE, scanRule) )  ||
            //MS core not use threshold??? Need to enhance
            MS_FAILED ( rc = scanRule.val(MS_KEY_ENGINE_THRESHOLD, threshold))){
            return MS_ERROR_NON_EXISTENT_SCANNER;
        } 
        return rc;
    }
    ms_bool isTrustedEngine(const MSDict& config, const ms_wstring &engineName)
    {
        MSDict availScanner, scanRule, includeEngines;
        if( MS_FAILED ( config.val(MS_KEY_AVAIL_SCANNERS, availScanner))        ||
            !availScanner.isArray()                                             ||
            !availScanner.size()                                                ||
            MS_FAILED ( availScanner[0].val(MS_KEY_SCAN_RULE, scanRule))        ||
            MS_FAILED ( scanRule.val(MS_KEY_INCLUDE_ENGINES, includeEngines) )  ||
            !includeEngines.isArray()){
            return false;
        } 
        for( ms_int i = 0 ; i < includeEngines.size() ; i++ ){
            if( engineName == includeEngines[i].stringVal()){
                return true;
            }
        }
        return false;

    }
}
}