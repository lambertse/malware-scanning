#include "cpr_utils.h"
#include "ms_logger.h"
#include "utils/string_utils.h"
namespace
{
namespace Internal
{
    ms_bool isStatusCode200s(const ms_int& code){
        return code / 100 == 2;
    }
    ms_bool isStatusCodeError(const ms_int& code){
        return code / 100 == 4 || code / 100 == 5;
    }
}
}

class GetAPIVersion : public BaseCprUtils
{
public:
    ms_bool ShouldRetrySpecific(){return false;}
    MSDict ShouldReportSpecificError(const cpr::Response& response) override
    {
        MSDict responseDict;
        ms_wstring version;
        MSJson::deserialize(StringUtils::toWideString(response.text), responseDict);

        if (response.text.empty()) {
            return CreateErrorDict(response.status_code, int(response.error.code), L"Empty response");
        }
        else if (!Internal::isStatusCode200s(response.status_code)) {
            auto errMsg =   "Error code: " + std::to_string(int(response.error.code)) 
                            + ". HTTP Code: " + std::to_string(response.status_code)
                            + ". Server response: " + response.text;
            MS_LOGGER_INFO(errMsg);
            return CreateErrorDict(response.status_code, int(response.error.code), L"Unable to reach the MetaDefender server");
		}
        else if (  MS_FAILED( responseDict.val(MS_KEY_VERSION, version) ) ) {
            return CreateErrorDict(response.status_code, int(response.error.code), L"Response is missing version field"); 
        } 
        else {
            return MSDict(MSDictType::NUL);
        }
    }
};

class CheckDataID   : public BaseCprUtils
{
public:
    ms_bool ShouldRetrySpecific(){return false;}
    MSDict ShouldReportSpecificError(const cpr::Response& response) override
    {
        MSDict responseDict;
        MSJson::deserialize(StringUtils::toWideString(response.text), responseDict);

        if (response.text.empty()) {
            return CreateErrorDict(response.status_code, int(response.error.code), L"Empty response");
        }
        else if (!Internal::isStatusCode200s(response.status_code)) {
            MSDict errorDict, errMsg;
            ms_wstring err;
            if( MS_SUCCESS(responseDict.val(MS_KEY_ERROR, errorDict)) &&
                MS_SUCCESS(errorDict.val(MS_KEY_MESSAGES, errMsg)     &&
                errMsg.isArray()) ){
                return CreateErrorDict(response.status_code, int(response.error.code), errMsg.size() == 0 ? L"Error messages empty" : errMsg[0].stringVal());
            }
            else if( MS_SUCCESS(responseDict.val(MS_KEY_ERR, err))){
                if( err == L"Access denied" && response.status_code == 405  )
                    return CreateErrorDict(response.status_code, int(response.error.code), L"The scan server returned an error: Invalid Apikey"); 
                return CreateErrorDict(response.status_code, int(response.error.code), err);
            }
            else {
                auto errMsg = "Error code: " + std::to_string(int(response.error.code)) 
                            + ". HTTP Code: " + std::to_string(response.status_code)
                            + ". Server response: " + response.text;
                MS_LOGGER_INFO(errMsg);
                return CreateErrorDict(response.status_code, int(response.error.code), L"Some errors occur. See details in log files");
            }
        }
        else
            return MSDict(MSDictType::NUL);
    }
};

class CheckAPIKey   : public BaseCprUtils
{
public:
    ms_bool ShouldRetrySpecific(){return false;}
    MSDict ShouldReportSpecificError(const cpr::Response& response) override{
        MSDict responseDict;
        MSJson::deserialize(StringUtils::toWideString(response.text), responseDict);

        if (response.text.empty()) {
            return CreateErrorDict(response.status_code, int(response.error.code), L"Empty response");
        }
        else if (!Internal::isStatusCode200s(response.status_code)) {
            MSDict errorDict, errMsg;
            ms_wstring err;
            if( MS_SUCCESS(responseDict.val(MS_KEY_ERROR, errorDict)) &&
                MS_SUCCESS(errorDict.val(MS_KEY_MESSAGES, errMsg)     && 
                errMsg.isArray()) ){
                return CreateErrorDict(response.status_code, int(response.error.code), errMsg.size() == 0 ? L"Error messages empty" : errMsg[0].stringVal());
            }
            else if ( MS_SUCCESS(responseDict.val(MS_KEY_ERR, err)) ) {
                return CreateErrorDict(response.status_code, int(response.error.code), L"The scan server returned an error: Invalid Apikey");
            }
            else {
                return CreateErrorDict(response.status_code, int(response.error.code), L"Response is missing field");
            }
        }
        else {
            return MSDict(MSDictType::NUL);
        }
    }
};

class CheckAPIKeyLimit   : public BaseCprUtils
{
public:
    ms_bool ShouldRetrySpecific(){return false;}
    MSDict ShouldReportSpecificError(const cpr::Response& response) override{
        MSDict responseDict;
        MSJson::deserialize(StringUtils::toWideString(response.text), responseDict);

        if (response.text.empty()) {
            return CreateErrorDict(response.status_code, int(response.error.code), L"Empty response");
        }
        else if (!Internal::isStatusCode200s(response.status_code)) {
            MSDict errorDict, errMsgDict;
            ms_int code;
            if (response.status_code == 429 && 
                MS_SUCCESS(responseDict.val(MS_KEY_ERROR, errorDict))   &&
                MS_SUCCESS(errorDict.val(MS_KEY_MESSAGES, errMsgDict))  &&
                MS_SUCCESS(errorDict.val(MS_KEY_CODE, code))            &&
                code == 429000                                          &&
                errMsgDict.isArray()) {
					return CreateErrorDict(response.status_code, int(response.error.code), errMsgDict.size() == 0 ? L"Error messages empty" : errMsgDict[0].stringVal());
				}
				else {
					auto errMsg =   "Error code: " + std::to_string(int(response.error.code)) 
                            + ". HTTP Code: " + std::to_string(response.status_code)
                            + ". Server response: " + response.text;
                    MS_LOGGER_INFO(errMsg);
                    return CreateErrorDict(response.status_code, int(response.error.code), L"Some errors occur. See details in log files");
				}
        }
        else {
            return MSDict(MSDictType::NUL);
        }
    }
};

class CheckHash   : public BaseCprUtils
{
public:
    ms_bool ShouldRetrySpecific(){return false;}
    MSDict ShouldReportSpecificError(const cpr::Response& response) override{
        MSDict responseDict;
        MSJson::deserialize(StringUtils::toWideString(response.text), responseDict);

        if (response.text.empty()) {
            return CreateErrorDict(response.status_code, int(response.error.code), L"Empty response");
        }
        else if (!Internal::isStatusCode200s(response.status_code)) {
            ms_wstring err;
            if (response.status_code == 404) {
                MSDict errorDict;
                ms_int code;
                if( MS_SUCCESS(responseDict.val(MS_KEY_ERROR, errorDict)) &&
                    MS_SUCCESS(errorDict.val(MS_KEY_CODE, code))           &&
                    code != 404003 /*hash not found*/ ){
                    MS_LOGGER_INFO("Hash error: {}. ErrCode: {}", response.text, (int)response.error.code);             
                }
                return MSDict(MSDictType::NUL); 
            }
            if (MS_SUCCESS(responseDict.val(MS_KEY_ERR, err)) &&
               (response.status_code == 403 || response.status_code == 405)) {
                return CreateErrorDict(response.status_code, int(response.error.code), L"The scan server returned an error: Invalid Apikey");
            }
            auto errMsg =   "Error code: " + std::to_string(int(response.error.code)) 
                            + ". HTTP Code: " + std::to_string(response.status_code)
                            + ". Server response: " + response.text;
            MS_LOGGER_INFO(errMsg);
            return CreateErrorDict(response.status_code, int(response.error.code), L"Some errors occur. See details in log files");
        }
        else {
            return MSDict(MSDictType::NUL);
        }
    }
};

class GetServerConnectionStatus : public BaseCprUtils
{
    ms_bool ShouldRetrySpecific(){return false;}
};

class UploadFileToServer : public BaseCprUtils
{
    ms_bool ShouldRetrySpecific(){return false;}
};