#ifndef __ms_dict__
#define __ms_dict__

#include "ms_types.h"
#include <set>
#include <unordered_map>
#include <memory>
#include <functional>

#ifdef _MSC_VER
#	pragma warning( push )
#	pragma warning( disable: 4251 )
#endif

enum class MSDictType 
{
	NUL, 
	NUMBER, 
	INTEGRAL,
	BOOL, 
	STRING,
	BYTES,
	ARRAY, 
	OBJECT,
	CALLABLE
};

class MSDict;
using ms_dict_array    = std::vector<MSDict>;
using ms_dict_object   = std::unordered_map<ms_wstring, MSDict>;
using ms_dict_keys     = std::set<ms_wstring>;
using ms_dict_callable = std::function<MSDict ( MSDict&& )>;

using ms_shared_dict   = std::shared_ptr<MSDict>;
using ms_weak_dict     = std::weak_ptr<MSDict>;
using ms_unique_dict   = std::unique_ptr<MSDict>;

class _MSDicVal;
class MSDictStepper;

class MSDict final
{
public:	
	MSDict() noexcept;
	MSDict( MSDictType type ) noexcept;
	MSDict( void* ) = delete;
	MSDict( std::nullptr_t ) noexcept;
	MSDict( int32_t val );
	MSDict( double val );	
	MSDict( bool val );
	MSDict( const ms_wstring& val );
	MSDict( const ms_wchar* val );
	MSDict( ms_wstring&& val );
	
	MSDict( const ms_bytes& val );
	MSDict( ms_bytes&& val );	

	MSDict( const ms_dict_array& vals );
	MSDict( ms_dict_array&& vals );

	MSDict( const ms_dict_object& vals );
	MSDict( ms_dict_object&& vals );

	MSDict( const MSDict& val );
	MSDict( MSDict&& val );

	MSDict( const ms_dict_callable& val );

	~MSDict() = default;

	MSDict& operator=( const MSDict& other );
	MSDict& operator=( MSDict&& other );

	MSDict& operator=( std::nullptr_t );
	MSDict& operator=( void* ) = delete;
	MSDict& operator=( int32_t val );
	MSDict& operator=( double val );	
	MSDict& operator=( bool val );
	MSDict& operator=( const ms_wstring& val );	
	MSDict& operator=( ms_wstring&& val );
	MSDict& operator=( const ms_wchar* val );
	MSDict& operator=( const ms_bytes& val );
	MSDict& operator=( ms_bytes&& val );	

	MSDict& operator=( const ms_dict_object& other );
	MSDict& operator=( ms_dict_object&& other );

	MSDict& operator=( const ms_dict_array& other );
	MSDict& operator=( ms_dict_array&& other );

	MSDict& operator=( const ms_dict_callable& other );

	MSDictType type() const;
	bool isType( const MSDictType type ) const;
	
	bool isNull()		const;
	bool isNumber() 	const;
	bool isIntegral()	const;
	bool isString()		const;
	bool isBytes()		const;
	bool isArray()		const;
	bool isObject() 	const;
	bool isCallable() 	const;

	ms_rc val( int32_t& val ) const;
	ms_rc val( double& val ) const;	
	ms_rc val( bool& val ) const;
	ms_rc val( ms_wstring& val ) const;
	ms_rc val( ms_bytes& val ) const;

	ms_rc steal( int32_t& val );
	ms_rc steal( double& val );	
	ms_rc steal( bool& val );
	ms_rc steal( ms_wstring& val );
	ms_rc steal( ms_bytes& val );

	ms_rc val( const ms_wstring& key, MSDict& val ) const; 		// copy to val
	ms_rc val( const ms_wstring& key, int32_t& val ) const;
	ms_rc val( const ms_wstring& key, double& val ) const;			
	ms_rc val( const ms_wstring& key, bool& val ) const;
	ms_rc val( const ms_wstring& key, ms_wstring& val ) const;	
	ms_rc val( const ms_wstring& key, ms_bytes& val ) const;		

	/* apply dot syntax to copy data out*/
	ms_rc dotVal( const ms_wstring& key_list, MSDict& val ) const;
	ms_rc dotVal( const ms_wstring& key_list, int32_t& val ) const;
	ms_rc dotVal( const ms_wstring& key_list, double& val ) const;			
	ms_rc dotVal( const ms_wstring& key_list, bool& val ) const;
	ms_rc dotVal( const ms_wstring& key_list, ms_wstring& val ) const;
	ms_rc dotVal( const ms_wstring& key_list, ms_bytes& val ) const;

	/* steal data from value of key - not applicable for const object*/
	ms_rc steal( const ms_wstring& key, MSDict& val );		
	ms_rc steal( const ms_wstring& key, int32_t& val );	
	ms_rc steal( const ms_wstring& key, double& val );			
	ms_rc steal( const ms_wstring& key, bool& val );
	ms_rc steal( const ms_wstring& key, ms_wstring& val );		
	ms_rc steal( const ms_wstring& key, ms_bytes& val );			

	/* apply dot syntax to steal data out - not applicable for const object*/
	ms_rc dotSteal( const ms_wstring& key_list, MSDict& val );		
	ms_rc dotSteal( const ms_wstring& key_list, int32_t& val );
	ms_rc dotSteal( const ms_wstring& key_list, double& val );			
	ms_rc dotSteal( const ms_wstring& key_list, bool& val );
	ms_rc dotSteal( const ms_wstring& key_list, ms_wstring& val );	
	ms_rc dotSteal( const ms_wstring& key_list, ms_bytes& val );		

	ms_rc val( const size_t idx, MSDict& val ) const;				// copy to val
	ms_rc val( const size_t idx, int32_t& val ) const;
	ms_rc val( const size_t idx, double& val ) const;	
	ms_rc val( const size_t idx, bool& val ) const;
	ms_rc val( const size_t idx, ms_wstring& val ) const;
	ms_rc val( const size_t idx, ms_bytes& val ) const;

	/* steal data from value of key*/
	ms_rc steal( const size_t idx, MSDict& val );				// unapplicable for const object
	ms_rc steal( const size_t idx, int32_t& val );
	ms_rc steal( const size_t idx, double& val );	
	ms_rc steal( const size_t idx, bool& val );
	ms_rc steal( const size_t idx, ms_wstring& val );			// unapplicable for const object
	ms_rc steal( const size_t idx, ms_bytes& val );			// unapplicable for const object

	/* appicale for callable object*/
	ms_rc call( MSDict&& in_val, MSDict& out_val ) const;
	MSDict operator()( MSDict&& val ) const;	

	double		numberVal() const;
	int32_t		intVal()	const;
	bool		boolVal()	const;
	ms_wstring	stringVal() const;
	ms_bytes	bytesVal()	const;	

	size_t size() const;
	const MSDict& operator[]( const size_t idx ) const;
	MSDict& operator[]( const size_t idx );

	const MSDict& operator[]( const ms_wstring& key ) const;
	MSDict& operator[]( const ms_wstring& key );		

	ms_rc add( const MSDict& val );
	ms_rc add( MSDict&& val );
	ms_rc add( const ms_wstring& key, const MSDict& val );
	ms_rc add( const ms_wstring& key, MSDict&& val );

	void clear();	// remove the internal data only, not reset to null
	ms_rc remove( const size_t idx );
	ms_rc remove( const ms_wstring& key );

	ms_rc contain( const ms_wstring& key_list ) const;
	ms_rc contain( const ms_wstring& key_list, const MSDictType type ) const;

	ms_dict_keys keys() const;
	void become( MSDictType type );		// drop internal data and turn to new empty type
	void drop();							// drop internal data and turn to null
    ms_rc step( std::shared_ptr<MSDictStepper> stepper ) const;

private:
	MSDict( std::shared_ptr<_MSDicVal> other ): m_val( other ){}
	void _set( const MSDict& val );
	void _set( MSDict&& val );

private:
	std::shared_ptr<_MSDicVal> m_val;	
	friend class _MSDot;	
};

#ifdef _MSC_VER
#	pragma warning( pop )
#endif

#endif
