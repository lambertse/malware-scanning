#ifndef __ms_slot_h__
#define __ms_slot_h__

#include <thread>
#include <condition_variable>
#include <mutex>
#include <unordered_set>
#include "utils/string_utils.h"
#include <iostream>
#include "ms_logger.h"
#include "ms_labels.h"
#include "ms_defines.h"

using ms_ll = size_t;

class Slot {
public:
    Slot(ms_ll srcLimitSize, ms_int srcMaxThr) : _limitTotalSize(srcLimitSize), 
                                              _currentProcessingSize(0),
                                              _currentProcessingThread(0),
                                              _maxProcessingThread(srcMaxThr){}

    void waitUntilSlotAvailable(ms_ll fileSize){
        std::unique_lock<std::mutex> lock(_slotMtx);
        _slotCv.wait(lock, [this] { return _currentProcessingSize < _limitTotalSize && _currentProcessingThread < _maxProcessingThread; });
        _currentProcessingSize += fileSize;
        _currentProcessingThread++;
        // MS_LOGGER_INFO("{} Get 1 task, current processing size: {}, current processing thread: {}", MS_LABEL_SLOT, _currentProcessingSize, _currentProcessingThread);
    }
    void finishATask(ms_ll fileSize){
        std::unique_lock<std::mutex> lock(_slotMtx);
        _currentProcessingSize -= fileSize;
        _currentProcessingThread--;
        // MS_LOGGER_INFO("{} Release 1 task, current processing size: {}, current processing thread: {}", MS_LABEL_SLOT, _currentProcessingSize, _currentProcessingThread);
        _slotCv.notify_all();
    }
    ms_int getCurProcessingThread(){
        return _currentProcessingThread;
    }
    ms_int getCurProcessingSize(){
        return _currentProcessingSize;
    }
private:
    std::mutex _slotMtx;
    std::condition_variable _slotCv;

    ms_ll _limitTotalSize;
    ms_ll _currentProcessingSize;

    ms_int _currentProcessingThread;
    ms_int _maxProcessingThread;
};

#endif