#ifndef __ms_layer_h__
#define __ms_layer_h__

#include "ms_return_codes.h"
#include "ms_layers_abstract.h"
#include "ms_defines.h"
#include "ms_slot.h"
#include <cpr/cpr.h>
#include "utils/string_utils.h"
#include "utils/file_utils.h"
#include "3rdparty/msdict/ms_json.h"

#include "ms_localdb_manager.h"
#include <iostream>
#include <thread>
#include <fstream>
#include <chrono>

// #ifndef _WIN32
//     #include <axz_scu_file.h>
// #endif
using namespace std::chrono_literals;

namespace
{
namespace Internal{
    enum RquestType{GET, POST};

    cpr::Header headerDictToCprHeader(const MSDict& reqHeader);

    ms_rc requestAPI(ms_wstring file_path, const MSDict& reqHeader, std::string reqUrl, MSDict& responseDict, RquestType t);
    ms_rc getScanServer(const MSDict& in_dict, ms_wstring& url);

    MSDict createErrorDict(const MSDict &errorDict);
}
};

class VerifyFile             final : public MalwareScanLayer
{
public:
    VerifyFile() {}

    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {         
        ms_rc rc = MS_OK;

        ms_wstring filePath;
        in_dict.val(MS_KEY_FILE_PATH, filePath);
        size_t file_size;
        FileUtils::fileSize(filePath, file_size);

        if(file_size == 0){
            Internal::createErrorDict( ms_dict_object{ {MS_KEY_ERROR_MSG, L"Empty file!"}} );
            std::cout << "Catch an empty file!" << std::endl;
            return MS_ERROR_EMPTY_FILE;
        }

        MSDict param = std::move(in_dict);
        param.add( MS_KEY_FILE_SIZE, std::to_wstring(file_size));

        return MalwareScanLayer::start(param, out_dict);
    }
};

class ManifestLayer             final : public MalwareScanLayer
{
public:
    ManifestLayer() {}

    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        //not implement for sot 
        return MalwareScanLayer::start(in_dict, out_dict);
    }
};

class CDRLayer                  final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        //not implement for sot
        return MalwareScanLayer::start(in_dict, out_dict);
    }
};

class CaculateHashLayer         final : public MalwareScanLayer
{
private: 
    std::shared_ptr<Slot> _calculateHashSlot;
public:
    CaculateHashLayer(ms_ll _limitTotalSize){
        _calculateHashSlot = std::make_shared<Slot>(_limitTotalSize, MS_THREAD_COUNT);
    } 
    CaculateHashLayer(const std::shared_ptr<Slot>& srcSlot) : _calculateHashSlot(srcSlot){}
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;

        ms_wstring filePath, fileSizeStr, sha256;
        if( MS_FAILED ( rc = in_dict.val(MS_KEY_FILE_PATH, filePath) ) ||
            MS_FAILED ( rc = in_dict.val(MS_KEY_FILE_SIZE, fileSizeStr) )){
            return rc;
        }
        size_t file_size = std::stoull(fileSizeStr);
        
        _calculateHashSlot->waitUntilSlotAvailable(file_size);
        std::ifstream is = FileUtils::getContent(filePath, rc);
        rc = FileUtils::calculateHash(is, sha256);
        _calculateHashSlot->finishATask(file_size);

        if ( MS_FAILED (rc)){
            out_dict = Internal::createErrorDict( ms_dict_object{{ MS_KEY_ERROR_MSG, L"Can not calculate hash!"}} );
            return rc;
        }

        MSDict param = std::move(in_dict);
        param.add(MS_KEY_HASH, sha256);
        return MalwareScanLayer::start(param, out_dict);
    }
};

class LocalHashLayer            final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;

        ms_wstring file_path, sha256;
        if ( MS_FAILED ( rc = in_dict.val(MS_KEY_FILE_PATH, file_path) ) ||
             MS_FAILED ( rc = in_dict.val(MS_KEY_HASH, sha256) )){
            return rc;
        }

        ms_wstring result;
        if( MS_SUCCESS(LocalDatabaseManager::instance()->queryLocalResult(sha256, result)) ){
            // std::cout << "Get a file from local DB" << std::endl;
            MSJson::deserialize(result, out_dict);
            out_dict.add(MS_KEY_FILE_PATH, file_path);
            return MS_OK;
        }
        return MalwareScanLayer::start(std::move(in_dict), out_dict);
    }
};

class ServerHashLayer           final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;

        ms_wstring filePath, sha256, scnServer, responseStr;
        MSDict reqHeader;
        if ( MS_FAILED ( rc = in_dict.val(MS_KEY_FILE_PATH, filePath)) ||
             MS_FAILED ( rc = in_dict.val(MS_KEY_HASH, sha256) )        ||
             MS_FAILED ( rc = in_dict.val(MS_KEY_REQUEST_HEADER, reqHeader) )||
             MS_FAILED ( rc = Internal::getScanServer(in_dict, scnServer)) ){
            return rc;
        }

        std::string reqUrl = StringUtils::toString( scnServer + MS_HASH_POST_FIX + sha256);
        
        MSDict responseDict, errorDict;
        if( MS_FAILED ( rc = Internal::requestAPI(filePath, reqHeader, reqUrl, responseDict, Internal::RquestType::GET) )){
            out_dict = Internal::createErrorDict( ms_dict_object{{MS_KEY_ERROR_MSG, L"Send check hash request failed!" }} );
            return MS_ERROR_SEND_REQUEST_TO_SERVER;
        }

        int errorCode = -1;

        if ( MS_FAILED( responseDict.val(MS_KEY_ERROR, errorDict)) ||
             MS_FAILED( errorDict.val(MS_KEY_ERROR, errorCode)) ){
            if( MS_FAILED( MSJson::serialize(responseDict, responseStr)) ||
                MS_FAILED (LocalDatabaseManager::instance()->saveLocalResult(sha256, responseStr,1))){
                std::cout << "Save " << StringUtils::toString(sha256) << " on local failed!" << std::endl;
            }
            out_dict = std::move(responseDict);   
            out_dict.add(MS_KEY_FILE_PATH, filePath);
            return MS_OK;
        }
        return MalwareScanLayer::start(std::move(in_dict), out_dict);
    }
};

class UploadFileLayer           final : public MalwareScanLayer
{
private: 
    std::shared_ptr<Slot> _uploadFileSlot;
    std::shared_ptr<Slot> _readingSlot;
public:
    UploadFileLayer(ms_ll _limitTotalSize, const std::shared_ptr<Slot>& _srcSlot) : _readingSlot(_srcSlot){
        _uploadFileSlot = std::make_shared<Slot>(_limitTotalSize, MS_MAX_ALLOWED_UPLOAD_THREAD);
    } 

    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;

        ms_wstring filePath, sha256, fileSizeStr, scnServer;
        MSDict reqHeader;
        if ( MS_FAILED ( rc = in_dict.val(MS_KEY_FILE_PATH, filePath) )         ||
             MS_FAILED ( rc = in_dict.val(MS_KEY_HASH, sha256) )                ||
             MS_FAILED ( rc = in_dict.val(MS_KEY_FILE_SIZE, fileSizeStr))        ||
             MS_FAILED ( rc = in_dict.val(MS_KEY_REQUEST_HEADER, reqHeader) )  ||
             MS_FAILED ( rc = Internal::getScanServer(in_dict, scnServer) )){
            return rc;
        }
        size_t fileSize = std::stoull(fileSizeStr);

        std::string reqUrl = StringUtils::toString( scnServer + MS_FILE_POST_FIX);
        MSDict responseDict, errorDict;
        {
            _readingSlot->waitUntilSlotAvailable(fileSize);
            _uploadFileSlot->waitUntilSlotAvailable(fileSize);
            rc = Internal::requestAPI(filePath, reqHeader, reqUrl, responseDict, Internal::RquestType::POST);
            _uploadFileSlot->finishATask(fileSize);
            _readingSlot->finishATask(fileSize);
        }

        if( MS_FAILED (rc)){
            out_dict = Internal::createErrorDict( ms_dict_object{{MS_KEY_ERROR_MSG, L"Upload file failed!" }} );
            return MS_ERROR_SEND_REQUEST_TO_SERVER;
        }
    
        int errorCode = -1;      

        if ( MS_FAILED ( responseDict.val(MS_KEY_ERROR, errorDict)) ||
             MS_FAILED ( errorDict.val(MS_KEY_CODE, errorCode))){
            MSDict param = std::move(in_dict);
            param.add(MS_KEY_UPLOAD_RESPONSE, responseDict);
            return MalwareScanLayer::start(param, out_dict);
        }
        out_dict = Internal::createErrorDict(ms_dict_object{
            { MS_KEY_ERROR_MSG, L"Upload file failed!"},
            { MS_KEY_ERROR_DICT, std::move(errorDict)}
        });
        return MS_ERROR_UPLOAD_FAILED;

    }
};

class QueryResultLayer          final : public MalwareScanLayer{
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;
        auto startProcessingTime = std::time(nullptr);

        ms_wstring filePath, dataId, scnServer;
        MSDict scanFileResults, uploadResponseDict, reqHeader;

        if( MS_FAILED ( rc = in_dict.val(MS_KEY_FILE_PATH, filePath))                 ||
            MS_FAILED ( rc = in_dict.val(MS_KEY_UPLOAD_RESPONSE, uploadResponseDict) )||
            MS_FAILED ( rc = uploadResponseDict.val(MS_KEY_DATA_ID, dataId))          ||
            MS_FAILED ( rc = in_dict.val(MS_KEY_REQUEST_HEADER, reqHeader))            ||
            MS_FAILED ( rc = Internal::getScanServer(in_dict, scnServer))){   
            return rc;
        }

        std::chrono::nanoseconds recheckResultWait = MS_QUERY_TIME;
        while (true) {
            std::string reqUrl = StringUtils::toString( scnServer + MS_FILE_POST_FIX + dataId);
            if(MS_FAILED ( rc = Internal::requestAPI(filePath, reqHeader, reqUrl, scanFileResults, Internal::RquestType::GET))){
                break;
            }

            MSDict infectErrDict;
            if ( MS_SUCCESS ( rc = scanFileResults.val(MS_KEY_INFECT_ERR, infectErrDict))){
                break;
            }

            ms_wstring dataIdKey;
            if( MS_SUCCESS ( scanFileResults.val( dataId, dataIdKey) ) && 
                dataIdKey == L"Not Found" ){
                std::cout << "Not found in db" << std::endl;
            }

            auto progressPercentage =
                scanFileResults[L"scan_results"][L"progress_percentage"].intVal();

            if (progressPercentage >= 100.0) {
                ms_wstring fileHash = scanFileResults[L"file_info"][L"sha256"].stringVal();

                ms_wstring scanResultStr;
                if ( MS_FAILED ( rc = MSJson::serialize(scanFileResults, scanResultStr))){
                    return rc;
                }   
                // 3 - Failed, 10 - Not Scanned, 19 - Cancelled
                std::set<int> failedCodes = {3, 10, 19};
                int conclusion =
                    scanFileResults[L"scan_results"][L"scan_all_result_i"].intVal();
                if (failedCodes.find(conclusion) == failedCodes.end() && 
                    MS_SUCCESS ( LocalDatabaseManager::instance()->saveLocalResult(fileHash, scanResultStr, 1) )) {
                    out_dict = scanFileResults;
                    out_dict.add(MS_KEY_FILE_PATH, filePath);
                    // std::cout << "Save result by " << StringUtils::toString(scanResultStr) << std::endl;
                }
                break;
            }
            recheckResultWait *= 2;
            if (recheckResultWait > 2s) recheckResultWait = 2s;

            std::this_thread::sleep_for(recheckResultWait);
        }
        scanFileResults.add( MS_KEY_FILE_PATH,  filePath );
        scanFileResults.add( MS_KEY_ST_PROC_TIME,  static_cast<int>(startProcessingTime) );
        scanFileResults.add( MS_KEY_END_PROC_TIME,  static_cast<int>(std::time(nullptr)));

        out_dict = std::move(scanFileResults);
        return rc;
    }
};

class ExternalLayer             final : public MalwareScanLayer{
public:
    ExternalLayer() {}

    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        //implement later
        return MalwareScanLayer::start(in_dict, out_dict);
    }
};
namespace{
    namespace Internal{
        cpr::Header headerDictToCprHeader(const MSDict &reqHeader)
        {
            cpr::Header header;
            if( !reqHeader.isObject() ){
                return header;
            }
            std::wstring tmp;
            MSJson::serialize(reqHeader, tmp);
            for( auto i : reqHeader.keys()){
                ms_wstring value;
                reqHeader.val(i, value);
                header[StringUtils::toString(i)] = StringUtils::toString(value);
            }

            return header;
        }

        ms_rc requestAPI(ms_wstring file_path, const MSDict& reqHeader, std::string reqUrl, MSDict& responseDict, RquestType t)
        {
            ms_rc rc = MS_OK;

            cpr::Header headers = headerDictToCprHeader(reqHeader);
            cpr::Response response;
            if(t == GET) {
                response = cpr::Get(cpr::Url{reqUrl}, cpr::Header{headers});
            }else if(t == POST){
                response = cpr::Post(cpr::Url{reqUrl}, cpr::Header{headers},  cpr::Multipart{{"part-name", cpr::File{StringUtils::toString(file_path)}}});
            }
            if ( MS_FAILED( rc = MSJson::deserialize( StringUtils::toWideString(response.text), responseDict))){
                return rc;
            }
            // std::cout << response.text << std::endl; 

            return rc;
        }

        ms_rc getScanServer(const MSDict &in_dict, ms_wstring &url)
        {
            ms_rc rc = MS_OK;
            MSDict config,availScanner;
            if( MS_FAILED ( rc = in_dict.val(MS_KEY_CONFIG, config))                ||
                MS_FAILED ( rc = config.val(MS_KEY_AVAIL_SCANNERS, availScanner))   ||
                !availScanner.isArray()                                             ||
                !availScanner.size()                                                ||
                MS_FAILED ( rc = availScanner[0].val(MS_KEY_URL, url))){
                return MS_ERROR_NON_EXISTENT_SCANNER;
            } 
            return rc;
        }
        MSDict createErrorDict(const MSDict &errorDict)
        {
            return ms_dict_object{ 
                { MS_KEY_INFECT_ERR, std::move(errorDict)} };
        }
    }
}
#endif