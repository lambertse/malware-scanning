#ifndef __ms_layer_h__
#define __ms_layer_h__

#include "ms_return_codes.h"
#include "ms_layers_abstract.h"
#include "ms_defines.h"
#include "ms_slot.h"
#include "3rdparty/ezcurl/EzCurl.h"
#include "utils/string_utils.h"
#include "utils/file_utils.h"
#include "3rdparty/msdict/ms_json.h"

#include "ms_localdb_manager.h"
#include <iostream>
#include <thread>
#include <fstream>
#include <chrono>

// #ifndef _WIN32
//     #include <axz_scu_file.h>
// #endif
using namespace Curl;
using namespace std::chrono_literals;

namespace
{
namespace Internal{
    enum type{GET, POST};
    ms_rc requestAPI(ms_wstring file_path, std::string reqUrl, std::ifstream& reqBody, std::stringstream& responseBody, type t);
    ms_rc getScanConfig(MSDict &dscnConfig); 
    ms_rc buildHeader(headers_t &header, const ms_wstring &file_path);
    ms_rc checkDataId(const ms_wstring& dataId, MSDict& result);
}
};

class VerifyFile             final : public MalwareScanLayer
{
public:
    VerifyFile() {}

    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        //not implement for sot         
        ms_rc rc = MS_OK;
        ms_wstring filePath;
        in_dict.val(MS_KEY_FILE_PATH, filePath);
        size_t file_size;
        FileUtils::fileSize(filePath, file_size);

        if(file_size == 0){
            std::cout << "Catch an empty file!" << std::endl;
            return MS_ERROR_ABORTED;
        }

        MSDict param = std::move(in_dict);
        param.add( MS_KEY_FILE_SIZE, std::to_wstring(file_size));
        return MalwareScanLayer::start(param, out_dict);
    }
};

class ManifestLayer             final : public MalwareScanLayer
{
public:
    ManifestLayer() {}

    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        //not implement for sot 
        return MalwareScanLayer::start(in_dict, out_dict);
    }
};

class CDRLayer                  final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        //not implement for sot
        return MalwareScanLayer::start(in_dict, out_dict);
    }
};

class CaculateHashLayer         final : public MalwareScanLayer
{
private: 
    std::shared_ptr<Slot> _calculateHashSlot;
public:
    CaculateHashLayer(ms_ll _limitTotalSize){
        _calculateHashSlot = std::make_shared<Slot>(_limitTotalSize, MS_THREAD_COUNT);
    } 
    CaculateHashLayer(const std::shared_ptr<Slot>& srcSlot) : _calculateHashSlot(srcSlot){}
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;
        ms_wstring filePath;
        in_dict.val(MS_KEY_FILE_PATH, filePath);
        ms_wstring fileSizeStr;
        in_dict.val(MS_KEY_FILE_SIZE, fileSizeStr);
        size_t file_size = std::stoull(fileSizeStr);
        // file_path = L"/home/trile/Documents/test.sh";

        ms_wstring sha256;
        _calculateHashSlot->waitUntilSlotAvailable(file_size, filePath);
        std::ifstream is = FileUtils::getContent(filePath, rc);
        FileUtils::calculateHash(is, sha256);
        _calculateHashSlot->finishATask(file_size, filePath);

        MSDict param = std::move(in_dict);
        param.add(MS_KEY_HASH, sha256);

        return MalwareScanLayer::start(param, out_dict);
    }
};

class LocalHashLayer            final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;
        ms_wstring file_path;
        in_dict.val(MS_KEY_FILE_PATH, file_path);
        
        ms_wstring sha256;
        in_dict.val(MS_KEY_HASH, sha256);

        ms_wstring result;
        if( MS_SUCCESS(LocalDatabaseManager::instance()->queryLocalResult(sha256, result)) ){
            // std::cout << "Get a file from local DB" << std::endl;
            MSJson::deserialize(result, out_dict);
            out_dict.add(MS_KEY_FILE_PATH, file_path);
            return MS_OK;
        }
        return MalwareScanLayer::start(std::move(in_dict), out_dict);
    }
};

class ServerHashLayer           final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        
        ms_wstring file_path;
        in_dict.val(MS_KEY_FILE_PATH, file_path);
        ms_wstring sha256;
        in_dict.val(MS_KEY_HASH, sha256);

        std::ifstream requestBody;
        std::stringstream responseBody;
        std::string server = "https://api.metadefender.com:443/v4/hash/";
        // auto requestType = CurlRetry::CallOrigin::hash;
        std::string reqUrl = server + StringUtils::toString(sha256);

        if(MS_FAILED ( Internal::requestAPI(file_path, reqUrl, requestBody, responseBody, Internal::type::GET) )){
            std::cout << "send APT request failed!" << std::endl;
            return MS_ERROR_ABORTED;
        }

        MSDict responseDict;
        if (  MS_FAILED(MSJson::deserialize( StringUtils::toWideString(responseBody.str()), responseDict))){
            return MS_ERROR_RANGE_JSON;
        }
        MSDict errorDict;        
        int errorCode;

        if( MS_SUCCESS( responseDict.val(MS_KEY_ERROR, errorDict)) && MS_SUCCESS(errorDict.val(MS_KEY_CODE, errorCode))){
            switch (errorCode)
            {
            case 404003:
                return MalwareScanLayer::start(in_dict, out_dict);
                break;
            default:
                break;
            }
        }

        out_dict = responseDict;   
        out_dict.add(MS_KEY_FILE_PATH, file_path);
        if( MS_SUCCESS (LocalDatabaseManager::instance()->saveLocalResult(sha256, StringUtils::toWideString(responseBody.str()),1))){
            // std::cout << "Save " << StringUtils::toString(sha256) << " on local db" << std::endl;
        }
        return MS_OK;
    }
};

class UploadFileLayer           final : public MalwareScanLayer
{
private: 
    std::shared_ptr<Slot> _uploadFileSlot;
    std::shared_ptr<Slot> _readingSlot;
public:
    UploadFileLayer(ms_ll _limitTotalSize, const std::shared_ptr<Slot>& _srcSlot) : _readingSlot(_srcSlot){
        _uploadFileSlot = std::make_shared<Slot>(_limitTotalSize, MS_MAX_ALLOWED_UPLOAD_THREAD);
    } 

    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;
        ms_wstring filePath;
        in_dict.val(MS_KEY_FILE_PATH, filePath);
        ms_wstring sha256;
        in_dict.val(MS_KEY_HASH, sha256);

        ms_wstring fileSizeStr;
        in_dict.val(MS_KEY_FILE_SIZE, fileSizeStr);
        size_t fileSize = std::stoull(fileSizeStr);

        std::stringstream responseBody;
        std::string reqUrl = "https://api.metadefender.com:443/v4/file";
        // auto requestType = CurlRetry::CallOrigin::hash;
        std::ifstream body = FileUtils::getContent(filePath, rc);
        
        _readingSlot->waitUntilSlotAvailable(fileSize, filePath);
        _uploadFileSlot->waitUntilSlotAvailable(fileSize, filePath);
        if( MS_FAILED ( Internal::requestAPI(filePath, reqUrl, body, responseBody, Internal::type::POST) ) ){
            std::cout << "send API request failed!" << std::endl;
            return MS_ERROR_ABORTED;
        }
        _uploadFileSlot->finishATask(fileSize, filePath);
        _readingSlot->finishATask(fileSize, filePath);
        
        MSDict responseDict;
        if (  MS_FAILED(MSJson::deserialize( StringUtils::toWideString(responseBody.str()), responseDict))){
            return MS_ERROR_RANGE_JSON;
        }
        MSDict errorDict;        
        int errorCode;

        if( MS_SUCCESS( responseDict.val(MS_KEY_ERROR, errorDict)) && MS_SUCCESS(errorDict.val(MS_KEY_CODE, errorCode))){
            std::cout << "Upload file meets error: " << errorCode << std::endl;
            return MS_ERROR_ABORTED;
        }

        // out_dict = responseDict;
        MSDict param = std::move(in_dict);
        param.add(MS_KEY_UPLOAD_RESPONSE, responseDict);

        return MalwareScanLayer::start(param, out_dict);
    }
};

class QueryResultLayer          final : public MalwareScanLayer{
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;
        auto startProcessingTime = std::time(nullptr);

        ms_wstring filePath;
        in_dict.val(MS_KEY_FILE_PATH, filePath);

        MSDict scanFileResults, uploadResponseDict;
        ms_wstring dataId;
        if(MS_FAILED ( rc = in_dict.val(MS_KEY_UPLOAD_RESPONSE, uploadResponseDict) )
        || MS_FAILED ( rc = uploadResponseDict.val(MS_KEY_DATA_ID, dataId))){   
            return rc;
        }
        std::chrono::nanoseconds recheckResultWait = 10ms;
        while (true) {
            if(MS_FAILED ( rc = Internal::checkDataId(dataId, scanFileResults))){
                break;
            }
            
            MSDict infectErrDict;
            if ( MS_SUCCESS ( rc = scanFileResults.val(MS_KEY_INFECT_ERR, infectErrDict))){
                break;
            }

            ms_wstring dataIdKey;
            if( MS_SUCCESS ( scanFileResults.val( dataId, dataIdKey) ) && 
                dataIdKey == L"Not Found" ){
                std::cout << "Not found in db" << std::endl;
            }

            auto progressPercentage =
                scanFileResults[L"scan_results"][L"progress_percentage"].intVal();

            if (progressPercentage >= 100.0) {
                ms_wstring fileHash = scanFileResults[L"file_info"][L"sha256"].stringVal();

                ms_wstring scanResultStr;
                if ( MS_FAILED ( rc = MSJson::serialize(scanFileResults, scanResultStr))){
                    return rc;
                }   
                // 3 - Failed, 10 - Not Scanned, 19 - Cancelled
                std::set<int> failedCodes = {3, 10, 19};
                int conclusion =
                    scanFileResults[L"scan_results"][L"scan_all_result_i"].intVal();
                if (failedCodes.find(conclusion) == failedCodes.end() && 
                    MS_SUCCESS ( LocalDatabaseManager::instance()->saveLocalResult(fileHash, scanResultStr, 1) )) {
                    out_dict = scanFileResults;
                    out_dict.add(MS_KEY_FILE_PATH, filePath);
                    // std::cout << "Save result by " << StringUtils::toString(scanResultStr) << std::endl;
                }
                break;
            }
            recheckResultWait *= 2;
            if (recheckResultWait > 2s) recheckResultWait = 2s;

            std::this_thread::sleep_for(recheckResultWait);
        }
        scanFileResults.add( MS_KEY_ST_PROC_TIME,  static_cast<int>(startProcessingTime) );
        scanFileResults.add( MS_KEY_END_PROC_TIME,  static_cast<int>(std::time(nullptr)));

        out_dict = std::move(scanFileResults);
        return rc;
    }
};

namespace{
    namespace Internal{
        ms_rc requestAPI(ms_wstring file_path, std::string reqUrl, std::ifstream &reqBody, std::stringstream &responseBody, type t)
        {
            ms_rc rc = MS_OK;
            headers_t reqHead;
            Internal::buildHeader(reqHead, file_path);
            std::string reqType = (t == type::GET) ? "GET" : "POST";
            httpRequest req = {
                reqType,
                reqUrl,
                reqBody,
                reqHead,
                responseBody,
                CookieOption{CookieOption::Load}};

            std::string response;
            uint32_t iteration = 1;
            while (true) {
                responseBody.str("");
                CurlLib::getInstance()->Request(req);
                // response = responseBody.str();
                // std::cout << StringUtils::toString(file_path) << " Server response " << response << std::endl;
                break;
            }
            return rc;
        }
        ms_rc getScanConfig(MSDict &dscnConfig){
            // dscnConfig = AxzScanConfig::instance()->getConfig();
            return MS_OK;
        }
        ms_rc buildHeader(headers_t &header, const ms_wstring &file_path){
            // std::string apiKey      = "2c43153e400f78ccd178d47f17e4ae63";
            std::string apiKey      = "2acdcdfa5857b2aa585c2e3d47f2096c";
            std::string contentType = "application/octet-stream";
            std::string userAgent   = "trile";
            std::string connection  = "Keep-Alive";

            header["user_agent"] = userAgent;
            // header["rule"] = contentType;
            header["content-type"] = contentType;
            header["apikey"] = apiKey;
            header["filename"] = StringUtils::toString(file_path);

            return MS_OK;
        }
        ms_rc checkDataId(const ms_wstring &dataId, MSDict &result)
        {
            ms_rc rc = MS_OK;
            std::ifstream requestBody;
            std::stringstream responseBody;
            std::string reqUrl = "https://api.metadefender.com:443/v4/file/";
            reqUrl += StringUtils::toString(dataId);
            if (MS_FAILED ( rc = requestAPI(dataId, reqUrl, requestBody, responseBody, type::GET) )){
                return rc;
            }

            if (  MS_FAILED(MSJson::deserialize( StringUtils::toWideString(responseBody.str()), result))){
                return MS_ERROR_RANGE_JSON;
            }
            MSDict errorDict;        
            int errorCode;

            if( MS_SUCCESS( result.val(MS_KEY_ERROR, errorDict)) && MS_SUCCESS(errorDict.val(MS_KEY_CODE, errorCode))){
                return MS_ERROR_ABORTED;
            }

            return rc;
        }
    }
}
#endif