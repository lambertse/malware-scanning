#ifndef __ms_layer_h__
#define __ms_layer_h__

#include "ms_return_codes.h"
#include "ms_layers_abstract.h"
#include "ms_defines.h"
#include "ms_slot.h"
#include "ms_logger.h"
#include <cpr/cpr.h>
#include "utils/string_utils.h"
#include "utils/file_utils.h"
#include "3rdparty/msdict/ms_json.h"

#include "ms_localdb_manager.h"
#include <iostream>
#include <thread>
#include <fstream>
#include <chrono>

// #ifndef _WIN32
//     #include <axz_scu_file.h>
// #endif
using namespace std::chrono_literals;

namespace
{
namespace Internal{
    enum RquestType {GET, POST};

    cpr::Header headerDictToCprHeader(const MSDict& reqHeader);

    ms_rc requestAPI(ms_wstring filePath, const MSDict& reqHeader, ms_string reqUrl, MSDict& responseDict, RquestType t);
    ms_rc getScanServer(const MSDict& inDict, ms_wstring& url);

    MSDict createErrorDict(const MSDict &errorDict);
    ms_bool isAcceptedResult(const MSDict&result);
}
};

class VerifyFile             final : public MalwareScanLayer
{
public:
    VerifyFile() {}

    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {         
        ms_rc rc = MS_OK;

        ms_wstring filePath;
        inDict.val(MS_KEY_FILE_PATH, filePath);
        size_t file_size;
        FileUtils::fileSize(filePath, file_size);

        if(file_size == 0){
            Internal::createErrorDict( ms_dict_object{ {MS_KEY_ERROR_MSG, L"Empty file!"}} );
            MS_LOGGER_ERROR("[layers] [verify] catch an empty file");
            return MS_ERROR_EMPTY_FILE;
        }

        MSDict param = std::move(inDict);
        param.add( MS_KEY_FILE_SIZE, std::to_wstring(file_size));

        return MalwareScanLayer::start(param, outDict);
    }
};

class ManifestLayer             final : public MalwareScanLayer
{
public:
    ManifestLayer() {}

    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        //not implement for sot 
        return MalwareScanLayer::start(inDict, outDict);
    }
};

class CDRLayer                  final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        //not implement for sot
        return MalwareScanLayer::start(inDict, outDict);
    }
};

class CaculateHashLayer         final : public MalwareScanLayer
{
private: 
    std::shared_ptr<Slot> _calculateHashSlot;
public:
    CaculateHashLayer(ms_ll _limitTotalSize){
        _calculateHashSlot = std::make_shared<Slot>(_limitTotalSize, MS_THREAD_COUNT);
    } 
    CaculateHashLayer(const std::shared_ptr<Slot>& srcSlot) : _calculateHashSlot(srcSlot){}
    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        ms_rc rc = MS_OK;

        ms_wstring filePath, fileSizeStr, sha256;
        if( MS_FAILED ( rc = inDict.val(MS_KEY_FILE_PATH, filePath) ) ||
            MS_FAILED ( rc = inDict.val(MS_KEY_FILE_SIZE, fileSizeStr) )){
            MS_LOGGER_ERROR("[layers] [cal-hash] in_dict is not valid");
            return rc;
        }
        size_t file_size = std::stoull(fileSizeStr);
        
        _calculateHashSlot->waitUntilSlotAvailable(file_size);
        std::ifstream is = FileUtils::getContent(filePath, rc);
        rc = FileUtils::calculateHash(is, sha256);
        _calculateHashSlot->finishATask(file_size);

        if ( MS_FAILED (rc)){
            outDict = Internal::createErrorDict( ms_dict_object{{ MS_KEY_ERROR_MSG, L"Can not calculate hash!"}} );
            MS_LOGGER_ERROR("[layers] [cal-hash] calculate hash failed");
            return rc;
        }

        MSDict param = std::move(inDict);
        param.add(MS_KEY_HASH, sha256);
        return MalwareScanLayer::start(param, outDict);
    }
};

class LocalHashLayer            final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        ms_rc rc = MS_OK;

        ms_wstring filePath, sha256;
        if ( MS_FAILED ( rc = inDict.val(MS_KEY_FILE_PATH, filePath) ) ||
             MS_FAILED ( rc = inDict.val(MS_KEY_HASH, sha256) )){
            MS_LOGGER_ERROR("[layers] [check-localhash] in_dict is not valid");
            return rc;
        }

        ms_wstring result;
        if( MS_SUCCESS(LocalDatabaseManager::instance()->queryLocalResult(sha256, result)) ){
            MS_LOGGER_INFO("[layers] [check-localhash] result is found in local database");
            MSJson::deserialize(result, outDict);
            outDict.add(MS_KEY_FILE_PATH, filePath);
            return MS_OK;
        }
        return MalwareScanLayer::start(std::move(inDict), outDict);
    }
};

class ServerHashLayer           final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        ms_rc rc = MS_OK;

        ms_wstring filePath, sha256, scnServer, responseStr;
        MSDict reqHeader;
        if ( MS_FAILED ( rc = inDict.val(MS_KEY_FILE_PATH, filePath)) ||
             MS_FAILED ( rc = inDict.val(MS_KEY_HASH, sha256) )        ||
             MS_FAILED ( rc = inDict.val(MS_KEY_REQUEST_HEADER, reqHeader) )||
             MS_FAILED ( rc = Internal::getScanServer(inDict, scnServer)) ){
             MS_LOGGER_ERROR("[layers] [check-serverhash] in_dict is not valid"); 
            return rc;
        }

        ms_string reqUrl = StringUtils::toString( scnServer + MS_HASH_POST_FIX + sha256);
        
        MSDict responseDict, errorDict;
        if( MS_FAILED ( rc = Internal::requestAPI(filePath, reqHeader, reqUrl, responseDict, Internal::RquestType::GET) )){
            outDict = Internal::createErrorDict( ms_dict_object{{MS_KEY_ERROR_MSG, L"Send check hash request failed!" }} );
            MS_LOGGER_ERROR("[layers] [check-serverhash] failed to send request to checkhash on server");
            return MS_ERROR_SEND_REQUEST_TO_SERVER;
        }

        ms_int errorCode = -1;

        if ( MS_FAILED( responseDict.val(MS_KEY_ERROR, errorDict)) ||
             MS_FAILED( errorDict.val(MS_KEY_CODE, errorCode)) ){
            if( MS_FAILED( rc = MSJson::serialize(responseDict, responseStr))||
                ! Internal::isAcceptedResult(responseDict)){
               MS_LOGGER_ERROR("[layers] [check-serverhash] result is not valid, go to next layer");
               return MalwareScanLayer::start(std::move(inDict), outDict);
            }
            LocalDatabaseManager::instance()->saveLocalResult(sha256, responseStr, 1);
            MS_LOGGER_INFO("[layers] [check-serverhash] server check hash successfully");
            outDict = std::move(responseDict);   
            outDict.add(MS_KEY_FILE_PATH, filePath);
            return MS_OK;
        }
        return MalwareScanLayer::start(std::move(inDict), outDict);
    }
};

class UploadFileLayer           final : public MalwareScanLayer
{
private: 
    std::shared_ptr<Slot> _uploadFileSlot;
    std::shared_ptr<Slot> _readingSlot;
public:
    UploadFileLayer(ms_ll _limitTotalSize, const std::shared_ptr<Slot>& _srcSlot) : _readingSlot(_srcSlot){
        _uploadFileSlot = std::make_shared<Slot>(_limitTotalSize, MS_MAX_ALLOWED_UPLOAD_THREAD);
    } 

    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        ms_rc rc = MS_OK;

        ms_wstring filePath, sha256, fileSizeStr, scnServer;
        MSDict reqHeader;
        if ( MS_FAILED ( rc = inDict.val(MS_KEY_FILE_PATH, filePath) )         ||
             MS_FAILED ( rc = inDict.val(MS_KEY_HASH, sha256) )                ||
             MS_FAILED ( rc = inDict.val(MS_KEY_FILE_SIZE, fileSizeStr))       ||
             MS_FAILED ( rc = inDict.val(MS_KEY_REQUEST_HEADER, reqHeader) )   ||
             MS_FAILED ( rc = Internal::getScanServer(inDict, scnServer) )){
            MS_LOGGER_ERROR("[layers] [uploadfile] in_dict is not valid");
            return rc;
        }
        size_t fileSize = std::stoull(fileSizeStr);

        ms_string reqUrl = StringUtils::toString( scnServer + MS_FILE_POST_FIX);
        MSDict responseDict, errorDict;
        {
            _readingSlot->waitUntilSlotAvailable(fileSize);
            _uploadFileSlot->waitUntilSlotAvailable(fileSize);
            rc = Internal::requestAPI(filePath, reqHeader, reqUrl, responseDict, Internal::RquestType::POST);
            _uploadFileSlot->finishATask(fileSize);
            _readingSlot->finishATask(fileSize);
        }

        if( MS_FAILED (rc)){
            outDict = Internal::createErrorDict( ms_dict_object{{MS_KEY_ERROR_MSG, L"Upload file failed!" },
                                                                {MS_KEY_ERROR_DICT, responseDict}} );
            MS_LOGGER_ERROR("[layers] [uploadfile] failed to send request to upload file on server");
            return MS_ERROR_SEND_REQUEST_TO_SERVER;
        }
    
        ms_int errorCode = -1;      

        if ( MS_FAILED ( responseDict.val(MS_KEY_ERROR, errorDict)) ||
             MS_FAILED ( errorDict.val(MS_KEY_CODE, errorCode))){
            MSDict param = std::move(inDict);
            param.add(MS_KEY_UPLOAD_RESPONSE, responseDict);
            MS_LOGGER_INFO("[layers] [uploadfile] upload file to server successfully");
            return MalwareScanLayer::start(param, outDict);
        }
        outDict = Internal::createErrorDict(ms_dict_object{
            { MS_KEY_ERROR_MSG, L"Upload file failed!"},
            { MS_KEY_ERROR_DICT, std::move(errorDict)}
        });
        ms_wstring tmp;
        MSJson::serialize(responseDict, tmp);
        MS_LOGGER_ERROR("[layers] [uploadfile] failed to upload file on server with error: {}", StringUtils::toString(tmp));
        return MS_ERROR_UPLOAD_FAILED;

    }
};

class QueryResultLayer          final : public MalwareScanLayer{
public:
    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        ms_rc rc = MS_OK;
        auto startProcessingTime = std::time(nullptr);

        ms_wstring filePath, dataId, scnServer;
        MSDict scanFileResults, uploadResponseDict, reqHeader;

        if( MS_FAILED ( rc = inDict.val(MS_KEY_FILE_PATH, filePath))                  ||
            MS_FAILED ( rc = inDict.val(MS_KEY_UPLOAD_RESPONSE, uploadResponseDict) ) ||
            MS_FAILED ( rc = uploadResponseDict.val(MS_KEY_DATA_ID, dataId))          ||
            MS_FAILED ( rc = inDict.val(MS_KEY_REQUEST_HEADER, reqHeader))            ||
            MS_FAILED ( rc = Internal::getScanServer(inDict, scnServer))){   
            MS_LOGGER_ERROR("[layers] [queryresult] in_dict is not valid");
            outDict = Internal::createErrorDict( ms_dict_object{ {MS_KEY_ERROR_MSG, L"Resource is not valid!"} } );
            return rc;
        }

        std::chrono::nanoseconds recheckResultWait = MS_QUERY_TIME;
        while (true) {
            ms_string reqUrl = StringUtils::toString( scnServer + MS_FILE_POST_FIX + dataId);
            if(MS_FAILED ( rc = Internal::requestAPI(filePath, reqHeader, reqUrl, scanFileResults, Internal::RquestType::GET))){
                ms_wstring tmp;
                MSJson::serialize(scanFileResults, tmp);
                MS_LOGGER_ERROR("[layers] [queryresult] send query result API failed. result: {}", StringUtils::toString(tmp));
                MSDict errDict = Internal::createErrorDict( scanFileResults );
                scanFileResults.add(errDict);
                break;
            }

            MSDict infectErrDict;
            ms_wstring dataIdKey;
            if ( MS_SUCCESS ( rc = scanFileResults.val(MS_KEY_INFECT_ERR, infectErrDict)) ||
               ( MS_SUCCESS ( scanFileResults.val( dataId, dataIdKey) ) && dataIdKey == L"Not Found" )  ){
                MS_LOGGER_ERROR("[layers] [queryresult] data ID is not exist on server");
                break;
            }

            int32_t progressPercentage = scanFileResults[MS_KEY_SCAN_RES][MS_KEY_PROC_PERCENTAGE].intVal();

            if (progressPercentage >= 100.0) {
                ms_wstring fileHash = scanFileResults[MS_KEY_FILE_INFO][MS_KEY_SHA_256].stringVal();

                ms_wstring scanResultStr;
                if ( MS_FAILED ( rc = MSJson::serialize(scanFileResults, scanResultStr))){
                    MS_LOGGER_ERROR("[layers] [queryresult] parse scan result failed");
                    return rc;
                }   
                // 3 - Failed, 10 - Not Scanned, 19 - Cancelled
                std::set<ms_int> failedCodes = {3, 10, 19};
                ms_int conclusion =
                    scanFileResults[MS_KEY_SCAN_RES][MS_KEY_SCAN_ALL_RES_I].intVal();
                if ( failedCodes.find(conclusion) == failedCodes.end() ) {
                    LocalDatabaseManager::instance()->saveLocalResult(fileHash, scanResultStr, 1);
                    MS_LOGGER_INFO("[layers] [queryresult] server query result successfully");
                }
                break;
            }
            recheckResultWait *= 2;
            if (recheckResultWait > 2s) recheckResultWait = 2s;

            std::this_thread::sleep_for(recheckResultWait);
        }
        scanFileResults.add( MS_KEY_FILE_PATH,          filePath );
        scanFileResults.add( MS_KEY_ST_PROC_TIME,       static_cast<ms_int>(startProcessingTime) );
        scanFileResults.add( MS_KEY_END_PROC_TIME,      static_cast<ms_int>(std::time(nullptr)));

        outDict = std::move(scanFileResults);
        return rc;
    }
};

class ExternalLayer             final : public MalwareScanLayer{
public:
    ExternalLayer() {}

    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        //implement later
        return MalwareScanLayer::start(inDict, outDict);
    }
};
namespace{
    namespace Internal{
        cpr::Header headerDictToCprHeader(const MSDict &reqHeader)
        {
            cpr::Header header;
            if( !reqHeader.isObject() ){
                MS_LOGGER_ERROR("[layers] [internal] request header dict is not valid");
                return header;
            }
            for( auto i : reqHeader.keys()){
                ms_wstring value;
                reqHeader.val(i, value);
                header[StringUtils::toString(i)] = StringUtils::toString(value);
            }

            return header;
        }

        ms_rc requestAPI(ms_wstring filePath, const MSDict& reqHeader, ms_string reqUrl, MSDict& responseDict, RquestType t)
        {
            ms_rc rc = MS_OK;;
            cpr::Header headers = headerDictToCprHeader(reqHeader);
            cpr::Response response;
            if(t == GET) {
                response = cpr::Get(cpr::Url{reqUrl},  cpr::VerifySsl{false}, cpr::Header{headers});
            }else if(t == POST){
                // cpr::SslOptions sslOpts = cpr::Ssl(cpr::ssl::CaPath{"/home/lambert/Documents/Client/grsc-linux/build/lib/curl-ca-bundle.crt"});
                response = cpr::Post(cpr::Url{reqUrl},  cpr::VerifySsl{false}, cpr::Header{headers},  cpr::Multipart{{"filePath", cpr::File{StringUtils::toString(filePath)}}});
            }
            if ( MS_FAILED( rc = MSJson::deserialize( StringUtils::toWideString(response.text), responseDict))){
                MS_LOGGER_ERROR("[layers] [internal] reponse is not valid");
                return rc;
            }

            return rc;
        }

        ms_rc getScanServer(const MSDict &inDict, ms_wstring &url)
        {
            ms_rc rc = MS_OK;
            MSDict config,availScanner;
            if( MS_FAILED ( rc = inDict.val(MS_KEY_CONFIG, config))                 ||
                MS_FAILED ( rc = config.val(MS_KEY_AVAIL_SCANNERS, availScanner))   ||
                !availScanner.isArray()                                             ||
                !availScanner.size()                                                ||
                MS_FAILED ( rc = availScanner[0].val(MS_KEY_URL, url))){
                MS_LOGGER_ERROR("[layers] [internal] config is not valid | not exist any scanners");
                return MS_ERROR_NON_EXISTENT_SCANNER;
            }
            return rc;
        }
        MSDict createErrorDict(const MSDict &errorDict)
        {
            return ms_dict_object{ 
                { MS_KEY_INFECT_ERR, std::move(errorDict)} };
        }
        ms_bool isAcceptedResult(const MSDict &result)
        {
            ms_rc rc = MS_OK;
            MSDict procInfo;
            ms_wstring res;
            if( MS_FAILED ( rc = result.val(MS_KEY_PROC_INFO, procInfo) )           ||
                MS_FAILED ( rc = procInfo.val(MS_KEY_RESULT, res))){
                ms_wstring tmp;
                MSJson::serialize(result, tmp);
                MS_LOGGER_ERROR("[layers] [check-serverhash] result from server is not valid!, result: {}", StringUtils::toString(tmp));
                return false;
            }
            return true;
        }
    }
}
#endif