#ifndef __ms_layer_h__
#define __ms_layer_h__

#include "ms_return_codes.h"
#include "ms_layers_abstract.h"
#include "ms_defines.h"
#include "ms_slot.h"
#include "ms_logger.h"
#include "ms_labels.h"
#include "ms_localdb_manager.h"

#include "utils/string_utils.h"
#include "utils/file_utils.h"
#include "utils/cpr_template_utils.h"
#include "3rdparty/msdict/ms_json.h"

#include <cpr/cpr.h>
#include <iostream>
#include <thread>
#include <fstream>
#include <chrono>

using namespace std::chrono_literals;

namespace
{
namespace Internal{
    enum RquestType { GET, POST };
    cpr::Header headerDictToCprHeader(const MSDict& reqHeader);

    ms_rc requestAPI(ms_wstring filePath, const MSDict& reqHeader, ms_string reqUrl, MSDict& responseDict, RquestType t, const CallOrigin& callOrg);
    ms_rc getScanServer(const MSDict& inDict, ms_wstring& url);

    MSDict createErrorDict(const ms_wstring& errMsg);

    /*Some time the result misses some fields. Need to check it*/
    ms_bool isAcceptedResult(const MSDict&result);
}
};

class VerifyFile             final : public MalwareScanLayer
{
public:
    VerifyFile() {}

    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {         
        ms_rc rc = MS_OK;

        ms_wstring filePath;
        inDict.val(MS_KEY_FILE_PATH, filePath);
        size_t file_size;
        FileUtils::fileSize(filePath, file_size);

        if(file_size == 0){
            Internal::createErrorDict( L"Empty file!" );
            MS_LOGGER_ERROR("{}{} catch an empty file", MS_LABEL_LAYERS, MS_LABEL_VERIFY);
        }

        MSDict param = std::move(inDict);
        param.add( MS_KEY_FILE_SIZE, std::to_wstring(file_size));

        return MalwareScanLayer::start(param, outDict);
    }
};

class ManifestLayer             final : public MalwareScanLayer
{
public:
    ManifestLayer() {}

    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        //not implement for sot 
        return MalwareScanLayer::start(inDict, outDict);
    }
};

class CDRLayer                  final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        //not implement for sot
        return MalwareScanLayer::start(inDict, outDict);
    }
};

class CaculateHashLayer         final : public MalwareScanLayer
{
private: 
    std::shared_ptr<Slot> _calculateHashSlot;
public:
    CaculateHashLayer(ms_ll _limitTotalSize){
        _calculateHashSlot = std::make_shared<Slot>(_limitTotalSize, MS_THREAD_COUNT);
    } 
    CaculateHashLayer(const std::shared_ptr<Slot>& srcSlot) : _calculateHashSlot(srcSlot){}
    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        ms_rc rc = MS_OK;

        ms_wstring filePath, fileSizeStr, sha256;
        if( MS_FAILED ( rc = inDict.val(MS_KEY_FILE_PATH, filePath) ) ||
            MS_FAILED ( rc = inDict.val(MS_KEY_FILE_SIZE, fileSizeStr) )){
            MS_LOGGER_ERROR("{}{} in_dict is not valid", MS_LABEL_LAYERS, MS_LABEL_CAL_HASH);
            return rc;
        }
        size_t file_size = std::stoull(fileSizeStr);
        
        _calculateHashSlot->waitUntilSlotAvailable(file_size);
        std::ifstream is = FileUtils::getContent(filePath, rc);
        rc = FileUtils::calculateHash(is, sha256);
        _calculateHashSlot->finishATask(file_size);

        if ( MS_FAILED (rc)){
            outDict = Internal::createErrorDict( L"Can not calculate hash!" );
            MS_LOGGER_ERROR("{}{} calculate hash failed", MS_LABEL_LAYERS, MS_LABEL_CAL_HASH);
            return rc;
        }

        MSDict param = std::move(inDict);
        param.add(MS_KEY_HASH, sha256);
        return MalwareScanLayer::start(param, outDict);
    }
};

class LocalHashLayer            final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        ms_rc rc = MS_OK;

        ms_wstring filePath, sha256;
        if ( MS_FAILED ( rc = inDict.val(MS_KEY_FILE_PATH, filePath) ) ||
             MS_FAILED ( rc = inDict.val(MS_KEY_HASH, sha256) )){
            MS_LOGGER_ERROR("{}{} in_dict is not valid", MS_LABEL_LAYERS, MS_LABEL_CHECK_LOCAL_HASH);
            return rc;
        }

        ms_wstring result;
        if( MS_SUCCESS(LocalDatabaseManager::instance()->queryLocalResult(sha256, result)) ){
            MS_LOGGER_INFO("{}{} result is found in local database", MS_LABEL_LAYERS, MS_LABEL_CHECK_LOCAL_HASH);
            MSJson::deserialize(result, outDict);
            outDict.add(MS_KEY_FILE_PATH, filePath);
            return MS_OK;
        }
        return MalwareScanLayer::start(std::move(inDict), outDict);
    }
};

class ServerHashLayer           final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        ms_rc rc = MS_OK;

        ms_wstring filePath, sha256, scnServer, responseStr;
        MSDict reqHeader;
        if ( MS_FAILED ( rc = inDict.val(MS_KEY_FILE_PATH, filePath)) ||
             MS_FAILED ( rc = inDict.val(MS_KEY_HASH, sha256) )        ||
             MS_FAILED ( rc = inDict.val(MS_KEY_REQUEST_HEADER, reqHeader) )||
             MS_FAILED ( rc = Internal::getScanServer(inDict, scnServer)) ){
             MS_LOGGER_ERROR("{}{} in_dict is not valid", MS_LABEL_LAYERS,MS_LABEL_CHECK_SERVER_HASH); 
            return rc;
        }

        ms_string reqUrl = StringUtils::toString( scnServer + MS_PATH_HASH_POST_FIX + sha256);
        
        MSDict responseDict, errorDict;
        if( MS_FAILED ( rc = Internal::requestAPI(filePath, reqHeader, reqUrl, responseDict, Internal::RquestType::GET, CallOrigin::hash) )){
            outDict = std::move(responseDict);
            MS_LOGGER_ERROR("{}{} failed to send request to checkhash on server", MS_LABEL_LAYERS,MS_LABEL_CHECK_SERVER_HASH);
            return MS_ERROR_SEND_REQUEST_TO_SERVER;
        }

        ms_int errorCode = -1;

        if ( MS_FAILED( responseDict.val(MS_KEY_ERROR, errorDict)) ||
             MS_FAILED( errorDict.val(MS_KEY_CODE, errorCode)) ){
            if( MS_FAILED( rc = MSJson::serialize(responseDict, responseStr))||
                ! Internal::isAcceptedResult(responseDict)){
               MS_LOGGER_ERROR("{}{} result is not valid, go to next layer", MS_LABEL_LAYERS,MS_LABEL_CHECK_SERVER_HASH);
               return MalwareScanLayer::start(std::move(inDict), outDict);
            }
            LocalDatabaseManager::instance()->saveLocalResult(sha256, responseStr, 1);
            MS_LOGGER_INFO("{}{} server check hash successfully", MS_LABEL_LAYERS,MS_LABEL_CHECK_SERVER_HASH);
            outDict = std::move(responseDict);   
            outDict.add(MS_KEY_FILE_PATH, filePath);
            return MS_OK;
        }
        return MalwareScanLayer::start(std::move(inDict), outDict);
    }
};

class UploadFileLayer           final : public MalwareScanLayer
{
private: 
    std::shared_ptr<Slot> _uploadFileSlot;
    std::shared_ptr<Slot> _readingSlot;
public:
    UploadFileLayer(ms_ll _limitTotalSize, const std::shared_ptr<Slot>& _srcSlot) : _readingSlot(_srcSlot){
        _uploadFileSlot = std::make_shared<Slot>(_limitTotalSize, MS_MAX_ALLOWED_UPLOAD_THREAD);
    } 
    UploadFileLayer(const std::shared_ptr<Slot>& srcReadSlot, const std::shared_ptr<Slot>& srcUploadSlot) : _uploadFileSlot(srcUploadSlot), _readingSlot(srcReadSlot){}

    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        ms_rc rc = MS_OK;
        
        ms_wstring filePath, sha256, fileSizeStr, scnServer;
        MSDict reqHeader;
        if ( MS_FAILED ( rc = inDict.val(MS_KEY_FILE_PATH, filePath) )         ||
             MS_FAILED ( rc = inDict.val(MS_KEY_HASH, sha256) )                ||
             MS_FAILED ( rc = inDict.val(MS_KEY_FILE_SIZE, fileSizeStr))       ||
             MS_FAILED ( rc = inDict.val(MS_KEY_REQUEST_HEADER, reqHeader) )   ||
             MS_FAILED ( rc = Internal::getScanServer(inDict, scnServer) )){
            MS_LOGGER_ERROR("{}{} in_dict is not valid", MS_LABEL_LAYERS, MS_LABEL_UPLOAD_FILE);
            return rc;
        }
        size_t fileSize = std::stoull(fileSizeStr);

        ms_string reqUrl = StringUtils::toString( scnServer + MS_PATH_FILE_POST_FIX);
        MSDict responseDict, errorDict;
        {
            _readingSlot->waitUntilSlotAvailable(fileSize);
            _uploadFileSlot->waitUntilSlotAvailable(fileSize);
            MS_LOGGER_INFO("{}{} Start uploading file {} with size {}. threading uploading: {}, size uploading: {}", MS_LABEL_LAYERS, MS_LABEL_UPLOAD_FILE, StringUtils::toString(filePath) , StringUtils::toString(fileSizeStr) , _uploadFileSlot->_currentProcessingThread, _uploadFileSlot->_currentProcessingSize);
            rc = Internal::requestAPI(filePath, reqHeader, reqUrl, responseDict, Internal::RquestType::POST, CallOrigin::sendFileLocal);
            MS_LOGGER_INFO("{}{} End uploading", MS_LABEL_LAYERS, MS_LABEL_UPLOAD_FILE);
            _uploadFileSlot->finishATask(fileSize);
            _readingSlot->finishATask(fileSize);
        }

        if( MS_FAILED (rc)){
            outDict = std::move(responseDict);
            MS_LOGGER_ERROR("{}{} failed to send request to upload file on server", MS_LABEL_LAYERS, MS_LABEL_UPLOAD_FILE);
            return MS_ERROR_UPLOAD_FAILED;
        }
    
        ms_int errorCode = -1;      

        if ( MS_FAILED ( responseDict.val(MS_KEY_ERROR, errorDict)) ||
             MS_FAILED ( errorDict.val(MS_KEY_CODE, errorCode))){
            MSDict param = std::move(inDict);
            param.add(MS_KEY_UPLOAD_RESPONSE, responseDict);
            MS_LOGGER_INFO("{}{} upload file to server successfully", MS_LABEL_LAYERS, MS_LABEL_UPLOAD_FILE);
            return MalwareScanLayer::start(param, outDict);
        }
        // outDict = Internal::createErrorDict(ms_dict_object{
        //     { MS_KEY_ERROR_MSG, L"Upload file failed!"},
        //     { MS_KEY_ERROR_DICT, std::move(errorDict)}
        // });
        // ms_wstring tmp;
        // MSJson::serialize(responseDict, tmp);
        // MS_LOGGER_ERROR("[layers] [uploadfile] failed to upload file on server with error: {}", StringUtils::toString(tmp));
        // return MS_ERROR_UPLOAD_FAILED;

    }
};

class QueryResultLayer          final : public MalwareScanLayer{
public:
    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        ms_rc rc = MS_OK;
        auto startProcessingTime = std::time(nullptr);

        ms_wstring filePath, dataId, scnServer;
        MSDict scanFileResults, uploadResponseDict, reqHeader;

        if( MS_FAILED ( rc = inDict.val(MS_KEY_FILE_PATH, filePath))                  ||
            MS_FAILED ( rc = inDict.val(MS_KEY_UPLOAD_RESPONSE, uploadResponseDict) ) ||
            MS_FAILED ( rc = uploadResponseDict.val(MS_KEY_DATA_ID, dataId))          ||
            MS_FAILED ( rc = inDict.val(MS_KEY_REQUEST_HEADER, reqHeader))            ||
            MS_FAILED ( rc = Internal::getScanServer(inDict, scnServer))){   
            MS_LOGGER_ERROR("{}{} in_dict is not valid", MS_LABEL_LAYERS, MS_LABEL_QUERY_RESULT);
            outDict = Internal::createErrorDict( L"Resource is not valid!" );
            return rc;
        }

        std::chrono::nanoseconds recheckResultWait = MS_QUERY_TIME;
        while (true) {
            ms_string reqUrl = StringUtils::toString( scnServer + MS_PATH_FILE_POST_FIX + dataId);
            if(MS_FAILED ( rc = Internal::requestAPI(filePath, reqHeader, reqUrl, scanFileResults, Internal::RquestType::GET, CallOrigin::checkDataId))){
                ms_wstring resStr;
                MSJson::serialize(scanFileResults, resStr);
                MS_LOGGER_ERROR("{}{} send query result API failed. result: {}", MS_LABEL_LAYERS, MS_LABEL_QUERY_RESULT, StringUtils::toString(resStr));
                MSDict errDict = std::move(scanFileResults);
                scanFileResults.add(errDict);
                break;
            }

            MSDict infectErrDict;
            ms_wstring dataIdKey;
            if ( MS_SUCCESS ( rc = scanFileResults.val(MS_KEY_INFECT_ERR, infectErrDict)) ||
               ( MS_SUCCESS ( scanFileResults.val( dataId, dataIdKey) ) && dataIdKey == L"Not Found" )  ){
                MS_LOGGER_ERROR("{}{} data ID is not exist on server", MS_LABEL_LAYERS, MS_LABEL_QUERY_RESULT);
                break;
            }

            int32_t progressPercentage = scanFileResults[MS_KEY_SCAN_RES][MS_KEY_PROC_PERCENTAGE].intVal();

            if (progressPercentage >= 100.0) {
                ms_wstring fileHash = scanFileResults[MS_KEY_FILE_INFO][MS_KEY_SHA_256].stringVal();

                ms_wstring scanResultStr;
                if ( MS_FAILED ( rc = MSJson::serialize(scanFileResults, scanResultStr))){
                    MS_LOGGER_ERROR("{}{} parse scan result failed", MS_LABEL_LAYERS, MS_LABEL_QUERY_RESULT);
                    return rc;
                }   
                // 3 - Failed, 10 - Not Scanned, 19 - Cancelled
                std::set<ms_int> failedCodes = {3, 10, 19};
                ms_int conclusion =
                    scanFileResults[MS_KEY_SCAN_RES][MS_KEY_SCAN_ALL_RES_I].intVal();
                if ( failedCodes.find(conclusion) == failedCodes.end() ) {
                    LocalDatabaseManager::instance()->saveLocalResult(fileHash, scanResultStr, 1);
                    MS_LOGGER_INFO("{}{} server query result successfully", MS_LABEL_LAYERS, MS_LABEL_QUERY_RESULT);
                }
                break;
            }
            recheckResultWait *= 2;
            if (recheckResultWait > 2s) recheckResultWait = 2s;

            std::this_thread::sleep_for(recheckResultWait);
        }
        scanFileResults.add( MS_KEY_FILE_PATH,          filePath );
        scanFileResults.add( MS_KEY_ST_PROC_TIME,       static_cast<ms_int>(startProcessingTime) );
        scanFileResults.add( MS_KEY_END_PROC_TIME,      static_cast<ms_int>(std::time(nullptr)));

        outDict = std::move(scanFileResults);
        return rc;
    }
};

class ExternalLayer             final : public MalwareScanLayer{
public:
    ExternalLayer() {}

    ms_rc start(const MSDict& inDict, MSDict& outDict) override
    {
        //implement later
        return MalwareScanLayer::start(inDict, outDict);
    }
};
namespace{
    namespace Internal{
        cpr::Header headerDictToCprHeader(const MSDict &reqHeader)
        {
            cpr::Header header;
            if( !reqHeader.isObject() ){
                MS_LOGGER_ERROR("{}{} request header dict is not valid", MS_LABEL_LAYERS, MS_LABEL_INTERNAL);
                return header;
            }
            for( auto i : reqHeader.keys()){
                ms_wstring value;
                reqHeader.val(i, value);
                header[StringUtils::toString(i)] = StringUtils::toString(value);
            }

            return header;
        }

        ms_rc requestAPI(ms_wstring filePath, const MSDict& reqHeader, ms_string reqUrl, MSDict& responseDict, RquestType t, const CallOrigin& callOrg)
        {
            ms_rc rc = MS_OK;;
            cpr::Header headers = headerDictToCprHeader(reqHeader);
            cpr::Response response;

            std::shared_ptr<BaseCprUtils> shouldRetry;
            switch (callOrg)
            {
            case CallOrigin::hash:
                shouldRetry = std::make_shared<CheckHash>();
                break;
            case CallOrigin::sendFileLocal:
                shouldRetry = std::make_shared<UploadFileToServer>();
                break;   
            case CallOrigin::checkDataId:
                shouldRetry = std::make_shared<CheckDataID>();
                break;   
            default:
                shouldRetry = std::make_shared<BaseCprUtils>();
                break;
            }

            uint32_t iter = 0;
            while(true){
                if(t == GET) {
                    response = cpr::Get(cpr::Url{reqUrl},  cpr::VerifySsl{false}, cpr::Header{headers});
                }else if(t == POST){
                    // cpr::SslOptions sslOpts = cpr::Ssl(cpr::ssl::CaPath{"/home/lambert/Documents/Client/grsc-linux/build/lib/curl-ca-bundle.crt"});
                    response = cpr::Post(cpr::Url{reqUrl},  cpr::VerifySsl{false}, cpr::Header{headers},  cpr::Multipart{{"filePath", cpr::File{StringUtils::toString(filePath)}}});
                }
                if(!shouldRetry->ShouldRetry(response, iter))
                    break;
            }
            MSDict errDict = shouldRetry->ShouldReportError(response);
            if( !errDict.isNull() ){
                responseDict = std::move(errDict);
                return MS_ERROR_SHOULD_REPORT_ERROR;
            }
            
            if ( MS_FAILED( rc = MSJson::deserialize( StringUtils::toWideString(response.text), responseDict))){
                MS_LOGGER_ERROR("{}{} reponse is not valid", MS_LABEL_LAYERS, MS_LABEL_INTERNAL);
                return rc;
            }

            return rc;
        }

        ms_rc getScanServer(const MSDict &inDict, ms_wstring &url)
        {
            ms_rc rc = MS_OK;
            MSDict config,availScanner;
            if( MS_FAILED ( rc = inDict.val(MS_KEY_CONFIG, config))                 ||
                MS_FAILED ( rc = config.val(MS_KEY_AVAIL_SCANNERS, availScanner))   ||
                !availScanner.isArray()                                             ||
                !availScanner.size()                                                ||
                MS_FAILED ( rc = availScanner[0].val(MS_KEY_URL, url))){
                MS_LOGGER_ERROR("{}{} config is not valid | not exist any scanners", MS_LABEL_LAYERS, MS_LABEL_INTERNAL);
                return MS_ERROR_NON_EXISTENT_SCANNER;
            }
            return rc;
        }

        MSDict createErrorDict(const ms_wstring& errMsg)
        {
           return ms_dict_object{
                    { MS_KEY_INFECT_ERR, ms_dict_object { 
                                            { MS_KEY_HTTP_CODE,         0 },
                                            { MS_KEY_CURL_ERROR_CODE,   0 },
                                            { MS_KEY_ERROR_MSG,         errMsg }
                                        }
                    }
                };
        }

        ms_bool isAcceptedResult(const MSDict &result)
        {
            ms_rc rc = MS_OK;
            MSDict procInfo;
            ms_wstring res;
            if( MS_FAILED ( rc = result.val(MS_KEY_PROC_INFO, procInfo) )           ||
                MS_FAILED ( rc = procInfo.val(MS_KEY_RESULT, res))){
                ms_wstring resStr;
                MSJson::serialize(result, resStr);
                MS_LOGGER_ERROR("{}{} result from server is not valid!, result: {}", MS_LABEL_LAYERS, MS_LABEL_QUERY_RESULT, StringUtils::toString(resStr));
                return false;
            }
            return true;
        }
    }
}
#endif