#ifndef __ms_layer_h__
#define __ms_layer_h__

#include "ms_return_codes.h"
#include "ms_layers_interface.h"
#include "ms_defines.h"
// #include "ms_config.h"
#include "shared/ezcurl/EzCurl.h"
#include "shared/cal_hash/CalculateHash.h"
#include "shared/string/StringUtils.h"

#include <iostream>
#include <thread>
#include <fstream>

using namespace Curl;

namespace
{
namespace Internal{
    ms_rc getScanConfig(AxzDict &dscnConfig); 
    ms_rc buildCheckHashHeader(headers_t &header, const std::wstring &file_path);
}
};

class ManifestLayer             final : public MalwareScanLayer
{
public:
    ManifestLayer() {}

    AxzDict start(const AxzDict& in_dict) override
    {
        //not implement for sot 
        MalwareScanLayer::start(in_dict);
    }
};

class CDRLayer                  final : public MalwareScanLayer
{
public:
    AxzDict start(const AxzDict& in_dict) override
    {
        //not implement for sot
        return MalwareScanLayer::start(in_dict);
    }
};


class CaculateHashLayer         final : public MalwareScanLayer
{
public:
    AxzDict start(const AxzDict& in_dict) override
    {
        std::wstring file_path;
        in_dict.val(MS_KEY_PATH, file_path);
        // file_path = L"/home/trile/Documents/test.sh";
        std::wstring sha256;
        AxzUtilsShamd hasher( AxzUtilsHashType::AXZ_SHA_256 );
        hasher.hexCodeOfFile(file_path, sha256);

        AxzDict param = std::move(in_dict);
        param.add(MS_KEY_HASH, sha256);

        return MalwareScanLayer::start(param);
    }
};

class LocalHashLayer            final : public MalwareScanLayer
{
public:
    AxzDict start(const AxzDict& in_dict) override
    {
        std::wstring file_path;
        in_dict.val(MS_KEY_PATH, file_path);
        
        std::wstring sha256;
        in_dict.val(MS_KEY_HASH, sha256);

        std::cout << StringUtils::toString(file_path) << " === " << StringUtils::toString(sha256) << std::endl;

        AxzDict param = std::move(in_dict);

        return MalwareScanLayer::start(in_dict);
    }
};

class ServerHashLayer           final : public MalwareScanLayer
{
public:
    AxzDict start(const AxzDict& in_dict) override
    {
        
        std::wstring file_path;
        in_dict.val(MS_KEY_PATH, file_path);
        std::wstring sha256;
        in_dict.val(MS_KEY_HASH, sha256);

        std::stringstream requestBody;
        std::stringstream responseBody;
        std::string server = "https://api.metadefender.com:443/v4/hash/";
        // auto requestType = CurlRetry::CallOrigin::hash;
        std::string reqUrl = server + StringUtils::toString(sha256);
        headers_t reqHead;
        Internal::buildCheckHashHeader(reqHead, file_path);
        httpRequest req = {
            "GET",
            reqUrl,
            requestBody,
            reqHead,
            responseBody
            // CookieOption{CookieOption::Load}};
        };
        std::string response;
        uint32_t iteration = 1;
        while (true) {
            responseBody.str("");
            CurlLib::getInstance()->Request(req);
            // std::cout << responseBody.str() << std::endl;
            // std::cout << req.error <<std::endl;
            // response = req.response.;
            // if (!CurlRetry::ShouldRetryCurl(requestType, req, iteration, response))
            break;
        }

    //     // AxzDict scanConfig = AxzScanConfig::instance()->getConfig();
    //     // axz_string tmp = AxzUtilsCommon::AxzDictToString(scanConfig);
    //     // std::cout << "Config: " << tmp << std::endl;
    //     std::wstring host = L"https://api.metadefender.com:443/v4";
    //     AxzDict header;
    //     if( AXZ_FAILED (Internal::buildCheckHashHeader(header, file_path))){
    //         return axz_dict_object {};
    //     }
    //     // axz_string tmp = AxzUtilsCommon::AxzDictToString(header);
    //     // std::cout << "Header: " << tmp << std::endl;
    //     AxzDict response{AxzDictType::OBJECT};
    //     axz_dict_callable handler = [&response]( AxzDict&& in_dict ) -> AxzDict 
    //     {
    //         axz_bytes responseBytes;
    //         in_dict.val(MS_KEY_RESPONSE, responseBytes);
    //         AxzAxzDict::deserialize( AxzScuString::toWideString( ( axz_char* )responseBytes.data() ), response );

    //         // std::cout << "Get response: " << AxzUtilsCommon::AxzDictToString(response) << std::endl;

            
    //         auto failing_comment_test = "{\n\"a\": 1\n}/";
    //         std::string err_failing_comment;
    //         auto   AxzDict_failing_comment = AxzDict11::AxzDict::parse(
    //   failing_comment_test, err_failing_comment, AxzDict11::AxzDictParse::COMMENTS); 
    //         std::cout << "Trile get response: " << AxzDict_failing_comment.dump() << std::endl;

    //         return MS_OK;
    //     };

    //     std::ifstream fileStream ( AxzScuString::toString(file_path));
    //     std::string fileContent( (std::istreambuf_iterator<char>(fileStream)), std::istreambuf_iterator<char>() );
    //     axz_bytes body { fileContent.begin(), fileContent.end() };

    //     std::wstring path { L"//hash//" + sha256 };
    //     axz_dict_object param_object = {
    //         { MS_KEY_HOST, host },
    //         { MS_KEY_PATH, path },
    //         { MS_KEY_HEADERS,  std::move( header ) },
    //         { MS_KEY_VERB,     AXZ_HTTPS_GET },
    //         { MS_KEY_BODY,     std::move( body ) },
    //         { MS_KEY_HANDLER, ( axz_dict_callable )handler }
    //     };
    //     axz_dict_object in_object = {
    //         { AXZ_KEY_MID, AXZ_MID_SEND_HTTPS_REQUEST_SYNC },
    //         { AXZ_KEY_PARAM, std::move( param_object ) }
    //     };

    //     AxzUtilsBridge bridge;
    //     auto result_dict = bridge.handle( in_object );
        return MalwareScanLayer::start(in_dict);
    }
};


class UploadFileLayer           final : public MalwareScanLayer
{
public:
    AxzDict start(const AxzDict& in_dict) override
    {
        std::wstring val;
        in_dict.val(MS_KEY_PATH, val);
        const std::string s( val.begin(), val.end() );
        std::cout << " Done a task! \n";
        return MalwareScanLayer::start(in_dict);
    }
};


namespace{
    namespace Internal{
        ms_rc getScanConfig(AxzDict &dscnConfig){
            // dscnConfig = AxzScanConfig::instance()->getConfig();
            return MS_OK;
        }

        ms_rc buildCheckHashHeader(headers_t &header, const std::wstring &file_path){
            std::string apiKey      = "2c43153e400f78ccd178d47f17e4ae63";
            std::string contentType = "application/octet-stream";
            std::string userAgent   = "trile";
            std::string connection  = "Keep-Alive";

            header["user_agent"] = userAgent;
            header["rule"] = contentType;
            header["apikey"] = apiKey;
            header["filename"] = StringUtils::toString(file_path);

            return MS_OK;
        }
    }
}
#endif