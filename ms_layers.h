#ifndef __ms_layer_h__
#define __ms_layer_h__

#include "ms_return_codes.h"
#include "ms_layers_interface.h"
#include "ms_defines.h"
// #include "ms_config.h"
#include "shared/ezcurl/EzCurl.h"
#include "shared/cal_hash/CalculateHash.h"
#include "shared/string/StringUtils.h"
#include "shared/axzdict/axz_json.h"

#include <iostream>
#include <thread>
#include <fstream>

using namespace Curl;

namespace
{
namespace Internal{
    ms_rc getScanConfig(AxzDict &dscnConfig); 
    ms_rc buildCheckHashHeader(headers_t &header, const std::wstring &file_path);
}
};

class ManifestLayer             final : public MalwareScanLayer
{
public:
    ManifestLayer() {}

    ms_rc start(const AxzDict& in_dict, AxzDict& out_dict) override
    {
        //not implement for sot 
        MalwareScanLayer::start(in_dict, out_dict);
    }
};

class CDRLayer                  final : public MalwareScanLayer
{
public:
    ms_rc start(const AxzDict& in_dict, AxzDict& out_dict) override
    {
        //not implement for sot
        return MalwareScanLayer::start(in_dict, out_dict);
    }
};


class CaculateHashLayer         final : public MalwareScanLayer
{
public:
    ms_rc start(const AxzDict& in_dict, AxzDict& out_dict) override
    {
        std::wstring file_path;
        in_dict.val(MS_KEY_PATH, file_path);
        // file_path = L"/home/trile/Documents/test.sh";
        std::wstring sha256;
        AxzUtilsShamd hasher( AxzUtilsHashType::AXZ_SHA_256 );
        hasher.hexCodeOfFile(file_path, sha256);

        AxzDict param = std::move(in_dict);
        param.add(MS_KEY_HASH, sha256);

        return MalwareScanLayer::start(param, out_dict);
    }
};

class LocalHashLayer            final : public MalwareScanLayer
{
public:
    ms_rc start(const AxzDict& in_dict, AxzDict& out_dict) override
    {
        std::wstring file_path;
        in_dict.val(MS_KEY_PATH, file_path);
        
        std::wstring sha256;
        in_dict.val(MS_KEY_HASH, sha256);

        // std::cout << StringUtils::toString(file_path) << " === " << StringUtils::toString(sha256) << std::endl;

        AxzDict param = std::move(in_dict);

        return MalwareScanLayer::start(param, out_dict);
    }
};

class ServerHashLayer           final : public MalwareScanLayer
{
public:
    ms_rc start(const AxzDict& in_dict, AxzDict& out_dict) override
    {
        
        std::wstring file_path;
        in_dict.val(MS_KEY_PATH, file_path);
        std::wstring sha256;
        in_dict.val(MS_KEY_HASH, sha256);

        std::stringstream requestBody;
        std::stringstream responseBody;
        std::string server = "https://api.metadefender.com:443/v4/hash/";
        // auto requestType = CurlRetry::CallOrigin::hash;
        std::string reqUrl = server + StringUtils::toString(sha256);
        headers_t reqHead;
        Internal::buildCheckHashHeader(reqHead, file_path);
        httpRequest req = {
            "GET",
            reqUrl,
            requestBody,
            reqHead,
            responseBody,
            CookieOption{CookieOption::Load}};

        std::string response;
        uint32_t iteration = 1;
        while (true) {
            responseBody.str("");
            CurlLib::getInstance()->Request(req);
            // response = responseBody.str();
            // std::cout << StringUtils::toString(file_path) << " Server response " << response << std::endl;
            // if (!CurlRetry::ShouldRetryCurl(requestType, req, iteration, response))
            break;
        }

        AxzDict responseDict;
        if (  MS_FAILED(AxzJson::deserialize( StringUtils::toWideString(responseBody.str()), responseDict))){
            return MS_ERROR_RANGE_JSON;
        }
        AxzDict errorDict;        
        int errorCode;

        if( MS_SUCCESS( responseDict.val(MS_KEY_ERROR, errorDict)) && MS_SUCCESS(errorDict.val(MS_KEY_CODE, errorCode))){
            switch (errorCode)
            {
            case 404003:
                return MalwareScanLayer::start(in_dict, out_dict);
                break;
            default:
                break;
            }
        }

        // std::wstring tmp;
        // AxzJson::serialize(responseDict, tmp);
        // std::cout << StringUtils::toString(tmp) << std::endl;
        out_dict = responseDict;
        // std::wstring tmp;
        // AxzJson::serialize(out_dict, tmp);
        // std::cout << StringUtils::toString(tmp) << std::endl;
        return MS_OK;
    }
};


class UploadFileLayer           final : public MalwareScanLayer
{
public:
    ms_rc start(const AxzDict& in_dict, AxzDict& out_dict) override
    {
        std::wstring val;
        in_dict.val(MS_KEY_PATH, val);
        const std::string s( val.begin(), val.end() );
        // std::cout << " Done a task! \n";
        return MS_OK;
        // return MalwareScanLayer::start(in_dict);
    }
};


namespace{
    namespace Internal{
        ms_rc getScanConfig(AxzDict &dscnConfig){
            // dscnConfig = AxzScanConfig::instance()->getConfig();
            return MS_OK;
        }

        ms_rc buildCheckHashHeader(headers_t &header, const std::wstring &file_path){
            std::string apiKey      = "2c43153e400f78ccd178d47f17e4ae63";
            std::string contentType = "application/octet-stream";
            std::string userAgent   = "trile";
            std::string connection  = "Keep-Alive";

            header["user_agent"] = userAgent;
            header["rule"] = contentType;
            header["apikey"] = apiKey;
            header["filename"] = StringUtils::toString(file_path);

            return MS_OK;
        }
    }
}
#endif