#ifndef __ms_layer_h__
#define __ms_layer_h__

#include "ms_return_codes.h"
#include "ms_layers_abstract.h"
#include "ms_defines.h"
#include "ms_slot.h"
#include "3rdparty/ezcurl/EzCurl.h"
#include "utils/string_utils.h"
#include "utils/file_utils.h"
#include "3rdparty/msdict/ms_json.h"

#include "ms_localhash_manager.h"
#include <iostream>
#include <thread>
#include <fstream>
#include <chrono>

// #ifndef _WIN32
//     #include <axz_scu_file.h>
// #endif
using namespace Curl;
using namespace std::chrono_literals;

namespace
{
namespace Internal{
    enum type{GET, POST};
    ms_rc requestAPI(std::wstring file_path, std::string reqUrl, std::ifstream& reqBody, std::stringstream& responseBody, type t);
    ms_rc getScanConfig(MSDict &dscnConfig); 
    ms_rc buildHeader(headers_t &header, const std::wstring &file_path);
    ms_rc checkDataId(const std::wstring& dataId, MSDict& result);
}
};

class VerifyFile             final : public MalwareScanLayer
{
public:
    VerifyFile() {}

    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        //not implement for sot 
        MalwareScanLayer::start(in_dict, out_dict);
    }
};

class ManifestLayer             final : public MalwareScanLayer
{
public:
    ManifestLayer() {}

    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        //not implement for sot 
        MalwareScanLayer::start(in_dict, out_dict);
    }
};

class CDRLayer                  final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        //not implement for sot
        return MalwareScanLayer::start(in_dict, out_dict);
    }
};

class CaculateHashLayer         final : public MalwareScanLayer
{
private: 
    std::shared_ptr<Slot> _calculateHashSlot;
public:
    CaculateHashLayer(ms_ll _limitTotalSize){
        _calculateHashSlot = std::make_shared<Slot>(_limitTotalSize, MS_THREAD_COUNT);
    } 
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;
        std::wstring file_path;
        in_dict.val(MS_KEY_PATH, file_path);
        size_t fileSize;
        FileUtils::fileSize(file_path, fileSize);
        // file_path = L"/home/trile/Documents/test.sh";

        std::wstring sha256;
        _calculateHashSlot->waitUntilSlotAvailable(fileSize, file_path);
        std::ifstream is = FileUtils::getContent(file_path, rc);
        FileUtils::calculateHash(is, sha256);
        _calculateHashSlot->finishATask(fileSize, file_path);

        MSDict param = std::move(in_dict);
        param.add(MS_KEY_HASH, sha256);

        return MalwareScanLayer::start(param, out_dict);
    }
};

class LocalHashLayer            final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;
        std::wstring file_path;
        in_dict.val(MS_KEY_PATH, file_path);
        
        std::wstring sha256;
        in_dict.val(MS_KEY_HASH, sha256);

        // std::cout << StringUtils::toString(file_path) << " === " << StringUtils::toString(sha256) << std::endl;
        std::wstring result;
        if( MS_SUCCESS(LocalHashManager::instance()->queryLocalHash(sha256, result)) ){
            std::cout << "Get a file from local DB" << std::endl;
            MSJson::deserialize(result, out_dict);
            return MS_OK;
        }
        return MalwareScanLayer::start(std::move(in_dict), out_dict);
    }
};

class ServerHashLayer           final : public MalwareScanLayer
{
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        
        std::wstring file_path;
        in_dict.val(MS_KEY_PATH, file_path);
        std::wstring sha256;
        in_dict.val(MS_KEY_HASH, sha256);

        std::ifstream requestBody;
        std::stringstream responseBody;
        std::string server = "https://api.metadefender.com:443/v4/hash/";
        // auto requestType = CurlRetry::CallOrigin::hash;
        std::string reqUrl = server + StringUtils::toString(sha256);

        if(MS_FAILED ( Internal::requestAPI(file_path, reqUrl, requestBody, responseBody, Internal::type::GET) )){
            return MS_ERROR_ABORTED;
        }

        MSDict responseDict;
        if (  MS_FAILED(MSJson::deserialize( StringUtils::toWideString(responseBody.str()), responseDict))){
            return MS_ERROR_RANGE_JSON;
        }
        MSDict errorDict;        
        int errorCode;

        if( MS_SUCCESS( responseDict.val(MS_KEY_ERROR, errorDict)) && MS_SUCCESS(errorDict.val(MS_KEY_CODE, errorCode))){
            switch (errorCode)
            {
            case 404003:
                return MalwareScanLayer::start(in_dict, out_dict);
                break;
            default:
                break;
            }
        }

        out_dict = responseDict;
        // if( Internal::saveLocalHash(sha256, StringUtils::toWideString(responseBody.str())) ){
        //     std::cout << "Save " << StringUtils::toString(sha256) << " on local db" << std::endl;
        // }    
        if( MS_SUCCESS (LocalHashManager::instance()->saveLocalHash(sha256, StringUtils::toWideString(responseBody.str())))){
            std::cout << "Save " << StringUtils::toString(sha256) << " on local db" << std::endl;
        }
        return MS_OK;
    }
};

class UploadFileLayer           final : public MalwareScanLayer
{
private: 
    std::shared_ptr<Slot> _uploadFileSlot;
public:
    UploadFileLayer(ms_ll _limitTotalSize){
        _uploadFileSlot = std::make_shared<Slot>(_limitTotalSize, MS_MAX_ALLOWED_UPLOAD_THREAD);
    } 
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;
        std::wstring file_path;
        in_dict.val(MS_KEY_PATH, file_path);
        std::wstring sha256;
        in_dict.val(MS_KEY_HASH, sha256);
        ms_ll fileSize = 100;

        std::stringstream responseBody;
        std::string reqUrl = "https://api.metadefender.com:443/v4/file";
        // auto requestType = CurlRetry::CallOrigin::hash;
        std::ifstream body = FileUtils::getContent(file_path, rc);
        
        _uploadFileSlot->waitUntilSlotAvailable(fileSize, file_path);
        if( MS_FAILED ( Internal::requestAPI(file_path, reqUrl, body, responseBody, Internal::type::POST) ) ){
            return MS_ERROR_ABORTED;
        }
        _uploadFileSlot->finishATask(fileSize, file_path);

        MSDict responseDict;
        if (  MS_FAILED(MSJson::deserialize( StringUtils::toWideString(responseBody.str()), responseDict))){
            return MS_ERROR_RANGE_JSON;
        }
        MSDict errorDict;        
        int errorCode;

        if( MS_SUCCESS( responseDict.val(MS_KEY_ERROR, errorDict)) && MS_SUCCESS(errorDict.val(MS_KEY_CODE, errorCode))){
            return MS_ERROR_ABORTED;
        }

        // out_dict = responseDict;
        MSDict param = std::move(in_dict);
        param.add(MS_KEY_UPLOAD_RESPONSE, responseDict);
        return MalwareScanLayer::start(param, out_dict);
    }
};

class QueryResultLayer          final : public MalwareScanLayer{
public:
    ms_rc start(const MSDict& in_dict, MSDict& out_dict) override
    {
        ms_rc rc = MS_OK;
        MSDict scanFileResults, uploadResponseDict;
        std::wstring dataId;
        if(MS_FAILED ( rc = in_dict.val(MS_KEY_UPLOAD_RESPONSE, uploadResponseDict) )
        || MS_FAILED ( rc = uploadResponseDict.val(MS_KEY_DATA_ID, dataId))){
            return rc;
        }
        std::chrono::nanoseconds recheckResultWait = 10ms;
        while (true) {
            if(MS_FAILED ( Internal::checkDataId(dataId, scanFileResults))){
                break;
            }
            
            // if (scanFileResults.count("infect_error") > 0) break;

            // // Data Id not found Response will be 200 with a json key of the data_id
            // // and "Not Found"
            // auto dataIdKey = scanFileResults[dataId].string_value();

            // if (dataIdKey == "Not Found") {
            //     scanFileResults =
            //         CurlRetry::CreateErrorJson(0, 0, "DataID not found").object_items();
            //     break;
            // }

            auto progressPercentage =
                scanFileResults[L"scan_results"][L"progress_percentage"].intVal();

            if (progressPercentage >= 100.0) {
                std::wstring fileHash = scanFileResults[L"file_info"][L"sha256"].stringVal();

                FileInfo fileResults;
                fileResults.hash = StringUtils::toString(fileHash);
                std::wstring scanResultStr;
                if ( MS_FAILED ( rc = MSJson::serialize(scanFileResults, scanResultStr))){
                    return rc;
                }   
                fileResults.scanResults =  StringUtils::toString(scanResultStr);
                // 3 - Failed, 10 - Not Scanned, 19 - Cancelled
                std::set<int> failedCodes = {3, 10, 19};
                int conclusion =
                    scanFileResults[L"scan_results"][L"scan_all_result_i"].intVal();
                if (failedCodes.find(conclusion) == failedCodes.end()) {
                    // ScanResultsTable::I()->SaveScanResults(fileResults);
                    out_dict = scanFileResults;
                    std::cout << "Save result by " << fileResults.scanResults << std::endl;
                }
                
                break;
            }

            recheckResultWait *= 2;
            if (recheckResultWait > 2s) recheckResultWait = 2s;

            std::this_thread::sleep_for(recheckResultWait);
        }

        return rc;
    }
};

namespace{
    namespace Internal{
        ms_rc requestAPI(std::wstring file_path, std::string reqUrl, std::ifstream &reqBody, std::stringstream &responseBody, type t)
        {
            ms_rc rc = MS_OK;
            headers_t reqHead;
            Internal::buildHeader(reqHead, file_path);
            std::string reqType = (t == type::GET) ? "GET" : "POST";
            httpRequest req = {
                reqType,
                reqUrl,
                reqBody,
                reqHead,
                responseBody,
                CookieOption{CookieOption::Load}};

            std::string response;
            uint32_t iteration = 1;
            while (true) {
                responseBody.str("");
                CurlLib::getInstance()->Request(req);
                response = responseBody.str();
                std::cout << StringUtils::toString(file_path) << " Server response " << response << std::endl;
                break;
            }
            return rc;
        }
        ms_rc getScanConfig(MSDict &dscnConfig){
            // dscnConfig = AxzScanConfig::instance()->getConfig();
            return MS_OK;
        }
        ms_rc buildHeader(headers_t &header, const std::wstring &file_path){
            // std::string apiKey      = "2c43153e400f78ccd178d47f17e4ae63";
            std::string apiKey      = "2acdcdfa5857b2aa585c2e3d47f2096c";
            std::string contentType = "application/octet-stream";
            std::string userAgent   = "trile";
            std::string connection  = "Keep-Alive";

            header["user_agent"] = userAgent;
            // header["rule"] = contentType;
            header["content-type"] = contentType;
            header["apikey"] = apiKey;
            header["filename"] = StringUtils::toString(file_path);

            return MS_OK;
        }
        ms_rc checkDataId(const std::wstring &dataId, MSDict &result)
        {
            ms_rc rc = MS_OK;
            std::ifstream requestBody;
            std::stringstream responseBody;
            std::string reqUrl = "https://api.metadefender.com:443/v4/file/";
            reqUrl += StringUtils::toString(dataId);
            if (MS_FAILED ( rc = requestAPI(dataId, reqUrl, requestBody, responseBody, type::GET) )){
                return rc;
            }

            if (  MS_FAILED(MSJson::deserialize( StringUtils::toWideString(responseBody.str()), result))){
                return MS_ERROR_RANGE_JSON;
            }
            MSDict errorDict;        
            int errorCode;

            if( MS_SUCCESS( result.val(MS_KEY_ERROR, errorDict)) && MS_SUCCESS(errorDict.val(MS_KEY_CODE, errorCode))){
                return MS_ERROR_ABORTED;
            }

            return rc;
        }
    }
}
#endif