#ifndef __file_utils_calhash_h__
#define __file_utils_calhash_h__

#include "../../ms_return_codes.h"
#include <cstdint>
#include <memory>
#include "openssl/evp.h"
#include "openssl/hmac.h"
#include <fstream>

#define MS_BUFFER_SZE  512

enum MSUtilsHashType: std::uint8_t
{
	MS_SHA_256 = 1,
	MS_SHA_384,
	MS_SHA_512,
	MS_MD_4,
	MS_MD_5
};

class _ms_hash_impl
{
public:    
    const EVP_MD* md;

public:
    _ms_hash_impl( MSUtilsHashType in_hash_type )
    {        
        OpenSSL_add_all_digests();
        this->md = EVP_get_digestbyname( this->_getName( in_hash_type ) );
    }

    virtual ~_ms_hash_impl() {        
    }

private:
    const char* _getName( MSUtilsHashType in_hash_type )
    {
        switch ( in_hash_type )
        {
            case MS_SHA_256:   return "SHA256";
            case MS_SHA_384:   return "SHA384";
            case MS_SHA_512:   return "SHA512";
            case MS_MD_4:      return "MD4";
            case MS_MD_5:      return "MD5";
        }
        return nullptr;
    }
};
class _ms_shamd_impl: public _ms_hash_impl
{
public:
    EVP_MD_CTX* mdCtx;

public:
    _ms_shamd_impl( MSUtilsHashType in_hash_type )
        : _ms_hash_impl( in_hash_type )
        , mdCtx( EVP_MD_CTX_create() )
    {}

    virtual ~_ms_shamd_impl()
    {
        if ( this->mdCtx )
        {
            EVP_MD_CTX_destroy( this->mdCtx );
        }
        EVP_cleanup();
    }
};

class  MSUtilsShamd
{
public:
    MSUtilsShamd( MSUtilsHashType in_hash_type ) : m_impl( std::make_shared<_ms_shamd_impl>(in_hash_type) ) 
    {
        
    }
    ~MSUtilsShamd(){}
    
    ms_rc hexCodeOfFile( std::ifstream& in_content, std::wstring& out_code){
    {       
        _ms_shamd_impl* impl = ( _ms_shamd_impl* )m_impl.get();
        if ( !impl || !impl->mdCtx || !impl->md )
        {
            return MS_ERROR_MEMORY_DRAINED;
        }

        ms_rc rc = MS_OK;    

        do
        {
            EVP_DigestInit_ex( impl->mdCtx, impl->md, nullptr );

            unsigned int code_len = EVP_MD_CTX_size( impl->mdCtx );
            if ( code_len <= 0 )
            {
                rc = MS_ERROR_NOT_READY;
                break;
            }

            std::shared_ptr<unsigned char> code(new unsigned char[code_len], std::default_delete<unsigned char[]>());
            if ( !code )
            {
                rc = MS_ERROR_MEMORY_DRAINED;
                break;
            }
            if ( !in_content.is_open() )
            {
                rc = MS_ERROR_ACCESS_DENIED;
                break;
            }                
            in_content.seekg( 0, in_content.end );
            size_t dat_len = in_content.tellg();
            in_content.seekg( 0, in_content.beg );

            unsigned char* buffer = new unsigned char[dat_len];
            if ( !buffer )
            {
                rc = MS_ERROR_MEMORY_DRAINED;
                break;
            }

            in_content.read( ( char* )buffer, dat_len );               

            EVP_DigestUpdate( impl->mdCtx, buffer, dat_len );                       
            EVP_DigestFinal_ex( impl->mdCtx, code.get(), &code_len );
            if ( buffer )
            {
                delete[] buffer;
            } 
            
            out_code.resize( code_len * 2 );
            auto p_out = ( wchar_t* )out_code.data();
            for( unsigned int i = 0 ; i < code_len ; i++ )
            {
                swprintf( p_out + i * 2, 3, L"%02X", code.get()[i] );        
            }
        } while( 0 );
        
        return rc;
    }


    }

private:    
    std::shared_ptr<_ms_hash_impl> m_impl;
};

#endif