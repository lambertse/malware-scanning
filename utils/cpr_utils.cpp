#include "cpr_utils.h"
#include "ms_logger.h"
#include "ms_labels.h"
#include "string_utils.h"
#include <thread>
#ifdef _WIN32
    #include <xplat/utils/Logging.h>
    #include <Common/utils/RegUtil.h>
    #include <Common/utils/LocaleUtil.h>
    #include <shared/features/malware_scan/MSLogger.h>
#endif

namespace
{
namespace Internal
{
    enum RetryType{
        WAIT_LIMIT_RESET = 1,
        WAIT_LIMIT_IN_MINUTE = 2,
        NORMAL_WAIT = 3
    };

    ms_bool isStatusCode200s(const ms_int& code){
        return code / 100 == 2;
    }
    ms_bool isStatusCodeError(const ms_int& code){
        return code / 100 == 4 || code / 100 == 5;
    }
	ms_bool isRetryErrorCode(const cpr::ErrorCode& code) {
    if (    code == cpr::ErrorCode::CONNECTION_FAILURE      ||
            code == cpr::ErrorCode::NETWORK_SEND_FAILURE    ||
            code == cpr::ErrorCode::NETWORK_RECEIVE_ERROR   ||
            code == cpr::ErrorCode::OPERATION_TIMEDOUT      ||
            code == cpr::ErrorCode::SSL_CONNECT_ERROR       ||
            code == cpr::ErrorCode::EMPTY_RESPONSE          ||
            code == cpr::ErrorCode::HOST_RESOLUTION_FAILURE)
            return true;
    return false;
	}
} 
}

ms_bool BaseCprUtils::ShouldRetry(const cpr::Response &response, uint32_t &iteration, const int &timeToCancelRetry)
{
using namespace std;
using namespace std::chrono;
using namespace std::chrono_literals;
unsigned int maxRetry = 7;

#ifdef _WIN32
    using namespace owc::malware_scan;
    static const std::wstring featureRegKey =
        TEXT("Software\\OPSWAT\\GEARS Client\\features\\malware-scan");
	DWORD dw = 0;
    if (RegUtil::ReadRegVal<DWORD>(HKEY_LOCAL_MACHINE, featureRegKey.c_str(),
                                                                    L"max_retry_count", &dw)) {
            MS_LOGGER_INFO("Set max retry count to: {}", dw);
            maxRetry = dw;
    }
#endif
    // if (++iteration == 1) 
    //     return true;  // always retry first time
    if(!ShouldRetrySpecific() ||
        ( !Internal::isStatusCodeError(response.status_code) && response.error.code == cpr::ErrorCode::OK )){
        return false;
    }

    time_t waitDuration = 0;
    std::srand(static_cast<int>(time(NULL)));
    MSDict responseDict;
    MSJson::deserialize(StringUtils::toWideString(response.text), responseDict);
    int retry = 0;
    if ( response.error.code == cpr::ErrorCode::UNSUPPORTED_PROTOCOL    ||
         response.error.code == cpr::ErrorCode::INVALID_URL_FORMAT)         // for the same logic with macOS
        return false;
    else if (Internal::isRetryErrorCode(response.error.code)) {
    	retry = Internal::NORMAL_WAIT;
    }
    MSDict errorDict;
    // successful curl so check for http status retry
    if (response.error.code == cpr::ErrorCode::OK) {
		int code;
		switch (response.status_code) {
		case 408:
			retry = Internal::WAIT_LIMIT_IN_MINUTE;
			break;
		case 429:
			code = responseDict[MS_KEY_ERROR][MS_KEY_CODE].intVal();
			switch (code) {
                case 429000:
                    retry = Internal::WAIT_LIMIT_RESET;
                    break;
                case 429001:
                case 429002:
                    retry = Internal::WAIT_LIMIT_IN_MINUTE;
                    break;
                }
            break;
		case 500:  // retry only for MD Core
			if (MS_FAILED (responseDict.val(MS_KEY_ERROR, errorDict))) {
				retry = Internal::NORMAL_WAIT;
			}
			break;
		case 503:  // retry only for MD Core
			if (MS_FAILED (responseDict.val(MS_KEY_ERROR, errorDict))) {
				retry = Internal::NORMAL_WAIT;
			}
			break;
        case 504: // Gateway Timeout
			retry = Internal::NORMAL_WAIT;
            break;
		default:
			return false;  // not in case -> cancel retry
		}
	}

	switch (retry) {
	case Internal::WAIT_LIMIT_RESET : {  // TODO: get in response headers
		auto resetTime = atoi(response.header.at("X-RateLimit-Reset-In").c_str());
		constexpr int MaxRetryTime = 120;
		if (resetTime <= MaxRetryTime) {
			waitDuration = resetTime;
		}
		else {
			return false;
		}
	} break;
	case Internal::WAIT_LIMIT_IN_MINUTE: {
		waitDuration = 60 + rand() % 60 + 1;
		auto retryTimePoint = std::time(0) + waitDuration;
		if (timeToCancelRetry > 0) {
			if (retryTimePoint > timeToCancelRetry) {
				return false;
			}
		}
	} break;
	case Internal::NORMAL_WAIT:
		if (++iteration > maxRetry)  // current set overallMaxTime = 4 mins, maybe change
							        // when overallMaxTime changed
		{
			MS_LOGGER_INFO("Give up retrying the request");
			return false;
		}
		waitDuration = std::min(120, (int)std::pow(2, iteration));
		break;
	}

	if (waitDuration > 0) {
        auto errMsg =   "Invalid response: " + response.error.message +
                        ". Error code: " + std::to_string((int)response.error.code) +
                        ". HTTP code: " + std::to_string(response.status_code) +
                        ". Response: " + response.text;
		auto sleepMsg = "Sleep and retry for request. Wait time: " + std::to_string(waitDuration) +
                        " seconds. Retrying type: " + std::to_string(retry);
        MS_LOGGER_INFO(errMsg);
        MS_LOGGER_INFO(sleepMsg);
		std::this_thread::sleep_for(chrono::seconds{ waitDuration });
		MS_LOGGER_INFO("Continue for sending request");
		return true;
	}
	else {
		return false;
	}
}
MSDict BaseCprUtils::ShouldReportError(const cpr::Response &response)
{
    if( Internal::isRetryErrorCode(response.error.code) ){
        return CreateErrorDict( response.status_code, int(response.error.code), StringUtils::toWideString(response.error.message) );
    }
    else if (response.error.code == cpr::ErrorCode::OK){
        if( response.status_code == 500 /*server error*/){
            MS_LOGGER_INFO("{} HTTP Code: {}, Error Code: {}, Server response: {}",   MS_LABEL_CPR, response.status_code, int(response.error.code), response.text);
            return CreateErrorDict(response.status_code, int(response.error.code), MS_MSG_UNABLE_REACH_SERVER);
        }
        else if( response.status_code == 429 && int(response.error.code) == 429000/*reach limit*/){
            return CreateErrorDict(response.status_code, int(response.error.code), StringUtils::toWideString(response.error.message));
        }
        //pass to specific call origin to handle
        return ShouldReportSpecificError(response);
    }
    return CreateErrorDict(response.status_code, int(response.error.code), StringUtils::toWideString(response.error.message));
}

MSDict BaseCprUtils::CreateErrorDict(int httpCode, int curlErrorCode, std::wstring errMsg)
{
    return ms_dict_object{
        { MS_KEY_INFECT_ERR, ms_dict_object { 
                                { MS_KEY_HTTP_CODE,         httpCode },
                                { MS_KEY_CURL_ERROR_CODE,   curlErrorCode },
                                { MS_KEY_ERROR_MSG,         errMsg }
                            }
        }
    };
}

MSDict BaseCprUtils::ShouldReportSpecificError(const cpr::Response &response)
{
    MSDict responseDict;
    MSJson::deserialize(StringUtils::toWideString(response.text), responseDict);

    if (response.text.empty()) {
        return CreateErrorDict(response.status_code, int(response.error.code), L"Empty response");
    }
    else if (!Internal::isStatusCode200s(response.status_code)) {
        ms_wstring err;
        MSDict errorDict,errMsgDict;
        ms_int code;
        if( MS_FAILED(responseDict.val(MS_KEY_ERROR, errorDict)) ||
            MS_FAILED(errorDict.val(MS_KEY_CODE, code))){
            return MSDict(MSDictType::NUL);
        }
        if( response.status_code == 400 ){
            if ((400000 <= code && code < 400140) || code > 400156) {
                return CreateErrorDict(response.status_code, int(response.error.code), L"No upload errors");
            }
        }
        else if(MS_SUCCESS(errorDict.val(MS_KEY_MESSAGES, errMsgDict)) &&
                errMsgDict.isArray()){
            return CreateErrorDict(response.status_code, int(response.error.code), errMsgDict.size() == 0 ? L"Error messages empty" : errMsgDict[0].stringVal());
        }
        else if(MS_SUCCESS(responseDict.val(MS_KEY_ERR, err))){
            return CreateErrorDict(response.status_code, int(response.error.code), err);
        }
        auto errMsg =   "Error code: " + std::to_string(int(response.error.code)) 
                        + ". HTTP Code: " + std::to_string(response.status_code)
                        + ". Server response: " + response.text;
        MS_LOGGER_INFO(errMsg);
        return CreateErrorDict(response.status_code, int(response.error.code), L"Some errors occur. See details in log files");
    }
    else {
        return MSDict(MSDictType::NUL);
    }
}
