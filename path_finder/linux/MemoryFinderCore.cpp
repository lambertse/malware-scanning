#include "MemoryFinderCore.h"
// #include <3rdpartycore/Filesystem.h>
// #include <3rdpartyjson/Json.h>

#include "axz_utils_bridge.h"
#include "axz_methods.h"
#include "axz_keys.h"
#include "axz_defines.h"
#include "axz_error_codes.h"

#include <dirent.h>

#include <unistd.h>
#include <fstream>
#include <iostream>
#include <unordered_set>
#include "../../utils/string_utils.h"

//#include "owccore/Process.h"
// #include "process_finder/ProcessFinder.h"

// #pragma comment(lib, "Wtsapi32.lib")
namespace fs = std::experimental::filesystem;

namespace
{
namespace Internal{
    bool is_number(const std::string& s);

    std::string getExecutablePath(const std::string& pidPath);

    axz_rc queryRunningProcesses( std::unordered_set<std::wstring>& pack, owc::finder::FoundCallback foundCallback);

    axz_rc querryRunningServices( std::unordered_set<std::wstring>& pack, owc::finder::FoundCallback foundCallback);
}
}

namespace owc {
namespace finder {
static void runningProcessExplore(
  finder::Options& options, finder::FoundCallback foundCallback,
  finder::FinishedCallback finishedCallback,
  std::function<void()> conditionCheck = nullptr) {
  // exploreSuccessful flag support to case run process finder x64 failed
  bool exploreSuccessful = true;

  std::unordered_set<std::wstring> pack;

  Internal::queryRunningProcesses(pack, foundCallback);
  Internal::querryRunningServices(pack, foundCallback);
  // foundCallback(std::make_shared<owc::finder::FoundPathInfo>(fs::u8path("/home/trile/Downloads/Win11_22H2_English_x64v2.iso")));
  // foundCallback(std::make_shared<owc::finder::FoundPathInfo>(fs::u8path("/home/lambert/Downloads/testvirus")));
  foundCallback(std::make_shared<owc::finder::FoundPathInfo>(fs::u8path("/home/trile/Downloads/testvirus")));

  if(finishedCallback){
    finishedCallback();
  }
}

MemoryFinderCore::MemoryFinderCore() {
  type_ = finder::Type::memory;
  multiPath_.push_back("Memory");
}

MemoryFinderCore::MemoryFinderCore(std::shared_ptr<std::recursive_mutex> mtx)
    : PathFinder{mtx} {
  type_ = finder::Type::memory;
  multiPath_.push_back("Memory");
}

MemoryFinderCore::~MemoryFinderCore() {}

LargeSize MemoryFinderCore::getTotalFileCount() {
  size_t fileTotal = 0;
  runningProcessExplore(
      options_, [&fileTotal](finder::FoundPathConstInfoPtr) { ++fileTotal; },
      nullptr, std::bind(&MemoryFinderCore::checkState, this));
  return fileTotal;
}

void MemoryFinderCore::getTotalFileCount(
    std::function<void(LargeSize totalFiles)> callback) {
  if (!callback) {
    return;
  }
  auto asyncThread = std::thread{[this, callback]() {
    FINDER_LOGGER_DEBUG("Starting thread: ", std::this_thread::get_id());
    callback(getTotalFileCount());
    FINDER_LOGGER_DEBUG("Exit thread: ", std::this_thread::get_id());
  }};

  // join thread if finder is erased
  asyncThreads_.push_back(std::move(asyncThread));
}

void MemoryFinderCore::explorePath(const Path& /*path*/) {
  runningProcessExplore(options_, foundCallback_, finishedCallback_,
                        std::bind(&MemoryFinderCore::checkState, this));
}
}  // namespace finder
}  // namespace owc


namespace 
{
namespace Internal
{
    bool is_number(const std::string& s)
    {
        return !s.empty() && std::find_if(s.begin(), 
            s.end(), [](unsigned char c) { return !std::isdigit(c); }) == s.end();
    }

    std::string getExecutablePath(const std::string& pidPath)
    {
        char buf[1024] { '\0' };

        size_t nbytes = readlink(pidPath.c_str(), buf, 1024);
        if (nbytes == -1) {
            // TODO: Handle error here
            //printf("\n%s: %d\n",pidPath.c_str(), errno);
            return "";
        }

        return buf;
    }

    axz_rc queryRunningProcesses( std::unordered_set<std::wstring>& pack, owc::finder::FoundCallback foundCallback)
    {
        axz_rc ret = AXZ_OK;

        std::string procPath { "/proc/" };

        struct dirent *de;

        DIR *dr = opendir(procPath.c_str());

        if (dr == NULL)  // opendir returns NULL if couldn't open directory 
        {
            return AXZ_ERROR_ABORTED; 
        }

        while ((de = readdir(dr)) != NULL) 
        {
            std::string dirName {de->d_name};
            if (de->d_type == DT_DIR && dirName != "." && dirName != "..")
            {
                if (is_number(dirName)) 
                {
                    std::string resolvedLink = getExecutablePath(procPath + dirName + "/exe");
                    std::wstring resolvedLinkWstr = StringUtils::toWideString(resolvedLink);
                    if (!resolvedLink.empty() &&
                        pack.find(resolvedLinkWstr) == pack.end()) {
                      pack.insert(resolvedLinkWstr);
                      foundCallback(std::make_shared<owc::finder::FoundPathInfo>(fs::u8path(resolvedLink)));
                    }
                    
                }
            }
        }

        closedir(dr);  

        return ret;
    }

    axz_rc querryRunningServices( std::unordered_set<std::wstring>& pack, owc::finder::FoundCallback foundCallback)
    {
        axz_rc ret = AXZ_OK;

        AxzDict out_result;
        
        AxzUtilsBridge bridge;
        out_result = bridge.handle( axz_dict_object{ 
            { AXZ_KEY_MID, AXZ_MID_QUERY_SERVICE_STATE } } ); 

        AxzDict detected_processes{AxzDictType::ARRAY};
        if ( AXZ_FAILED( out_result.val(L"detected_processes", detected_processes) ))
            return AXZ_ERROR_JSON_KEY_MISSED;

        AxzDict runningProcess {AxzDictType::ARRAY};
        for (int i = 0; i < detected_processes.size(); i++) 
        {
            std::wstring type;
            if (AXZ_SUCCESS(detected_processes[i].val(L"type", type)) && type == L"service")
            {
                std::wstring state;
                if (AXZ_SUCCESS(detected_processes[i].val(L"state", state)) && state == L"running") 
                {
                    std::wstring path;
                    if (AXZ_SUCCESS(detected_processes[i].val(L"path", path)) && 
                        pack.find(path) == pack.end())
                    {
                        pack.insert(path);
                        foundCallback(std::make_shared<owc::finder::FoundPathInfo>(fs::u8path(path)));

                    }
                }
            }
        }

        return ret;
    }
}
}