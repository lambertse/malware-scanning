#include "RegularFinderCore.h"
#include "axz_scu_string.h"
#include "axz_keys.h"
#include "axz_dict.h"
//#include <owccore/Logging.h>

#include <atomic>
#include <iostream>
#include <queue>
#include <ftw.h>
#include <fstream>
namespace fs = std::experimental::filesystem;
namespace
{
namespace Internal
{
    axz_string readFileInDir( const axz_string& in_path )
    {
        // TODO: avoid using static variable, need to enhance here
        // WARNING: not thread safe function

        static axz_string paths;
        static axz_string seperator {";"};

        paths.clear();

        auto display_info = [](const char *fpath, const struct stat *sb, int tflag, struct FTW *ftwbuf) -> int {
            
            if (tflag == FTW_F)
            {
                axz_string path { fpath };

                paths += path + seperator;
            }

            return 0;           /* To tell nftw() to continue */
        };

        if (nftw(in_path.c_str(), display_info, 20, FTW_PHYS) == -1) 
        {
            perror("nftw");
        }

        return paths;
    }
}
}

namespace owc {
namespace finder {

static void linuxExplore(
    const Path& path, const finder::Options& options,
    FoundCallback fileFoundCallback,
    finder::FinishedCallback finishedCallback){

      axz_string pathStr = path.string();

      axz_string files_str =  Internal::readFileInDir(pathStr);

      std::stringstream ss(files_str);
      std::string token;
      while (std::getline(ss, token, ';'))
      {
        // std::cout << "Found " << token << std::endl;
        fileFoundCallback(std::make_shared<owc::finder::FoundPathInfo>(fs::u8path(token)));
      }
      if(finishedCallback){
      finishedCallback();
      }
    }
RegularFinderCore::RegularFinderCore() { type_ = finder::Type::regular; }

RegularFinderCore::RegularFinderCore(std::shared_ptr<std::recursive_mutex> mtx)
    : PathFinder{mtx} {
  type_ = finder::Type::regular;
}

RegularFinderCore::~RegularFinderCore() {}

LargeSize RegularFinderCore::getTotalFileCount() {
  std::atomic<LargeSize> totalFiles = 0;
  auto threadCount = std::thread::hardware_concurrency() / 2;
  auto opt = options_;
  opt.file_only = true;
  // auto waittingToFindPathsQ = std::make_shared<Queue<finder::Path>>();
  // queues_.emplace(waittingToFindPathsQ);
  for (auto& path : multiPath_) {
    linuxExplore(
        path, opt,
        [&totalFiles](finder::FoundPathConstInfoPtr) { ++totalFiles; }, nullptr);
  }

  std::lock_guard lock(mtx_);
  // queues_.erase(waittingToFindPathsQ);
  return totalFiles;
}

LargeSize RegularFinderCore::getTotalFileCount(const Path& path,
                                               const Options& options,
                                               uint32_t threadCount) {
  std::atomic<size_t> totalFiles = 0;
  // auto waittingToFindPathsQ = std::make_shared<Queue<finder::Path>>();
  // queues_.emplace(waittingToFindPathsQ);
  linuxExplore(
      path, options,
      [&totalFiles](finder::FoundPathConstInfoPtr) { totalFiles++; }, nullptr);
  std::lock_guard lock(mtx_);
  // queues_.erase(waittingToFindPathsQ);
  return totalFiles;
}

void RegularFinderCore::getTotalFileCount(FileCountCallback callback) {
  if (!callback) {
    return;
  }
  asyncThreads_.push_back(std::thread{[callback, this]() {
    //FINDER_LOGGER_DEBUG("Starting thread: ", std::this_thread::get_id());
    if (callback) {
      callback(getTotalFileCount());
    }
    //FINDER_LOGGER_DEBUG("Exit thread: ", std::this_thread::get_id());
  }});
}

bool RegularFinderCore::accesible(const Path& path, int& error) {
  std::error_code ec;
  if (fs::exists(path, ec)) {
    return true;
  }
  error = ec.value();
  return false;
}

void RegularFinderCore::stop() {
  // {
  //   std::lock_guard lock(mtx_);
  //   for (auto& queue : queues_) {
  //     queue->close();
  //   }
  // }
  PathFinder::stop();
}

void RegularFinderCore::explorePath(const Path& path) {
  // auto waittingToFindPathsQ = std::make_shared<Queue<finder::Path>>();
  // queues_.emplace(waittingToFindPathsQ);
  linuxExplore(
      path, options_,
      std::bind(&RegularFinderCore::onFileFound, this, std::placeholders::_1), finishedCallback_);
  std::lock_guard lock(mtx_);
  // queues_.erase(waittingToFindPathsQ);
}
}  // namespace finder
}  // namespace owc
