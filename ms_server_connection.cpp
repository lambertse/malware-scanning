#include "ms_server_connection.h"
#include "utils/string_utils.h"
#include "utils/cpr_template_utils.h"

struct ApiVersion {
    int major, minor, revision, build;

    ApiVersion(ms_string versionStr) {
        sscanf(versionStr.c_str(), "%d.%d.%d.%d", &major, &minor, &revision,
            &build);
    }
    //Check if it is core version >= 4.16.2.0
    bool isNewCoreVersion() {
        if (major < 4) return false;
        if (major == 4 && minor < 16) return false;
        if (major == 4 && minor == 16 && revision < 2) return false;
        return true;
    }
};

namespace
{
namespace Internal
{
    enum RequestType { GET, POST};
    ms_rc requestAPI(const MSDict& reqHeader, ms_string reqUrl, MSDict& responseDict, RequestType t);
}
}

ms_rc MDServerConnection::generateReqHeader(const MSDict& config, MSDict& desRqHeader, MSDict& additionalInfo){
    ms_rc rc = MS_OK;
    MSDict availScanner, defaultScanner;
    if(MS_FAILED ( rc = config.val(MS_KEY_AVAIL_SCANNERS, availScanner))){
        if( !availScanner.isArray() || !availScanner.size() ){
            MS_LOGGER_ERROR("[engine] Generate request header failed, not exist scanner");
            return MS_ERROR_NON_EXISTENT_SCANNER;
        } 
    }
    defaultScanner = availScanner[0];
    ms_wstring tmp;
    MSJson::serialize(defaultScanner, tmp);
    MSDict scanRule;
    ms_wstring url, apiKey, user_agent, rule;
    ms_int serverType;
    if( MS_FAILED ( rc = defaultScanner.val(MS_KEY_URL, url))               ||
        MS_FAILED ( rc = defaultScanner.val(MS_KEY_API_KEY_CONFIG, apiKey)) ||
        MS_FAILED ( rc = defaultScanner.val(MS_KEY_SCAN_RULE, scanRule ))   ||
        MS_FAILED ( rc = defaultScanner.val(MS_KEY_TYPE, serverType) )){
        MS_LOGGER_ERROR("[engine] Generate request header failed, config is not valid");
        return rc;
    }
    if ( serverType == 1 && 
        ( MS_FAILED ( rc = scanRule.val(MS_KEY_USER_AGENT, user_agent) )  ||
            MS_FAILED ( rc = scanRule.val(MS_KEY_RULE, rule)))){
        MS_LOGGER_ERROR("[engine] Generate request header failed, config is not valid");
        return rc;   
    }
    additionalInfo = ms_dict_object{
        {   MS_KEY_URL             , url},
        {   MS_KEY_TYPE            , serverType},
        {   MS_KEY_RULE            , rule}
    };
    desRqHeader = ms_dict_object{
        {   MS_KEY_RULE,           rule},
        {   MS_KEY_USER_AGENT,     user_agent},
        {   MS_KEY_WORK_FLOW,      L""},
        {   MS_KEY_ARCHIVEPWD,     L""},
        // {   MS_KEY_API_KEY,        L"060c9a0e4ac20d28a12c1791428f39b0"},
        {   MS_KEY_API_KEY,        L"060c9a0e4ac20d28a12c1791428f39b0"},
        {   MS_KEY_CONTENT_TYPE,   L"application/octet-stream"},
        {   MS_KEY_ACCEPT,         L""},
        {   MS_KEY_EXPECT,         L""},
        {   MS_KEY_USER_HOST_NAME, L""},
        {   MS_KEY_SOURCE,         L""},
        {   MS_KEY_CONNECTION,     L"Keep-Alive"}};
    return rc;
}

ms_rc MDServerConnection::getApiVersion(const MSDict& reqHeader, const MSDict& inDict, MSDict& outDict){
    ms_rc rc = MS_OK;
    ms_wstring url;
    ms_int serverType;
    if( MS_FAILED (rc = inDict.val(MS_KEY_URL, url)) ||
        MS_FAILED (rc = inDict.val(MS_KEY_TYPE, serverType))){
            return rc;
    }
    cpr::Header header;
    if( !reqHeader.isObject() ){
        MS_LOGGER_ERROR("[layers] [internal] request header dict is not valid");
    }
    for( auto i : reqHeader.keys()){
        ms_wstring value;
        reqHeader.val(i, value);
        header[StringUtils::toString(i)] = StringUtils::toString(value);
    }

    ms_wstring reqUrl = serverType ? url + L"/version" : url + L"/status/version";
    cpr::Response response = cpr::Get(cpr::Url{StringUtils::toString(reqUrl)},  cpr::VerifySsl{false}, cpr::Header{header}, cpr::ConnectTimeout{10000}, cpr::Timeout{20000});
    MSDict responseDict;
    MSJson::deserialize(StringUtils::toWideString(response.text), responseDict);
    // TODO: handle MD Core v4 version 4.16.2 or older than
    {
        if (serverType == MDCore && response.status_code == 403) {
            outDict =  ms_dict_object{  {L"url", url},
                                        {L"connected", true},
                                        {L"error", L""},
                                        {L"version", L""}};
            return rc;
        }
    }
    // ENDTODO
    std::shared_ptr<GetAPIVersion> shouldReportErr = std::make_shared<GetAPIVersion>();
    MSDict errorDict = shouldReportErr->ShouldReportError(response);
    ms_wstring version;
    if( !errorDict.isNull() ||
        MS_FAILED( responseDict.val(MS_KEY_VERSION, version) ) ){
        version = L"-1";
    }

    outDict =  ms_dict_object{  {L"url", url},
                                {L"connected", true},
                                {L"error", L""},
                                {L"version", version}};
    return rc;
}

ms_rc MDServerConnection::getApiKeyInfo(const MSDict &reqHeader, const MSDict &inDict, MSDict &outDict)
{
    ms_rc rc = MS_OK;
    ms_wstring url;
    ms_int serverType;
    if( MS_FAILED (rc = inDict.val(MS_KEY_URL, url)) ||
        MS_FAILED (rc = inDict.val(MS_KEY_TYPE, serverType))){
            return rc;
    }
    cpr::Header header;
    if( !reqHeader.isObject() ){
        MS_LOGGER_ERROR("[layers] [internal] request header dict is not valid");
    }
    for( auto i : reqHeader.keys()){
        ms_wstring value;
        reqHeader.val(i, value);
        header[StringUtils::toString(i)] = StringUtils::toString(value);
    }
    ms_wstring reqUrl;
    if(serverType == MDServerType::MDCloud){
        if (url.find(L"/v2") == std::wstring::npos){
            reqUrl = url + L"/apikey";
        }
        else{
            reqUrl = url + L"/apikey/limits";
        }
    }else{
        reqUrl = url + L"/admin/license";
    }
    cpr::Response response = cpr::Get(cpr::Url{StringUtils::toString(reqUrl)},  cpr::VerifySsl{false}, cpr::Header{header}, cpr::ConnectTimeout{10000}, cpr::Timeout{20000});
    MSDict responseDict;
    MSJson::deserialize(StringUtils::toWideString(response.text), responseDict);

    //verify response
    std::shared_ptr<CheckAPIKey> shouldReportErr = std::make_shared<CheckAPIKey>();
    MSDict errorDict = shouldReportErr->ShouldReportError(response);
    outDict = ms_dict_object{
        { MS_KEY_VALID_API_KEY,  errorDict.isNull()},
        { MS_KEY_ERROR,          errorDict},
        { MS_KEY_API_KEY_INFO,   responseDict}
    };
    return rc;
}

ms_rc MDServerConnection::getApiKeyLimit(const MSDict &reqHeader, const MSDict &inDict, MSDict &outDict)
{
    ms_rc rc = MS_OK;
    ms_wstring url;
    ms_int serverType;
    if( MS_FAILED (rc = inDict.val(MS_KEY_URL, url)) ||
        MS_FAILED (rc = inDict.val(MS_KEY_TYPE, serverType))){
            return rc;
    }
    if(serverType == MDServerType::MDCore){
        return MS_OK;
    }
    cpr::Header header;
    if( !reqHeader.isObject() ){
        MS_LOGGER_ERROR("[layers] [internal] request header dict is not valid");
    }
    for( auto i : reqHeader.keys()){
        ms_wstring value;
        reqHeader.val(i, value);
        header[StringUtils::toString(i)] = StringUtils::toString(value);
    }

    ms_wstring reqUrl =  url + L"/hash/E71A6D8760B37E45FA09D3E1E67E2CD3";
    cpr::Response response = cpr::Get(cpr::Url{StringUtils::toString(reqUrl)},  cpr::VerifySsl{false}, cpr::Header{header}, cpr::ConnectTimeout{10000}, cpr::Timeout{20000});
    MSDict responseDict;
    for(auto i : response.header){
        responseDict.add( StringUtils::toWideString(i.first), StringUtils::toWideString(i.second) );
    }

    std::shared_ptr<CheckAPIKeyLimit> shouldReportErr = std::make_shared<CheckAPIKeyLimit>();
    MSDict errorDict = shouldReportErr->ShouldReportError(response);
    //handle result
    outDict = ms_dict_object{
        { MS_KEY_NO_REACH_LIMIT, errorDict.isNull() },
        { MS_KEY_ERROR, L"" },
        { MS_KEY_API_KEY_LIMITS, responseDict }  
    };
    ms_wstring tmp;
    MSJson::serialize(outDict, tmp);
    return rc;

}

ms_rc MDServerConnection::getScanRuleFromMDCore(const MSDict &reqHeader, const MSDict &inDict, MSDict &outDict)
{
    ms_rc rc = MS_OK;
    ms_wstring url;
    ms_int serverType;
    if( MS_FAILED (rc = inDict.val(MS_KEY_URL, url)) ||
        MS_FAILED (rc = inDict.val(MS_KEY_TYPE, serverType))){
            return rc;
    }
    if(serverType == MDServerType::MDCore){
        return MS_OK;
    }
    cpr::Header header;
    if( !reqHeader.isObject() ){
        MS_LOGGER_ERROR("[layers] [internal] request header dict is not valid");
    }
    for( auto i : reqHeader.keys()){
        ms_wstring value;
        reqHeader.val(i, value);
        header[StringUtils::toString(i)] = StringUtils::toString(value);
    }

    ms_wstring reqUrl =  L"file/rules";
    cpr::Response response = cpr::Get(cpr::Url{StringUtils::toString(reqUrl)},  cpr::VerifySsl{false}, cpr::Header{header}, cpr::ConnectTimeout{10000}, cpr::Timeout{20000});
    MSDict responseDict;
    MSJson::deserialize(StringUtils::toWideString(response.text), responseDict);
    ms_wstring errorMessage;
    if(!Internal::isStatusCode200s(response.status_code)){
        errorMessage = StringUtils::toWideString(response.error.message);
    }
    //handle result
    outDict = ms_dict_object{
        { MS_KEY_ERROR,         errorMessage },
        { MS_KEY_SCAN_RULES,    responseDict }  
    };
}

ms_rc MDServerConnection::getServerStatus(const MSDict &config, MSDict &res)
{
    ms_rc rc = MS_OK;
    res.become(MSDictType::OBJECT);
    MSDict reqHeader, additionalInfo, apiVer, serverStatus {MSDictType::OBJECT};
    if( MS_FAILED ( rc = generateReqHeader(config, reqHeader, additionalInfo))){
        MS_LOGGER_ERROR("{} can not generate report header", MS_LABEL_SERVER_CONNECTION);
        return rc;
    }
    ms_int serverType = additionalInfo[MS_KEY_TYPE].intVal();
    ms_bool isValid;
    //Check api version
    if( MS_FAILED( rc = MDServerConnection::checkApiVersion(reqHeader, additionalInfo, serverStatus, isValid))){
        MS_LOGGER_ERROR("{} can not get API version", MS_LABEL_SERVER_CONNECTION);
        return rc;
    }
    else if(!isValid){
        res.add(MS_KEY_RESULT, serverStatus);
        return rc;
    }
    ms_wstring tmp;
    MSJson::serialize(serverStatus, tmp);
    //Check api key info
    if( MS_FAILED( rc = MDServerConnection::checkApiKeyInfo(reqHeader, additionalInfo, serverStatus, isValid))){
        MS_LOGGER_ERROR("{} can not get check apikey info", MS_LABEL_SERVER_CONNECTION);
        return rc;
    }
    else if(!isValid){
        res.add(MS_KEY_RESULT, serverStatus);
        return rc;
    }
    /*
        Check API connection for specific MD server:
            - Core: scan rules
            - Cloud: reach limit?
    */
    if (serverType == MDCloud) {
        MSDict limits;
        ms_bool isNoReachLimit;
        if( MS_FAILED(rc = MDServerConnection::getApiKeyLimit(reqHeader, additionalInfo, limits)) ||
            MS_FAILED( rc = limits.val(MS_KEY_NO_REACH_LIMIT, isNoReachLimit)) ){
            MS_LOGGER_ERROR("{} can not get reach limit", MS_LABEL_SERVER_CONNECTION);
            return rc;
        }
        serverStatus.add(MS_KEY_API_KEY_LIMITS, limits);
        if (!isNoReachLimit) {
            serverStatus.add(MS_KEY_CODE, LimitReached);
            serverStatus.add(MS_KEY_ERROR_MSG,  limits[MS_KEY_ERROR][MS_KEY_INFECT_ERR][MS_KEY_ERROR_MSG].stringVal());
            serverStatus.add(MS_KEY_ERROR, limits[MS_KEY_ERROR]);
            res.add(MS_KEY_RESULT, serverStatus);
            return rc;
        }
    }
    else{
        ms_wstring rule;
        additionalInfo.val(MS_KEY_RULE,rule);
        MSDict rules,scanRules;
        if(MS_FAILED ( rc = MDServerConnection::getScanRuleFromMDCore(reqHeader, additionalInfo, rules) ) ||
           MS_FAILED ( rc = rules.val(MS_KEY_SCAN_RULES, scanRules) )){
            MS_LOGGER_ERROR("{} can not get scan rule on core", MS_LABEL_SERVER_CONNECTION);
            return rc;
        }
        for (int i = 0; i < scanRules.size(); i++) {
            MSDict availableRule = scanRules[i];
            ms_wstring ruleName;
            availableRule.val(MS_KEY_NAME, ruleName);
            if (rule == ruleName) {
                res.add(MS_KEY_RESULT, serverStatus);
                return rc;
            }
        }
        //limit reached????
        serverStatus.add(MS_KEY_CODE, LimitReached);
        serverStatus.add(MS_KEY_ERROR_MSG, L"No available rule is present for scanning");
    }
    
    res.add(MS_KEY_RESULT, serverStatus);
    MSJson::serialize(res, tmp);
    return rc;
}

ms_rc MDServerConnection::checkApiVersion(const MSDict &reqHeader, const MSDict &additionalInfo, MSDict &serverStatus, bool &res)
{
    ms_rc rc = MS_OK;
    MSDict apiVer;
    if ( MS_FAILED( rc = MDServerConnection::getApiVersion(reqHeader, additionalInfo, apiVer))){
        MS_LOGGER_ERROR("{} can not get API version", MS_LABEL_SERVER_CONNECTION);
        return rc;
    }
    rc = serverStatus.add(MS_KEY_SERVERS, apiVer);
    rc = serverStatus.add(MS_KEY_CODE, int(Scannable));

    ms_bool isConnected = true;
    if ( MS_SUCCESS( rc = apiVer.val(MS_KEY_CONNECTED, isConnected) ) && isConnected == false){
        MS_LOGGER_ERROR("{} API version is not valid", MS_LABEL_SERVER_CONNECTION);
        serverStatus.add(MS_KEY_CODE, Disconnected);
        //need enhance
        serverStatus.add(MS_KEY_ERROR_MSG,  apiVer[MS_KEY_ERROR][MS_KEY_INFECT_ERR][MS_KEY_ERROR_MSG].stringVal());
        res = false;
        return rc;
    }
    //Handler Core < 4.16.2
    ms_wstring version;
    if( MS_SUCCESS(apiVer.val(MS_KEY_VERSION, version)) && version == L"" ){
        serverStatus.add(MS_KEY_CODE, int(Scannable));
        res = false;
        return rc;
    }
    //Maybe the case above cover this, check later
    // ApiVersion coreAPIVersion(StringUtils::toString(version));
    // if( !coreAPIVersion.isNewCoreVersion() && serverType == MDServerType::MDCore ){
    //     res.add(MS_KEY_RESULT, serverStatus);
    //     return rc;
    // }

    res = true;
    return rc;
}

ms_rc MDServerConnection::checkApiKeyInfo(const MSDict &reqHeader, const MSDict &additionalInfo, MSDict &serverStatus, bool &res)
{
    ms_rc rc = MS_OK;
    MSDict apikeyInfo;
    MDServerConnection::getApiKeyInfo(reqHeader, additionalInfo, apikeyInfo);
    serverStatus.add(MS_KEY_API_KEY, apikeyInfo);
    ms_bool isApiKeyValid;
    if(MS_FAILED( rc = apikeyInfo.val(MS_KEY_VALID_API_KEY, isApiKeyValid)) ){
        res = false;
        return rc; 
    }
    if( !isApiKeyValid){
        serverStatus.add(MS_KEY_CODE, InvalidApiKey);
        serverStatus.add(MS_KEY_ERROR_MSG,  apikeyInfo[MS_KEY_ERROR][MS_KEY_INFECT_ERR][MS_KEY_ERROR_MSG].stringVal());
        serverStatus.add(MS_KEY_ERROR, apikeyInfo[MS_KEY_ERROR]);
        res = false;
        return rc;
    }
    res = true;
    return rc;
}

namespace
{
namespace Internal
{
    ms_rc requestAPI(const MSDict& reqHeader, ms_string reqUrl, MSDict& responseDict, RequestType t){

    }
}
}